// Generated by gir (https://github.com/gtk-rs/gir @ 88259bc5f36f+)
// from ../../gir/gir-files (@ 1783d05ebac3+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use glib_sys as glib;
use gio_sys as gio;
use gobject_sys as gobject;

#[allow(unused_imports)]
use std::ffi::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong, c_void};
#[allow(unused_imports)]
use libc::{size_t, ssize_t, time_t, off_t, intptr_t, uintptr_t, FILE};
#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t, stat, in6_addr};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type NM80211Mode = c_int;
pub const NM_802_11_MODE_UNKNOWN: NM80211Mode = 0;
pub const NM_802_11_MODE_ADHOC: NM80211Mode = 1;
pub const NM_802_11_MODE_INFRA: NM80211Mode = 2;
pub const NM_802_11_MODE_AP: NM80211Mode = 3;
pub const NM_802_11_MODE_MESH: NM80211Mode = 4;

pub type NMActiveConnectionState = c_int;
pub const NM_ACTIVE_CONNECTION_STATE_UNKNOWN: NMActiveConnectionState = 0;
pub const NM_ACTIVE_CONNECTION_STATE_ACTIVATING: NMActiveConnectionState = 1;
pub const NM_ACTIVE_CONNECTION_STATE_ACTIVATED: NMActiveConnectionState = 2;
pub const NM_ACTIVE_CONNECTION_STATE_DEACTIVATING: NMActiveConnectionState = 3;
pub const NM_ACTIVE_CONNECTION_STATE_DEACTIVATED: NMActiveConnectionState = 4;

pub type NMActiveConnectionStateReason = c_int;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN: NMActiveConnectionStateReason = 0;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_NONE: NMActiveConnectionStateReason = 1;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED: NMActiveConnectionStateReason = 2;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED: NMActiveConnectionStateReason = 3;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED: NMActiveConnectionStateReason = 4;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID: NMActiveConnectionStateReason = 5;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT: NMActiveConnectionStateReason = 6;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT: NMActiveConnectionStateReason = 7;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED: NMActiveConnectionStateReason = 8;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS: NMActiveConnectionStateReason = 9;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED: NMActiveConnectionStateReason = 10;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED: NMActiveConnectionStateReason = 11;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED: NMActiveConnectionStateReason = 12;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED: NMActiveConnectionStateReason = 13;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED: NMActiveConnectionStateReason = 14;

pub type NMAgentManagerError = c_int;
pub const NM_AGENT_MANAGER_ERROR_FAILED: NMAgentManagerError = 0;
pub const NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED: NMAgentManagerError = 1;
pub const NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER: NMAgentManagerError = 2;
pub const NM_AGENT_MANAGER_ERROR_NOT_REGISTERED: NMAgentManagerError = 3;
pub const NM_AGENT_MANAGER_ERROR_NO_SECRETS: NMAgentManagerError = 4;
pub const NM_AGENT_MANAGER_ERROR_USER_CANCELED: NMAgentManagerError = 5;

pub type NMCapability = c_int;
pub const NM_CAPABILITY_TEAM: NMCapability = 1;
pub const NM_CAPABILITY_OVS: NMCapability = 2;

pub type NMClientError = c_int;
pub const NM_CLIENT_ERROR_FAILED: NMClientError = 0;
pub const NM_CLIENT_ERROR_MANAGER_NOT_RUNNING: NMClientError = 1;
pub const NM_CLIENT_ERROR_OBJECT_CREATION_FAILED: NMClientError = 2;

pub type NMClientPermission = c_int;
pub const NM_CLIENT_PERMISSION_NONE: NMClientPermission = 0;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK: NMClientPermission = 1;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI: NMClientPermission = 2;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN: NMClientPermission = 3;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX: NMClientPermission = 4;
pub const NM_CLIENT_PERMISSION_SLEEP_WAKE: NMClientPermission = 5;
pub const NM_CLIENT_PERMISSION_NETWORK_CONTROL: NMClientPermission = 6;
pub const NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED: NMClientPermission = 7;
pub const NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN: NMClientPermission = 8;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM: NMClientPermission = 9;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN: NMClientPermission = 10;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME: NMClientPermission = 11;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS: NMClientPermission = 12;
pub const NM_CLIENT_PERMISSION_RELOAD: NMClientPermission = 13;
pub const NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK: NMClientPermission = 14;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS: NMClientPermission = 15;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK: NMClientPermission = 16;
pub const NM_CLIENT_PERMISSION_WIFI_SCAN: NMClientPermission = 17;
pub const NM_CLIENT_PERMISSION_LAST: NMClientPermission = 17;

pub type NMClientPermissionResult = c_int;
pub const NM_CLIENT_PERMISSION_RESULT_UNKNOWN: NMClientPermissionResult = 0;
pub const NM_CLIENT_PERMISSION_RESULT_YES: NMClientPermissionResult = 1;
pub const NM_CLIENT_PERMISSION_RESULT_AUTH: NMClientPermissionResult = 2;
pub const NM_CLIENT_PERMISSION_RESULT_NO: NMClientPermissionResult = 3;

pub type NMConnectionError = c_int;
pub const NM_CONNECTION_ERROR_FAILED: NMConnectionError = 0;
pub const NM_CONNECTION_ERROR_SETTING_NOT_FOUND: NMConnectionError = 1;
pub const NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND: NMConnectionError = 2;
pub const NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET: NMConnectionError = 3;
pub const NM_CONNECTION_ERROR_MISSING_SETTING: NMConnectionError = 4;
pub const NM_CONNECTION_ERROR_INVALID_SETTING: NMConnectionError = 5;
pub const NM_CONNECTION_ERROR_MISSING_PROPERTY: NMConnectionError = 6;
pub const NM_CONNECTION_ERROR_INVALID_PROPERTY: NMConnectionError = 7;

pub type NMConnectionMultiConnect = c_int;
pub const NM_CONNECTION_MULTI_CONNECT_DEFAULT: NMConnectionMultiConnect = 0;
pub const NM_CONNECTION_MULTI_CONNECT_SINGLE: NMConnectionMultiConnect = 1;
pub const NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE: NMConnectionMultiConnect = 2;
pub const NM_CONNECTION_MULTI_CONNECT_MULTIPLE: NMConnectionMultiConnect = 3;

pub type NMConnectivityState = c_int;
pub const NM_CONNECTIVITY_UNKNOWN: NMConnectivityState = 0;
pub const NM_CONNECTIVITY_NONE: NMConnectivityState = 1;
pub const NM_CONNECTIVITY_PORTAL: NMConnectivityState = 2;
pub const NM_CONNECTIVITY_LIMITED: NMConnectivityState = 3;
pub const NM_CONNECTIVITY_FULL: NMConnectivityState = 4;

pub type NMCryptoError = c_int;
pub const NM_CRYPTO_ERROR_FAILED: NMCryptoError = 0;
pub const NM_CRYPTO_ERROR_INVALID_DATA: NMCryptoError = 1;
pub const NM_CRYPTO_ERROR_INVALID_PASSWORD: NMCryptoError = 2;
pub const NM_CRYPTO_ERROR_UNKNOWN_CIPHER: NMCryptoError = 3;
pub const NM_CRYPTO_ERROR_DECRYPTION_FAILED: NMCryptoError = 4;
pub const NM_CRYPTO_ERROR_ENCRYPTION_FAILED: NMCryptoError = 5;

pub type NMDeviceError = c_int;
pub const NM_DEVICE_ERROR_FAILED: NMDeviceError = 0;
pub const NM_DEVICE_ERROR_CREATION_FAILED: NMDeviceError = 1;
pub const NM_DEVICE_ERROR_INVALID_CONNECTION: NMDeviceError = 2;
pub const NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION: NMDeviceError = 3;
pub const NM_DEVICE_ERROR_NOT_ACTIVE: NMDeviceError = 4;
pub const NM_DEVICE_ERROR_NOT_SOFTWARE: NMDeviceError = 5;
pub const NM_DEVICE_ERROR_NOT_ALLOWED: NMDeviceError = 6;
pub const NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND: NMDeviceError = 7;
pub const NM_DEVICE_ERROR_VERSION_ID_MISMATCH: NMDeviceError = 8;
pub const NM_DEVICE_ERROR_MISSING_DEPENDENCIES: NMDeviceError = 9;
pub const NM_DEVICE_ERROR_INVALID_ARGUMENT: NMDeviceError = 10;

pub type NMDeviceState = c_int;
pub const NM_DEVICE_STATE_UNKNOWN: NMDeviceState = 0;
pub const NM_DEVICE_STATE_UNMANAGED: NMDeviceState = 10;
pub const NM_DEVICE_STATE_UNAVAILABLE: NMDeviceState = 20;
pub const NM_DEVICE_STATE_DISCONNECTED: NMDeviceState = 30;
pub const NM_DEVICE_STATE_PREPARE: NMDeviceState = 40;
pub const NM_DEVICE_STATE_CONFIG: NMDeviceState = 50;
pub const NM_DEVICE_STATE_NEED_AUTH: NMDeviceState = 60;
pub const NM_DEVICE_STATE_IP_CONFIG: NMDeviceState = 70;
pub const NM_DEVICE_STATE_IP_CHECK: NMDeviceState = 80;
pub const NM_DEVICE_STATE_SECONDARIES: NMDeviceState = 90;
pub const NM_DEVICE_STATE_ACTIVATED: NMDeviceState = 100;
pub const NM_DEVICE_STATE_DEACTIVATING: NMDeviceState = 110;
pub const NM_DEVICE_STATE_FAILED: NMDeviceState = 120;

pub type NMDeviceStateReason = c_int;
pub const NM_DEVICE_STATE_REASON_NONE: NMDeviceStateReason = 0;
pub const NM_DEVICE_STATE_REASON_UNKNOWN: NMDeviceStateReason = 1;
pub const NM_DEVICE_STATE_REASON_NOW_MANAGED: NMDeviceStateReason = 2;
pub const NM_DEVICE_STATE_REASON_NOW_UNMANAGED: NMDeviceStateReason = 3;
pub const NM_DEVICE_STATE_REASON_CONFIG_FAILED: NMDeviceStateReason = 4;
pub const NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE: NMDeviceStateReason = 5;
pub const NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED: NMDeviceStateReason = 6;
pub const NM_DEVICE_STATE_REASON_NO_SECRETS: NMDeviceStateReason = 7;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT: NMDeviceStateReason = 8;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED: NMDeviceStateReason = 9;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED: NMDeviceStateReason = 10;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT: NMDeviceStateReason = 11;
pub const NM_DEVICE_STATE_REASON_PPP_START_FAILED: NMDeviceStateReason = 12;
pub const NM_DEVICE_STATE_REASON_PPP_DISCONNECT: NMDeviceStateReason = 13;
pub const NM_DEVICE_STATE_REASON_PPP_FAILED: NMDeviceStateReason = 14;
pub const NM_DEVICE_STATE_REASON_DHCP_START_FAILED: NMDeviceStateReason = 15;
pub const NM_DEVICE_STATE_REASON_DHCP_ERROR: NMDeviceStateReason = 16;
pub const NM_DEVICE_STATE_REASON_DHCP_FAILED: NMDeviceStateReason = 17;
pub const NM_DEVICE_STATE_REASON_SHARED_START_FAILED: NMDeviceStateReason = 18;
pub const NM_DEVICE_STATE_REASON_SHARED_FAILED: NMDeviceStateReason = 19;
pub const NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED: NMDeviceStateReason = 20;
pub const NM_DEVICE_STATE_REASON_AUTOIP_ERROR: NMDeviceStateReason = 21;
pub const NM_DEVICE_STATE_REASON_AUTOIP_FAILED: NMDeviceStateReason = 22;
pub const NM_DEVICE_STATE_REASON_MODEM_BUSY: NMDeviceStateReason = 23;
pub const NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE: NMDeviceStateReason = 24;
pub const NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER: NMDeviceStateReason = 25;
pub const NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT: NMDeviceStateReason = 26;
pub const NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED: NMDeviceStateReason = 27;
pub const NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED: NMDeviceStateReason = 28;
pub const NM_DEVICE_STATE_REASON_GSM_APN_FAILED: NMDeviceStateReason = 29;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING: NMDeviceStateReason = 30;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED: NMDeviceStateReason = 31;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT: NMDeviceStateReason = 32;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED: NMDeviceStateReason = 33;
pub const NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED: NMDeviceStateReason = 34;
pub const NM_DEVICE_STATE_REASON_FIRMWARE_MISSING: NMDeviceStateReason = 35;
pub const NM_DEVICE_STATE_REASON_REMOVED: NMDeviceStateReason = 36;
pub const NM_DEVICE_STATE_REASON_SLEEPING: NMDeviceStateReason = 37;
pub const NM_DEVICE_STATE_REASON_CONNECTION_REMOVED: NMDeviceStateReason = 38;
pub const NM_DEVICE_STATE_REASON_USER_REQUESTED: NMDeviceStateReason = 39;
pub const NM_DEVICE_STATE_REASON_CARRIER: NMDeviceStateReason = 40;
pub const NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED: NMDeviceStateReason = 41;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE: NMDeviceStateReason = 42;
pub const NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND: NMDeviceStateReason = 43;
pub const NM_DEVICE_STATE_REASON_BT_FAILED: NMDeviceStateReason = 44;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED: NMDeviceStateReason = 45;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED: NMDeviceStateReason = 46;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED: NMDeviceStateReason = 47;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_WRONG: NMDeviceStateReason = 48;
pub const NM_DEVICE_STATE_REASON_INFINIBAND_MODE: NMDeviceStateReason = 49;
pub const NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED: NMDeviceStateReason = 50;
pub const NM_DEVICE_STATE_REASON_BR2684_FAILED: NMDeviceStateReason = 51;
pub const NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE: NMDeviceStateReason = 52;
pub const NM_DEVICE_STATE_REASON_SSID_NOT_FOUND: NMDeviceStateReason = 53;
pub const NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED: NMDeviceStateReason = 54;
pub const NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED: NMDeviceStateReason = 55;
pub const NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED: NMDeviceStateReason = 56;
pub const NM_DEVICE_STATE_REASON_MODEM_FAILED: NMDeviceStateReason = 57;
pub const NM_DEVICE_STATE_REASON_MODEM_AVAILABLE: NMDeviceStateReason = 58;
pub const NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT: NMDeviceStateReason = 59;
pub const NM_DEVICE_STATE_REASON_NEW_ACTIVATION: NMDeviceStateReason = 60;
pub const NM_DEVICE_STATE_REASON_PARENT_CHANGED: NMDeviceStateReason = 61;
pub const NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED: NMDeviceStateReason = 62;
pub const NM_DEVICE_STATE_REASON_OVSDB_FAILED: NMDeviceStateReason = 63;
pub const NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE: NMDeviceStateReason = 64;
pub const NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED: NMDeviceStateReason = 65;
pub const NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED: NMDeviceStateReason = 66;
pub const NM_DEVICE_STATE_REASON_PEER_NOT_FOUND: NMDeviceStateReason = 67;
pub const NM_DEVICE_STATE_REASON_DEVICE_HANDLER_FAILED: NMDeviceStateReason = 68;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_BY_DEFAULT: NMDeviceStateReason = 69;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_EXTERNAL_DOWN: NMDeviceStateReason = 70;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_LINK_NOT_INIT: NMDeviceStateReason = 71;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_QUITTING: NMDeviceStateReason = 72;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_SLEEPING: NMDeviceStateReason = 73;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_USER_CONF: NMDeviceStateReason = 74;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_USER_EXPLICIT: NMDeviceStateReason = 75;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_USER_SETTINGS: NMDeviceStateReason = 76;
pub const NM_DEVICE_STATE_REASON_UNMANAGED_USER_UDEV: NMDeviceStateReason = 77;

pub type NMDeviceType = c_int;
pub const NM_DEVICE_TYPE_UNKNOWN: NMDeviceType = 0;
pub const NM_DEVICE_TYPE_ETHERNET: NMDeviceType = 1;
pub const NM_DEVICE_TYPE_WIFI: NMDeviceType = 2;
pub const NM_DEVICE_TYPE_UNUSED1: NMDeviceType = 3;
pub const NM_DEVICE_TYPE_UNUSED2: NMDeviceType = 4;
pub const NM_DEVICE_TYPE_BT: NMDeviceType = 5;
pub const NM_DEVICE_TYPE_OLPC_MESH: NMDeviceType = 6;
pub const NM_DEVICE_TYPE_WIMAX: NMDeviceType = 7;
pub const NM_DEVICE_TYPE_MODEM: NMDeviceType = 8;
pub const NM_DEVICE_TYPE_INFINIBAND: NMDeviceType = 9;
pub const NM_DEVICE_TYPE_BOND: NMDeviceType = 10;
pub const NM_DEVICE_TYPE_VLAN: NMDeviceType = 11;
pub const NM_DEVICE_TYPE_ADSL: NMDeviceType = 12;
pub const NM_DEVICE_TYPE_BRIDGE: NMDeviceType = 13;
pub const NM_DEVICE_TYPE_GENERIC: NMDeviceType = 14;
pub const NM_DEVICE_TYPE_TEAM: NMDeviceType = 15;
pub const NM_DEVICE_TYPE_TUN: NMDeviceType = 16;
pub const NM_DEVICE_TYPE_IP_TUNNEL: NMDeviceType = 17;
pub const NM_DEVICE_TYPE_MACVLAN: NMDeviceType = 18;
pub const NM_DEVICE_TYPE_VXLAN: NMDeviceType = 19;
pub const NM_DEVICE_TYPE_VETH: NMDeviceType = 20;
pub const NM_DEVICE_TYPE_MACSEC: NMDeviceType = 21;
pub const NM_DEVICE_TYPE_DUMMY: NMDeviceType = 22;
pub const NM_DEVICE_TYPE_PPP: NMDeviceType = 23;
pub const NM_DEVICE_TYPE_OVS_INTERFACE: NMDeviceType = 24;
pub const NM_DEVICE_TYPE_OVS_PORT: NMDeviceType = 25;
pub const NM_DEVICE_TYPE_OVS_BRIDGE: NMDeviceType = 26;
pub const NM_DEVICE_TYPE_WPAN: NMDeviceType = 27;
pub const NM_DEVICE_TYPE_6LOWPAN: NMDeviceType = 28;
pub const NM_DEVICE_TYPE_WIREGUARD: NMDeviceType = 29;
pub const NM_DEVICE_TYPE_WIFI_P2P: NMDeviceType = 30;
pub const NM_DEVICE_TYPE_VRF: NMDeviceType = 31;
pub const NM_DEVICE_TYPE_LOOPBACK: NMDeviceType = 32;
pub const NM_DEVICE_TYPE_HSR: NMDeviceType = 33;

pub type NMIPTunnelMode = c_int;
pub const NM_IP_TUNNEL_MODE_UNKNOWN: NMIPTunnelMode = 0;
pub const NM_IP_TUNNEL_MODE_IPIP: NMIPTunnelMode = 1;
pub const NM_IP_TUNNEL_MODE_GRE: NMIPTunnelMode = 2;
pub const NM_IP_TUNNEL_MODE_SIT: NMIPTunnelMode = 3;
pub const NM_IP_TUNNEL_MODE_ISATAP: NMIPTunnelMode = 4;
pub const NM_IP_TUNNEL_MODE_VTI: NMIPTunnelMode = 5;
pub const NM_IP_TUNNEL_MODE_IP6IP6: NMIPTunnelMode = 6;
pub const NM_IP_TUNNEL_MODE_IPIP6: NMIPTunnelMode = 7;
pub const NM_IP_TUNNEL_MODE_IP6GRE: NMIPTunnelMode = 8;
pub const NM_IP_TUNNEL_MODE_VTI6: NMIPTunnelMode = 9;
pub const NM_IP_TUNNEL_MODE_GRETAP: NMIPTunnelMode = 10;
pub const NM_IP_TUNNEL_MODE_IP6GRETAP: NMIPTunnelMode = 11;

pub type NMKeyfileHandlerType = c_int;
pub const NM_KEYFILE_HANDLER_TYPE_WARN: NMKeyfileHandlerType = 1;
pub const NM_KEYFILE_HANDLER_TYPE_WRITE_CERT: NMKeyfileHandlerType = 2;

pub type NMKeyfileWarnSeverity = c_int;
pub const NM_KEYFILE_WARN_SEVERITY_DEBUG: NMKeyfileWarnSeverity = 1000;
pub const NM_KEYFILE_WARN_SEVERITY_INFO: NMKeyfileWarnSeverity = 2000;
pub const NM_KEYFILE_WARN_SEVERITY_INFO_MISSING_FILE: NMKeyfileWarnSeverity = 2901;
pub const NM_KEYFILE_WARN_SEVERITY_WARN: NMKeyfileWarnSeverity = 3000;

pub type NMManagerError = c_int;
pub const NM_MANAGER_ERROR_FAILED: NMManagerError = 0;
pub const NM_MANAGER_ERROR_PERMISSION_DENIED: NMManagerError = 1;
pub const NM_MANAGER_ERROR_UNKNOWN_CONNECTION: NMManagerError = 2;
pub const NM_MANAGER_ERROR_UNKNOWN_DEVICE: NMManagerError = 3;
pub const NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE: NMManagerError = 4;
pub const NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE: NMManagerError = 5;
pub const NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE: NMManagerError = 6;
pub const NM_MANAGER_ERROR_DEPENDENCY_FAILED: NMManagerError = 7;
pub const NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE: NMManagerError = 8;
pub const NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED: NMManagerError = 9;
pub const NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL: NMManagerError = 10;
pub const NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN: NMManagerError = 11;
pub const NM_MANAGER_ERROR_INVALID_ARGUMENTS: NMManagerError = 12;
pub const NM_MANAGER_ERROR_MISSING_PLUGIN: NMManagerError = 13;

pub type NMMetered = c_int;
pub const NM_METERED_UNKNOWN: NMMetered = 0;
pub const NM_METERED_YES: NMMetered = 1;
pub const NM_METERED_NO: NMMetered = 2;
pub const NM_METERED_GUESS_YES: NMMetered = 3;
pub const NM_METERED_GUESS_NO: NMMetered = 4;

pub type NMRollbackResult = c_int;
pub const NM_ROLLBACK_RESULT_OK: NMRollbackResult = 0;
pub const NM_ROLLBACK_RESULT_ERR_NO_DEVICE: NMRollbackResult = 1;
pub const NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED: NMRollbackResult = 2;
pub const NM_ROLLBACK_RESULT_ERR_FAILED: NMRollbackResult = 3;

pub type NMSecretAgentError = c_int;
pub const NM_SECRET_AGENT_ERROR_FAILED: NMSecretAgentError = 0;
pub const NM_SECRET_AGENT_ERROR_PERMISSION_DENIED: NMSecretAgentError = 1;
pub const NM_SECRET_AGENT_ERROR_INVALID_CONNECTION: NMSecretAgentError = 2;
pub const NM_SECRET_AGENT_ERROR_USER_CANCELED: NMSecretAgentError = 3;
pub const NM_SECRET_AGENT_ERROR_AGENT_CANCELED: NMSecretAgentError = 4;
pub const NM_SECRET_AGENT_ERROR_NO_SECRETS: NMSecretAgentError = 5;

pub type NMSetting8021xCKFormat = c_int;
pub const NM_SETTING_802_1X_CK_FORMAT_UNKNOWN: NMSetting8021xCKFormat = 0;
pub const NM_SETTING_802_1X_CK_FORMAT_X509: NMSetting8021xCKFormat = 1;
pub const NM_SETTING_802_1X_CK_FORMAT_RAW_KEY: NMSetting8021xCKFormat = 2;
pub const NM_SETTING_802_1X_CK_FORMAT_PKCS12: NMSetting8021xCKFormat = 3;

pub type NMSetting8021xCKScheme = c_int;
pub const NM_SETTING_802_1X_CK_SCHEME_UNKNOWN: NMSetting8021xCKScheme = 0;
pub const NM_SETTING_802_1X_CK_SCHEME_BLOB: NMSetting8021xCKScheme = 1;
pub const NM_SETTING_802_1X_CK_SCHEME_PATH: NMSetting8021xCKScheme = 2;
pub const NM_SETTING_802_1X_CK_SCHEME_PKCS11: NMSetting8021xCKScheme = 3;

pub type NMSettingCompareFlags = c_int;
pub const NM_SETTING_COMPARE_FLAG_EXACT: NMSettingCompareFlags = 0;
pub const NM_SETTING_COMPARE_FLAG_FUZZY: NMSettingCompareFlags = 1;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_ID: NMSettingCompareFlags = 2;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS: NMSettingCompareFlags = 4;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS: NMSettingCompareFlags = 8;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS: NMSettingCompareFlags = 16;
pub const NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT: NMSettingCompareFlags = 32;
pub const NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT: NMSettingCompareFlags = 64;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP: NMSettingCompareFlags = 128;

pub type NMSettingConnectionAutoconnectSlaves = c_int;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT: NMSettingConnectionAutoconnectSlaves = -1;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO: NMSettingConnectionAutoconnectSlaves = 0;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES: NMSettingConnectionAutoconnectSlaves = 1;

pub type NMSettingConnectionDnsOverTls = c_int;
pub const NM_SETTING_CONNECTION_DNS_OVER_TLS_DEFAULT: NMSettingConnectionDnsOverTls = -1;
pub const NM_SETTING_CONNECTION_DNS_OVER_TLS_NO: NMSettingConnectionDnsOverTls = 0;
pub const NM_SETTING_CONNECTION_DNS_OVER_TLS_OPPORTUNISTIC: NMSettingConnectionDnsOverTls = 1;
pub const NM_SETTING_CONNECTION_DNS_OVER_TLS_YES: NMSettingConnectionDnsOverTls = 2;

pub type NMSettingConnectionDownOnPoweroff = c_int;
pub const NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_DEFAULT: NMSettingConnectionDownOnPoweroff = -1;
pub const NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_NO: NMSettingConnectionDownOnPoweroff = 0;
pub const NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_YES: NMSettingConnectionDownOnPoweroff = 1;

pub type NMSettingConnectionLldp = c_int;
pub const NM_SETTING_CONNECTION_LLDP_DEFAULT: NMSettingConnectionLldp = -1;
pub const NM_SETTING_CONNECTION_LLDP_DISABLE: NMSettingConnectionLldp = 0;
pub const NM_SETTING_CONNECTION_LLDP_ENABLE_RX: NMSettingConnectionLldp = 1;

pub type NMSettingConnectionLlmnr = c_int;
pub const NM_SETTING_CONNECTION_LLMNR_DEFAULT: NMSettingConnectionLlmnr = -1;
pub const NM_SETTING_CONNECTION_LLMNR_NO: NMSettingConnectionLlmnr = 0;
pub const NM_SETTING_CONNECTION_LLMNR_RESOLVE: NMSettingConnectionLlmnr = 1;
pub const NM_SETTING_CONNECTION_LLMNR_YES: NMSettingConnectionLlmnr = 2;

pub type NMSettingConnectionMdns = c_int;
pub const NM_SETTING_CONNECTION_MDNS_DEFAULT: NMSettingConnectionMdns = -1;
pub const NM_SETTING_CONNECTION_MDNS_NO: NMSettingConnectionMdns = 0;
pub const NM_SETTING_CONNECTION_MDNS_RESOLVE: NMSettingConnectionMdns = 1;
pub const NM_SETTING_CONNECTION_MDNS_YES: NMSettingConnectionMdns = 2;

pub type NMSettingDiffResult = c_int;
pub const NM_SETTING_DIFF_RESULT_UNKNOWN: NMSettingDiffResult = 0;
pub const NM_SETTING_DIFF_RESULT_IN_A: NMSettingDiffResult = 1;
pub const NM_SETTING_DIFF_RESULT_IN_B: NMSettingDiffResult = 2;
pub const NM_SETTING_DIFF_RESULT_IN_A_DEFAULT: NMSettingDiffResult = 4;
pub const NM_SETTING_DIFF_RESULT_IN_B_DEFAULT: NMSettingDiffResult = 8;

pub type NMSettingIP4LinkLocal = c_int;
pub const NM_SETTING_IP4_LL_DEFAULT: NMSettingIP4LinkLocal = 0;
pub const NM_SETTING_IP4_LL_AUTO: NMSettingIP4LinkLocal = 1;
pub const NM_SETTING_IP4_LL_DISABLED: NMSettingIP4LinkLocal = 2;
pub const NM_SETTING_IP4_LL_ENABLED: NMSettingIP4LinkLocal = 3;

pub type NMSettingIP6ConfigAddrGenMode = c_int;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64: NMSettingIP6ConfigAddrGenMode = 0;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY: NMSettingIP6ConfigAddrGenMode = 1;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_DEFAULT_OR_EUI64: NMSettingIP6ConfigAddrGenMode = 2;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_DEFAULT: NMSettingIP6ConfigAddrGenMode = 3;

pub type NMSettingIP6ConfigPrivacy = c_int;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN: NMSettingIP6ConfigPrivacy = -1;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED: NMSettingIP6ConfigPrivacy = 0;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR: NMSettingIP6ConfigPrivacy = 1;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR: NMSettingIP6ConfigPrivacy = 2;

pub type NMSettingMacRandomization = c_int;
pub const NM_SETTING_MAC_RANDOMIZATION_DEFAULT: NMSettingMacRandomization = 0;
pub const NM_SETTING_MAC_RANDOMIZATION_NEVER: NMSettingMacRandomization = 1;
pub const NM_SETTING_MAC_RANDOMIZATION_ALWAYS: NMSettingMacRandomization = 2;

pub type NMSettingMacsecMode = c_int;
pub const NM_SETTING_MACSEC_MODE_PSK: NMSettingMacsecMode = 0;
pub const NM_SETTING_MACSEC_MODE_EAP: NMSettingMacsecMode = 1;

pub type NMSettingMacsecOffload = c_int;
pub const NM_SETTING_MACSEC_OFFLOAD_DEFAULT: NMSettingMacsecOffload = -1;
pub const NM_SETTING_MACSEC_OFFLOAD_OFF: NMSettingMacsecOffload = 0;
pub const NM_SETTING_MACSEC_OFFLOAD_PHY: NMSettingMacsecOffload = 1;
pub const NM_SETTING_MACSEC_OFFLOAD_MAC: NMSettingMacsecOffload = 2;

pub type NMSettingMacsecValidation = c_int;
pub const NM_SETTING_MACSEC_VALIDATION_DISABLE: NMSettingMacsecValidation = 0;
pub const NM_SETTING_MACSEC_VALIDATION_CHECK: NMSettingMacsecValidation = 1;
pub const NM_SETTING_MACSEC_VALIDATION_STRICT: NMSettingMacsecValidation = 2;

pub type NMSettingMacvlanMode = c_int;
pub const NM_SETTING_MACVLAN_MODE_UNKNOWN: NMSettingMacvlanMode = 0;
pub const NM_SETTING_MACVLAN_MODE_VEPA: NMSettingMacvlanMode = 1;
pub const NM_SETTING_MACVLAN_MODE_BRIDGE: NMSettingMacvlanMode = 2;
pub const NM_SETTING_MACVLAN_MODE_PRIVATE: NMSettingMacvlanMode = 3;
pub const NM_SETTING_MACVLAN_MODE_PASSTHRU: NMSettingMacvlanMode = 4;
pub const NM_SETTING_MACVLAN_MODE_SOURCE: NMSettingMacvlanMode = 5;

pub type NMSettingProxyMethod = c_int;
pub const NM_SETTING_PROXY_METHOD_NONE: NMSettingProxyMethod = 0;
pub const NM_SETTING_PROXY_METHOD_AUTO: NMSettingProxyMethod = 1;

pub type NMSettingSerialParity = c_int;
pub const NM_SETTING_SERIAL_PARITY_NONE: NMSettingSerialParity = 0;
pub const NM_SETTING_SERIAL_PARITY_EVEN: NMSettingSerialParity = 1;
pub const NM_SETTING_SERIAL_PARITY_ODD: NMSettingSerialParity = 2;

pub type NMSettingTunMode = c_int;
pub const NM_SETTING_TUN_MODE_UNKNOWN: NMSettingTunMode = 0;
pub const NM_SETTING_TUN_MODE_TUN: NMSettingTunMode = 1;
pub const NM_SETTING_TUN_MODE_TAP: NMSettingTunMode = 2;

pub type NMSettingWirelessChannelWidth = c_int;
pub const NM_SETTING_WIRELESS_CHANNEL_WIDTH_AUTO: NMSettingWirelessChannelWidth = 0;
pub const NM_SETTING_WIRELESS_CHANNEL_WIDTH_20MHZ: NMSettingWirelessChannelWidth = 20;
pub const NM_SETTING_WIRELESS_CHANNEL_WIDTH_40MHZ: NMSettingWirelessChannelWidth = 40;
pub const NM_SETTING_WIRELESS_CHANNEL_WIDTH_80MHZ: NMSettingWirelessChannelWidth = 80;

pub type NMSettingWirelessPowersave = c_int;
pub const NM_SETTING_WIRELESS_POWERSAVE_DEFAULT: NMSettingWirelessPowersave = 0;
pub const NM_SETTING_WIRELESS_POWERSAVE_IGNORE: NMSettingWirelessPowersave = 1;
pub const NM_SETTING_WIRELESS_POWERSAVE_DISABLE: NMSettingWirelessPowersave = 2;
pub const NM_SETTING_WIRELESS_POWERSAVE_ENABLE: NMSettingWirelessPowersave = 3;

pub type NMSettingWirelessSecurityFils = c_int;
pub const NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT: NMSettingWirelessSecurityFils = 0;
pub const NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE: NMSettingWirelessSecurityFils = 1;
pub const NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL: NMSettingWirelessSecurityFils = 2;
pub const NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED: NMSettingWirelessSecurityFils = 3;

pub type NMSettingWirelessSecurityPmf = c_int;
pub const NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT: NMSettingWirelessSecurityPmf = 0;
pub const NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE: NMSettingWirelessSecurityPmf = 1;
pub const NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL: NMSettingWirelessSecurityPmf = 2;
pub const NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED: NMSettingWirelessSecurityPmf = 3;

pub type NMSettingsError = c_int;
pub const NM_SETTINGS_ERROR_FAILED: NMSettingsError = 0;
pub const NM_SETTINGS_ERROR_PERMISSION_DENIED: NMSettingsError = 1;
pub const NM_SETTINGS_ERROR_NOT_SUPPORTED: NMSettingsError = 2;
pub const NM_SETTINGS_ERROR_INVALID_CONNECTION: NMSettingsError = 3;
pub const NM_SETTINGS_ERROR_READ_ONLY_CONNECTION: NMSettingsError = 4;
pub const NM_SETTINGS_ERROR_UUID_EXISTS: NMSettingsError = 5;
pub const NM_SETTINGS_ERROR_INVALID_HOSTNAME: NMSettingsError = 6;
pub const NM_SETTINGS_ERROR_INVALID_ARGUMENTS: NMSettingsError = 7;
pub const NM_SETTINGS_ERROR_VERSION_ID_MISMATCH: NMSettingsError = 8;
pub const NM_SETTINGS_ERROR_NOT_SUPPORTED_BY_PLUGIN: NMSettingsError = 9;

pub type NMSriovEswitchEncapMode = c_int;
pub const NM_SRIOV_ESWITCH_ENCAP_MODE_PRESERVE: NMSriovEswitchEncapMode = -1;
pub const NM_SRIOV_ESWITCH_ENCAP_MODE_NONE: NMSriovEswitchEncapMode = 0;
pub const NM_SRIOV_ESWITCH_ENCAP_MODE_BASIC: NMSriovEswitchEncapMode = 1;

pub type NMSriovEswitchInlineMode = c_int;
pub const NM_SRIOV_ESWITCH_INLINE_MODE_PRESERVE: NMSriovEswitchInlineMode = -1;
pub const NM_SRIOV_ESWITCH_INLINE_MODE_NONE: NMSriovEswitchInlineMode = 0;
pub const NM_SRIOV_ESWITCH_INLINE_MODE_LINK: NMSriovEswitchInlineMode = 1;
pub const NM_SRIOV_ESWITCH_INLINE_MODE_NETWORK: NMSriovEswitchInlineMode = 2;
pub const NM_SRIOV_ESWITCH_INLINE_MODE_TRANSPORT: NMSriovEswitchInlineMode = 3;

pub type NMSriovEswitchMode = c_int;
pub const NM_SRIOV_ESWITCH_MODE_PRESERVE: NMSriovEswitchMode = -1;
pub const NM_SRIOV_ESWITCH_MODE_LEGACY: NMSriovEswitchMode = 0;
pub const NM_SRIOV_ESWITCH_MODE_SWITCHDEV: NMSriovEswitchMode = 1;

pub type NMSriovVFVlanProtocol = c_int;
pub const NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q: NMSriovVFVlanProtocol = 0;
pub const NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD: NMSriovVFVlanProtocol = 1;

pub type NMState = c_int;
pub const NM_STATE_UNKNOWN: NMState = 0;
pub const NM_STATE_ASLEEP: NMState = 10;
pub const NM_STATE_DISCONNECTED: NMState = 20;
pub const NM_STATE_DISCONNECTING: NMState = 30;
pub const NM_STATE_CONNECTING: NMState = 40;
pub const NM_STATE_CONNECTED_LOCAL: NMState = 50;
pub const NM_STATE_CONNECTED_SITE: NMState = 60;
pub const NM_STATE_CONNECTED_GLOBAL: NMState = 70;

pub type NMTernary = c_int;
pub const NM_TERNARY_DEFAULT: NMTernary = -1;
pub const NM_TERNARY_FALSE: NMTernary = 0;
pub const NM_TERNARY_TRUE: NMTernary = 1;

pub type NMUtilsSecurityType = c_int;
pub const NMU_SEC_INVALID: NMUtilsSecurityType = 0;
pub const NMU_SEC_NONE: NMUtilsSecurityType = 1;
pub const NMU_SEC_STATIC_WEP: NMUtilsSecurityType = 2;
pub const NMU_SEC_LEAP: NMUtilsSecurityType = 3;
pub const NMU_SEC_DYNAMIC_WEP: NMUtilsSecurityType = 4;
pub const NMU_SEC_WPA_PSK: NMUtilsSecurityType = 5;
pub const NMU_SEC_WPA_ENTERPRISE: NMUtilsSecurityType = 6;
pub const NMU_SEC_WPA2_PSK: NMUtilsSecurityType = 7;
pub const NMU_SEC_WPA2_ENTERPRISE: NMUtilsSecurityType = 8;
pub const NMU_SEC_SAE: NMUtilsSecurityType = 9;
pub const NMU_SEC_OWE: NMUtilsSecurityType = 10;
pub const NMU_SEC_WPA3_SUITE_B_192: NMUtilsSecurityType = 11;

pub type NMVersionInfoCapability = c_int;
pub const _NM_VERSION_INFO_CAPABILITY_UNUSED: NMVersionInfoCapability = 2147483647;

pub type NMVlanPriorityMap = c_int;
pub const NM_VLAN_INGRESS_MAP: NMVlanPriorityMap = 0;
pub const NM_VLAN_EGRESS_MAP: NMVlanPriorityMap = 1;

pub type NMVpnConnectionState = c_int;
pub const NM_VPN_CONNECTION_STATE_UNKNOWN: NMVpnConnectionState = 0;
pub const NM_VPN_CONNECTION_STATE_PREPARE: NMVpnConnectionState = 1;
pub const NM_VPN_CONNECTION_STATE_NEED_AUTH: NMVpnConnectionState = 2;
pub const NM_VPN_CONNECTION_STATE_CONNECT: NMVpnConnectionState = 3;
pub const NM_VPN_CONNECTION_STATE_IP_CONFIG_GET: NMVpnConnectionState = 4;
pub const NM_VPN_CONNECTION_STATE_ACTIVATED: NMVpnConnectionState = 5;
pub const NM_VPN_CONNECTION_STATE_FAILED: NMVpnConnectionState = 6;
pub const NM_VPN_CONNECTION_STATE_DISCONNECTED: NMVpnConnectionState = 7;

pub type NMVpnConnectionStateReason = c_int;
pub const NM_VPN_CONNECTION_STATE_REASON_UNKNOWN: NMVpnConnectionStateReason = 0;
pub const NM_VPN_CONNECTION_STATE_REASON_NONE: NMVpnConnectionStateReason = 1;
pub const NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED: NMVpnConnectionStateReason = 2;
pub const NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED: NMVpnConnectionStateReason = 3;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED: NMVpnConnectionStateReason = 4;
pub const NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID: NMVpnConnectionStateReason = 5;
pub const NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT: NMVpnConnectionStateReason = 6;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT: NMVpnConnectionStateReason = 7;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED: NMVpnConnectionStateReason = 8;
pub const NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS: NMVpnConnectionStateReason = 9;
pub const NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED: NMVpnConnectionStateReason = 10;
pub const NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED: NMVpnConnectionStateReason = 11;

pub type NMVpnPluginError = c_int;
pub const NM_VPN_PLUGIN_ERROR_FAILED: NMVpnPluginError = 0;
pub const NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS: NMVpnPluginError = 1;
pub const NM_VPN_PLUGIN_ERROR_ALREADY_STARTED: NMVpnPluginError = 2;
pub const NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS: NMVpnPluginError = 3;
pub const NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED: NMVpnPluginError = 4;
pub const NM_VPN_PLUGIN_ERROR_WRONG_STATE: NMVpnPluginError = 5;
pub const NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS: NMVpnPluginError = 6;
pub const NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED: NMVpnPluginError = 7;
pub const NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION: NMVpnPluginError = 8;
pub const NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED: NMVpnPluginError = 9;

pub type NMVpnPluginFailure = c_int;
pub const NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED: NMVpnPluginFailure = 0;
pub const NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED: NMVpnPluginFailure = 1;
pub const NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG: NMVpnPluginFailure = 2;

pub type NMVpnServiceState = c_int;
pub const NM_VPN_SERVICE_STATE_UNKNOWN: NMVpnServiceState = 0;
pub const NM_VPN_SERVICE_STATE_INIT: NMVpnServiceState = 1;
pub const NM_VPN_SERVICE_STATE_SHUTDOWN: NMVpnServiceState = 2;
pub const NM_VPN_SERVICE_STATE_STARTING: NMVpnServiceState = 3;
pub const NM_VPN_SERVICE_STATE_STARTED: NMVpnServiceState = 4;
pub const NM_VPN_SERVICE_STATE_STOPPING: NMVpnServiceState = 5;
pub const NM_VPN_SERVICE_STATE_STOPPED: NMVpnServiceState = 6;

pub type NMWepKeyType = c_int;
pub const NM_WEP_KEY_TYPE_UNKNOWN: NMWepKeyType = 0;
pub const NM_WEP_KEY_TYPE_KEY: NMWepKeyType = 1;
pub const NM_WEP_KEY_TYPE_PASSPHRASE: NMWepKeyType = 2;

pub type NMWimaxNspNetworkType = c_int;
pub const NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN: NMWimaxNspNetworkType = 0;
pub const NM_WIMAX_NSP_NETWORK_TYPE_HOME: NMWimaxNspNetworkType = 1;
pub const NM_WIMAX_NSP_NETWORK_TYPE_PARTNER: NMWimaxNspNetworkType = 2;
pub const NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER: NMWimaxNspNetworkType = 3;

// Constants
pub const NM_ACCESS_POINT_BANDWIDTH: &[u8] = b"bandwidth\0";
pub const NM_ACCESS_POINT_BSSID: &[u8] = b"bssid\0";
pub const NM_ACCESS_POINT_FLAGS: &[u8] = b"flags\0";
pub const NM_ACCESS_POINT_FREQUENCY: &[u8] = b"frequency\0";
pub const NM_ACCESS_POINT_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_ACCESS_POINT_LAST_SEEN: &[u8] = b"last-seen\0";
pub const NM_ACCESS_POINT_MAX_BITRATE: &[u8] = b"max-bitrate\0";
pub const NM_ACCESS_POINT_MODE: &[u8] = b"mode\0";
pub const NM_ACCESS_POINT_RSN_FLAGS: &[u8] = b"rsn-flags\0";
pub const NM_ACCESS_POINT_SSID: &[u8] = b"ssid\0";
pub const NM_ACCESS_POINT_STRENGTH: &[u8] = b"strength\0";
pub const NM_ACCESS_POINT_WPA_FLAGS: &[u8] = b"wpa-flags\0";
pub const NM_ACTIVE_CONNECTION_CONNECTION: &[u8] = b"connection\0";
pub const NM_ACTIVE_CONNECTION_CONTROLLER: &[u8] = b"controller\0";
pub const NM_ACTIVE_CONNECTION_DEFAULT: &[u8] = b"default\0";
pub const NM_ACTIVE_CONNECTION_DEFAULT6: &[u8] = b"default6\0";
pub const NM_ACTIVE_CONNECTION_DEVICES: &[u8] = b"devices\0";
pub const NM_ACTIVE_CONNECTION_DHCP4_CONFIG: &[u8] = b"dhcp4-config\0";
pub const NM_ACTIVE_CONNECTION_DHCP6_CONFIG: &[u8] = b"dhcp6-config\0";
pub const NM_ACTIVE_CONNECTION_ID: &[u8] = b"id\0";
pub const NM_ACTIVE_CONNECTION_IP4_CONFIG: &[u8] = b"ip4-config\0";
pub const NM_ACTIVE_CONNECTION_IP6_CONFIG: &[u8] = b"ip6-config\0";
pub const NM_ACTIVE_CONNECTION_MASTER: &[u8] = b"master\0";
pub const NM_ACTIVE_CONNECTION_SPECIFIC_OBJECT_PATH: &[u8] = b"specific-object-path\0";
pub const NM_ACTIVE_CONNECTION_STATE: &[u8] = b"state\0";
pub const NM_ACTIVE_CONNECTION_STATE_FLAGS: &[u8] = b"state-flags\0";
pub const NM_ACTIVE_CONNECTION_TYPE: &[u8] = b"type\0";
pub const NM_ACTIVE_CONNECTION_UUID: &[u8] = b"uuid\0";
pub const NM_ACTIVE_CONNECTION_VPN: &[u8] = b"vpn\0";
pub const NM_BRIDGE_VLAN_VID_MAX: c_int = 4094;
pub const NM_BRIDGE_VLAN_VID_MIN: c_int = 1;
pub const NM_CHECKPOINT_CREATED: &[u8] = b"created\0";
pub const NM_CHECKPOINT_DEVICES: &[u8] = b"devices\0";
pub const NM_CHECKPOINT_ROLLBACK_TIMEOUT: &[u8] = b"rollback-timeout\0";
pub const NM_CLIENT_ACTIVATING_CONNECTION: &[u8] = b"activating-connection\0";
pub const NM_CLIENT_ACTIVE_CONNECTIONS: &[u8] = b"active-connections\0";
pub const NM_CLIENT_ACTIVE_CONNECTION_ADDED: &[u8] = b"active-connection-added\0";
pub const NM_CLIENT_ACTIVE_CONNECTION_REMOVED: &[u8] = b"active-connection-removed\0";
pub const NM_CLIENT_ALL_DEVICES: &[u8] = b"all-devices\0";
pub const NM_CLIENT_ANY_DEVICE_ADDED: &[u8] = b"any-device-added\0";
pub const NM_CLIENT_ANY_DEVICE_REMOVED: &[u8] = b"any-device-removed\0";
pub const NM_CLIENT_CAN_MODIFY: &[u8] = b"can-modify\0";
pub const NM_CLIENT_CAPABILITIES: &[u8] = b"capabilities\0";
pub const NM_CLIENT_CHECKPOINTS: &[u8] = b"checkpoints\0";
pub const NM_CLIENT_CONNECTIONS: &[u8] = b"connections\0";
pub const NM_CLIENT_CONNECTION_ADDED: &[u8] = b"connection-added\0";
pub const NM_CLIENT_CONNECTION_REMOVED: &[u8] = b"connection-removed\0";
pub const NM_CLIENT_CONNECTIVITY: &[u8] = b"connectivity\0";
pub const NM_CLIENT_CONNECTIVITY_CHECK_AVAILABLE: &[u8] = b"connectivity-check-available\0";
pub const NM_CLIENT_CONNECTIVITY_CHECK_ENABLED: &[u8] = b"connectivity-check-enabled\0";
pub const NM_CLIENT_CONNECTIVITY_CHECK_URI: &[u8] = b"connectivity-check-uri\0";
pub const NM_CLIENT_DBUS_CONNECTION: &[u8] = b"dbus-connection\0";
pub const NM_CLIENT_DBUS_NAME_OWNER: &[u8] = b"dbus-name-owner\0";
pub const NM_CLIENT_DEVICES: &[u8] = b"devices\0";
pub const NM_CLIENT_DEVICE_ADDED: &[u8] = b"device-added\0";
pub const NM_CLIENT_DEVICE_REMOVED: &[u8] = b"device-removed\0";
pub const NM_CLIENT_DNS_CONFIGURATION: &[u8] = b"dns-configuration\0";
pub const NM_CLIENT_DNS_MODE: &[u8] = b"dns-mode\0";
pub const NM_CLIENT_DNS_RC_MANAGER: &[u8] = b"dns-rc-manager\0";
pub const NM_CLIENT_HOSTNAME: &[u8] = b"hostname\0";
pub const NM_CLIENT_INSTANCE_FLAGS: &[u8] = b"instance-flags\0";
pub const NM_CLIENT_METERED: &[u8] = b"metered\0";
pub const NM_CLIENT_NETWORKING_ENABLED: &[u8] = b"networking-enabled\0";
pub const NM_CLIENT_NM_RUNNING: &[u8] = b"nm-running\0";
pub const NM_CLIENT_PERMISSIONS_STATE: &[u8] = b"permissions-state\0";
pub const NM_CLIENT_PERMISSION_CHANGED: &[u8] = b"permission-changed\0";
pub const NM_CLIENT_PRIMARY_CONNECTION: &[u8] = b"primary-connection\0";
pub const NM_CLIENT_RADIO_FLAGS: &[u8] = b"radio-flags\0";
pub const NM_CLIENT_STARTUP: &[u8] = b"startup\0";
pub const NM_CLIENT_STATE: &[u8] = b"state\0";
pub const NM_CLIENT_VERSION: &[u8] = b"version\0";
pub const NM_CLIENT_VERSION_INFO: &[u8] = b"version-info\0";
pub const NM_CLIENT_WIMAX_ENABLED: &[u8] = b"wimax-enabled\0";
pub const NM_CLIENT_WIMAX_HARDWARE_ENABLED: &[u8] = b"wimax-hardware-enabled\0";
pub const NM_CLIENT_WIRELESS_ENABLED: &[u8] = b"wireless-enabled\0";
pub const NM_CLIENT_WIRELESS_HARDWARE_ENABLED: &[u8] = b"wireless-hardware-enabled\0";
pub const NM_CLIENT_WWAN_ENABLED: &[u8] = b"wwan-enabled\0";
pub const NM_CLIENT_WWAN_HARDWARE_ENABLED: &[u8] = b"wwan-hardware-enabled\0";
pub const NM_CONNECTION_CHANGED: &[u8] = b"changed\0";
pub const NM_CONNECTION_NORMALIZE_PARAM_IP4_CONFIG_METHOD: &[u8] = b"ip4-config-method\0";
pub const NM_CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD: &[u8] = b"ip6-config-method\0";
pub const NM_CONNECTION_SECRETS_CLEARED: &[u8] = b"secrets-cleared\0";
pub const NM_CONNECTION_SECRETS_UPDATED: &[u8] = b"secrets-updated\0";
pub const NM_DBUS_INTERFACE: &[u8] = b"org.freedesktop.NetworkManager\0";
pub const NM_DBUS_INTERFACE_DNS_MANAGER: &[u8] = b"org.freedesktop.NetworkManager.DnsManager\0";
pub const NM_DBUS_INTERFACE_SETTINGS: &[u8] = b"org.freedesktop.NetworkManager.Settings\0";
pub const NM_DBUS_INTERFACE_SETTINGS_CONNECTION: &[u8] = b"org.freedesktop.NetworkManager.Settings.Connection\0";
pub const NM_DBUS_INTERFACE_SETTINGS_CONNECTION_SECRETS: &[u8] = b"org.freedesktop.NetworkManager.Settings.Connection.Secrets\0";
pub const NM_DBUS_INTERFACE_VPN: &[u8] = b"org.freedesktop.NetworkManager.VPN.Manager\0";
pub const NM_DBUS_INTERFACE_VPN_CONNECTION: &[u8] = b"org.freedesktop.NetworkManager.VPN.Connection\0";
pub const NM_DBUS_INVALID_VPN_CONNECTION: &[u8] = b"org.freedesktop.NetworkManager.VPNConnections.InvalidVPNConnection\0";
pub const NM_DBUS_NO_ACTIVE_VPN_CONNECTION: &[u8] = b"org.freedesktop.NetworkManager.VPNConnections.NoActiveVPNConnection\0";
pub const NM_DBUS_NO_VPN_CONNECTIONS: &[u8] = b"org.freedesktop.NetworkManager.VPNConnections.NoVPNConnections\0";
pub const NM_DBUS_PATH: &[u8] = b"/org/freedesktop/NetworkManager\0";
pub const NM_DBUS_PATH_AGENT_MANAGER: &[u8] = b"/org/freedesktop/NetworkManager/AgentManager\0";
pub const NM_DBUS_PATH_DNS_MANAGER: &[u8] = b"/org/freedesktop/NetworkManager/DnsManager\0";
pub const NM_DBUS_PATH_SECRET_AGENT: &[u8] = b"/org/freedesktop/NetworkManager/SecretAgent\0";
pub const NM_DBUS_PATH_SETTINGS: &[u8] = b"/org/freedesktop/NetworkManager/Settings\0";
pub const NM_DBUS_PATH_SETTINGS_CONNECTION: &[u8] = b"/org/freedesktop/NetworkManager/Settings/Connection\0";
pub const NM_DBUS_PATH_VPN: &[u8] = b"/org/freedesktop/NetworkManager/VPN/Manager\0";
pub const NM_DBUS_PATH_VPN_CONNECTION: &[u8] = b"/org/freedesktop/NetworkManager/VPN/Connection\0";
pub const NM_DBUS_SERVICE: &[u8] = b"org.freedesktop.NetworkManager\0";
pub const NM_DBUS_VPN_ALREADY_STARTED: &[u8] = b"AlreadyStarted\0";
pub const NM_DBUS_VPN_ALREADY_STOPPED: &[u8] = b"AlreadyStopped\0";
pub const NM_DBUS_VPN_BAD_ARGUMENTS: &[u8] = b"BadArguments\0";
pub const NM_DBUS_VPN_ERROR_PREFIX: &[u8] = b"org.freedesktop.NetworkManager.VPN.Error\0";
pub const NM_DBUS_VPN_INTERACTIVE_NOT_SUPPORTED: &[u8] = b"InteractiveNotSupported\0";
pub const NM_DBUS_VPN_SIGNAL_CONNECT_FAILED: &[u8] = b"ConnectFailed\0";
pub const NM_DBUS_VPN_SIGNAL_IP4_CONFIG: &[u8] = b"IP4Config\0";
pub const NM_DBUS_VPN_SIGNAL_IP_CONFIG_BAD: &[u8] = b"IPConfigBad\0";
pub const NM_DBUS_VPN_SIGNAL_LAUNCH_FAILED: &[u8] = b"LaunchFailed\0";
pub const NM_DBUS_VPN_SIGNAL_LOGIN_BANNER: &[u8] = b"LoginBanner\0";
pub const NM_DBUS_VPN_SIGNAL_LOGIN_FAILED: &[u8] = b"LoginFailed\0";
pub const NM_DBUS_VPN_SIGNAL_STATE_CHANGE: &[u8] = b"StateChange\0";
pub const NM_DBUS_VPN_SIGNAL_VPN_CONFIG_BAD: &[u8] = b"VPNConfigBad\0";
pub const NM_DBUS_VPN_STARTING_IN_PROGRESS: &[u8] = b"StartingInProgress\0";
pub const NM_DBUS_VPN_STOPPING_IN_PROGRESS: &[u8] = b"StoppingInProgress\0";
pub const NM_DBUS_VPN_WRONG_STATE: &[u8] = b"WrongState\0";
pub const NM_DEVICE_6LOWPAN_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_6LOWPAN_PARENT: &[u8] = b"parent\0";
pub const NM_DEVICE_ACTIVE_CONNECTION: &[u8] = b"active-connection\0";
pub const NM_DEVICE_ADSL_CARRIER: &[u8] = b"carrier\0";
pub const NM_DEVICE_AUTOCONNECT: &[u8] = b"autoconnect\0";
pub const NM_DEVICE_AVAILABLE_CONNECTIONS: &[u8] = b"available-connections\0";
pub const NM_DEVICE_BOND_CARRIER: &[u8] = b"carrier\0";
pub const NM_DEVICE_BOND_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_BOND_SLAVES: &[u8] = b"slaves\0";
pub const NM_DEVICE_BRIDGE_CARRIER: &[u8] = b"carrier\0";
pub const NM_DEVICE_BRIDGE_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_BRIDGE_SLAVES: &[u8] = b"slaves\0";
pub const NM_DEVICE_BT_CAPABILITIES: &[u8] = b"bt-capabilities\0";
pub const NM_DEVICE_BT_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_BT_NAME: &[u8] = b"name\0";
pub const NM_DEVICE_CAPABILITIES: &[u8] = b"capabilities\0";
pub const NM_DEVICE_DEVICE_TYPE: &[u8] = b"device-type\0";
pub const NM_DEVICE_DHCP4_CONFIG: &[u8] = b"dhcp4-config\0";
pub const NM_DEVICE_DHCP6_CONFIG: &[u8] = b"dhcp6-config\0";
pub const NM_DEVICE_DRIVER: &[u8] = b"driver\0";
pub const NM_DEVICE_DRIVER_VERSION: &[u8] = b"driver-version\0";
pub const NM_DEVICE_DUMMY_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_ETHERNET_CARRIER: &[u8] = b"carrier\0";
pub const NM_DEVICE_ETHERNET_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_ETHERNET_PERMANENT_HW_ADDRESS: &[u8] = b"perm-hw-address\0";
pub const NM_DEVICE_ETHERNET_S390_SUBCHANNELS: &[u8] = b"s390-subchannels\0";
pub const NM_DEVICE_ETHERNET_SPEED: &[u8] = b"speed\0";
pub const NM_DEVICE_FIRMWARE_MISSING: &[u8] = b"firmware-missing\0";
pub const NM_DEVICE_FIRMWARE_VERSION: &[u8] = b"firmware-version\0";
pub const NM_DEVICE_GENERIC_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_GENERIC_TYPE_DESCRIPTION: &[u8] = b"type-description\0";
pub const NM_DEVICE_HSR_MULTICAST_SPEC: &[u8] = b"multicast-spec\0";
pub const NM_DEVICE_HSR_PORT1: &[u8] = b"port1\0";
pub const NM_DEVICE_HSR_PORT2: &[u8] = b"port2\0";
pub const NM_DEVICE_HSR_PRP: &[u8] = b"prp\0";
pub const NM_DEVICE_HSR_SUPERVISION_ADDRESS: &[u8] = b"supervision-address\0";
pub const NM_DEVICE_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_INFINIBAND_CARRIER: &[u8] = b"carrier\0";
pub const NM_DEVICE_INFINIBAND_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_INTERFACE: &[u8] = b"interface\0";
pub const NM_DEVICE_INTERFACE_FLAGS: &[u8] = b"interface-flags\0";
pub const NM_DEVICE_IP4_CONFIG: &[u8] = b"ip4-config\0";
pub const NM_DEVICE_IP4_CONNECTIVITY: &[u8] = b"ip4-connectivity\0";
pub const NM_DEVICE_IP6_CONFIG: &[u8] = b"ip6-config\0";
pub const NM_DEVICE_IP6_CONNECTIVITY: &[u8] = b"ip6-connectivity\0";
pub const NM_DEVICE_IP_INTERFACE: &[u8] = b"ip-interface\0";
pub const NM_DEVICE_IP_TUNNEL_ENCAPSULATION_LIMIT: &[u8] = b"encapsulation-limit\0";
pub const NM_DEVICE_IP_TUNNEL_FLAGS: &[u8] = b"flags\0";
pub const NM_DEVICE_IP_TUNNEL_FLOW_LABEL: &[u8] = b"flow-label\0";
pub const NM_DEVICE_IP_TUNNEL_FWMARK: &[u8] = b"fwmark\0";
pub const NM_DEVICE_IP_TUNNEL_INPUT_KEY: &[u8] = b"input-key\0";
pub const NM_DEVICE_IP_TUNNEL_LOCAL: &[u8] = b"local\0";
pub const NM_DEVICE_IP_TUNNEL_MODE: &[u8] = b"mode\0";
pub const NM_DEVICE_IP_TUNNEL_OUTPUT_KEY: &[u8] = b"output-key\0";
pub const NM_DEVICE_IP_TUNNEL_PARENT: &[u8] = b"parent\0";
pub const NM_DEVICE_IP_TUNNEL_PATH_MTU_DISCOVERY: &[u8] = b"path-mtu-discovery\0";
pub const NM_DEVICE_IP_TUNNEL_REMOTE: &[u8] = b"remote\0";
pub const NM_DEVICE_IP_TUNNEL_TOS: &[u8] = b"tos\0";
pub const NM_DEVICE_IP_TUNNEL_TTL: &[u8] = b"ttl\0";
pub const NM_DEVICE_LLDP_NEIGHBORS: &[u8] = b"lldp-neighbors\0";
pub const NM_DEVICE_MACSEC_CIPHER_SUITE: &[u8] = b"cipher-suite\0";
pub const NM_DEVICE_MACSEC_ENCODING_SA: &[u8] = b"encoding-sa\0";
pub const NM_DEVICE_MACSEC_ENCRYPT: &[u8] = b"encrypt\0";
pub const NM_DEVICE_MACSEC_ES: &[u8] = b"es\0";
pub const NM_DEVICE_MACSEC_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_MACSEC_ICV_LENGTH: &[u8] = b"icv-length\0";
pub const NM_DEVICE_MACSEC_INCLUDE_SCI: &[u8] = b"include-sci\0";
pub const NM_DEVICE_MACSEC_PARENT: &[u8] = b"parent\0";
pub const NM_DEVICE_MACSEC_PROTECT: &[u8] = b"protect\0";
pub const NM_DEVICE_MACSEC_REPLAY_PROTECT: &[u8] = b"replay-protect\0";
pub const NM_DEVICE_MACSEC_SCB: &[u8] = b"scb\0";
pub const NM_DEVICE_MACSEC_SCI: &[u8] = b"sci\0";
pub const NM_DEVICE_MACSEC_VALIDATION: &[u8] = b"validation\0";
pub const NM_DEVICE_MACSEC_WINDOW: &[u8] = b"window\0";
pub const NM_DEVICE_MACVLAN_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_MACVLAN_MODE: &[u8] = b"mode\0";
pub const NM_DEVICE_MACVLAN_NO_PROMISC: &[u8] = b"no-promisc\0";
pub const NM_DEVICE_MACVLAN_PARENT: &[u8] = b"parent\0";
pub const NM_DEVICE_MACVLAN_TAP: &[u8] = b"tap\0";
pub const NM_DEVICE_MANAGED: &[u8] = b"managed\0";
pub const NM_DEVICE_METERED: &[u8] = b"metered\0";
pub const NM_DEVICE_MODEM_APN: &[u8] = b"apn\0";
pub const NM_DEVICE_MODEM_CURRENT_CAPABILITIES: &[u8] = b"current-capabilities\0";
pub const NM_DEVICE_MODEM_DEVICE_ID: &[u8] = b"device-id\0";
pub const NM_DEVICE_MODEM_MODEM_CAPABILITIES: &[u8] = b"modem-capabilities\0";
pub const NM_DEVICE_MODEM_OPERATOR_CODE: &[u8] = b"operator-code\0";
pub const NM_DEVICE_MTU: &[u8] = b"mtu\0";
pub const NM_DEVICE_NM_PLUGIN_MISSING: &[u8] = b"nm-plugin-missing\0";
pub const NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL: &[u8] = b"active-channel\0";
pub const NM_DEVICE_OLPC_MESH_COMPANION: &[u8] = b"companion\0";
pub const NM_DEVICE_OLPC_MESH_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_OVS_BRIDGE_SLAVES: &[u8] = b"slaves\0";
pub const NM_DEVICE_OVS_PORT_SLAVES: &[u8] = b"slaves\0";
pub const NM_DEVICE_PATH: &[u8] = b"path\0";
pub const NM_DEVICE_PHYSICAL_PORT_ID: &[u8] = b"physical-port-id\0";
pub const NM_DEVICE_PORTS: &[u8] = b"ports\0";
pub const NM_DEVICE_PRODUCT: &[u8] = b"product\0";
pub const NM_DEVICE_REAL: &[u8] = b"real\0";
pub const NM_DEVICE_STATE: &[u8] = b"state\0";
pub const NM_DEVICE_STATE_REASON: &[u8] = b"state-reason\0";
pub const NM_DEVICE_TEAM_CARRIER: &[u8] = b"carrier\0";
pub const NM_DEVICE_TEAM_CONFIG: &[u8] = b"config\0";
pub const NM_DEVICE_TEAM_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_TEAM_SLAVES: &[u8] = b"slaves\0";
pub const NM_DEVICE_TUN_GROUP: &[u8] = b"group\0";
pub const NM_DEVICE_TUN_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_TUN_MODE: &[u8] = b"mode\0";
pub const NM_DEVICE_TUN_MULTI_QUEUE: &[u8] = b"multi-queue\0";
pub const NM_DEVICE_TUN_NO_PI: &[u8] = b"no-pi\0";
pub const NM_DEVICE_TUN_OWNER: &[u8] = b"owner\0";
pub const NM_DEVICE_TUN_VNET_HDR: &[u8] = b"vnet-hdr\0";
pub const NM_DEVICE_UDI: &[u8] = b"udi\0";
pub const NM_DEVICE_VENDOR: &[u8] = b"vendor\0";
pub const NM_DEVICE_VETH_PEER: &[u8] = b"peer\0";
pub const NM_DEVICE_VLAN_CARRIER: &[u8] = b"carrier\0";
pub const NM_DEVICE_VLAN_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_VLAN_PARENT: &[u8] = b"parent\0";
pub const NM_DEVICE_VLAN_VLAN_ID: &[u8] = b"vlan-id\0";
pub const NM_DEVICE_VRF_TABLE: &[u8] = b"table\0";
pub const NM_DEVICE_VXLAN_AGEING: &[u8] = b"ageing\0";
pub const NM_DEVICE_VXLAN_CARRIER: &[u8] = b"carrier\0";
pub const NM_DEVICE_VXLAN_DST_PORT: &[u8] = b"dst-port\0";
pub const NM_DEVICE_VXLAN_GROUP: &[u8] = b"group\0";
pub const NM_DEVICE_VXLAN_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_VXLAN_ID: &[u8] = b"id\0";
pub const NM_DEVICE_VXLAN_L2MISS: &[u8] = b"l2miss\0";
pub const NM_DEVICE_VXLAN_L3MISS: &[u8] = b"l3miss\0";
pub const NM_DEVICE_VXLAN_LEARNING: &[u8] = b"learning\0";
pub const NM_DEVICE_VXLAN_LIMIT: &[u8] = b"limit\0";
pub const NM_DEVICE_VXLAN_LOCAL: &[u8] = b"local\0";
pub const NM_DEVICE_VXLAN_PARENT: &[u8] = b"parent\0";
pub const NM_DEVICE_VXLAN_PROXY: &[u8] = b"proxy\0";
pub const NM_DEVICE_VXLAN_RSC: &[u8] = b"rsc\0";
pub const NM_DEVICE_VXLAN_SRC_PORT_MAX: &[u8] = b"src-port-max\0";
pub const NM_DEVICE_VXLAN_SRC_PORT_MIN: &[u8] = b"src-port-min\0";
pub const NM_DEVICE_VXLAN_TOS: &[u8] = b"tos\0";
pub const NM_DEVICE_VXLAN_TTL: &[u8] = b"ttl\0";
pub const NM_DEVICE_WIFI_ACCESS_POINTS: &[u8] = b"access-points\0";
pub const NM_DEVICE_WIFI_ACTIVE_ACCESS_POINT: &[u8] = b"active-access-point\0";
pub const NM_DEVICE_WIFI_BITRATE: &[u8] = b"bitrate\0";
pub const NM_DEVICE_WIFI_CAPABILITIES: &[u8] = b"wireless-capabilities\0";
pub const NM_DEVICE_WIFI_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_WIFI_LAST_SCAN: &[u8] = b"last-scan\0";
pub const NM_DEVICE_WIFI_MODE: &[u8] = b"mode\0";
pub const NM_DEVICE_WIFI_P2P_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_WIFI_P2P_PEERS: &[u8] = b"peers\0";
pub const NM_DEVICE_WIFI_P2P_WFDIES: &[u8] = b"wfdies\0";
pub const NM_DEVICE_WIFI_PERMANENT_HW_ADDRESS: &[u8] = b"perm-hw-address\0";
pub const NM_DEVICE_WIMAX_ACTIVE_NSP: &[u8] = b"active-nsp\0";
pub const NM_DEVICE_WIMAX_BSID: &[u8] = b"bsid\0";
pub const NM_DEVICE_WIMAX_CENTER_FREQUENCY: &[u8] = b"center-frequency\0";
pub const NM_DEVICE_WIMAX_CINR: &[u8] = b"cinr\0";
pub const NM_DEVICE_WIMAX_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DEVICE_WIMAX_NSPS: &[u8] = b"nsps\0";
pub const NM_DEVICE_WIMAX_RSSI: &[u8] = b"rssi\0";
pub const NM_DEVICE_WIMAX_TX_POWER: &[u8] = b"tx-power\0";
pub const NM_DEVICE_WIREGUARD_FWMARK: &[u8] = b"fwmark\0";
pub const NM_DEVICE_WIREGUARD_LISTEN_PORT: &[u8] = b"listen-port\0";
pub const NM_DEVICE_WIREGUARD_PUBLIC_KEY: &[u8] = b"public-key\0";
pub const NM_DEVICE_WPAN_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_DHCP_CONFIG_FAMILY: &[u8] = b"family\0";
pub const NM_DHCP_CONFIG_OPTIONS: &[u8] = b"options\0";
pub const NM_ETHTOOL_OPTNAME_CHANNELS_COMBINED: &[u8] = b"channels-combined\0";
pub const NM_ETHTOOL_OPTNAME_CHANNELS_OTHER: &[u8] = b"channels-other\0";
pub const NM_ETHTOOL_OPTNAME_CHANNELS_RX: &[u8] = b"channels-rx\0";
pub const NM_ETHTOOL_OPTNAME_CHANNELS_TX: &[u8] = b"channels-tx\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_ADAPTIVE_RX: &[u8] = b"coalesce-adaptive-rx\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_ADAPTIVE_TX: &[u8] = b"coalesce-adaptive-tx\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_PKT_RATE_HIGH: &[u8] = b"coalesce-pkt-rate-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_PKT_RATE_LOW: &[u8] = b"coalesce-pkt-rate-low\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_FRAMES: &[u8] = b"coalesce-rx-frames\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_HIGH: &[u8] = b"coalesce-rx-frames-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_IRQ: &[u8] = b"coalesce-rx-frames-irq\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_LOW: &[u8] = b"coalesce-rx-frames-low\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_USECS: &[u8] = b"coalesce-rx-usecs\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_USECS_HIGH: &[u8] = b"coalesce-rx-usecs-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_USECS_IRQ: &[u8] = b"coalesce-rx-usecs-irq\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_RX_USECS_LOW: &[u8] = b"coalesce-rx-usecs-low\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_SAMPLE_INTERVAL: &[u8] = b"coalesce-sample-interval\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_STATS_BLOCK_USECS: &[u8] = b"coalesce-stats-block-usecs\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_FRAMES: &[u8] = b"coalesce-tx-frames\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_HIGH: &[u8] = b"coalesce-tx-frames-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_IRQ: &[u8] = b"coalesce-tx-frames-irq\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_LOW: &[u8] = b"coalesce-tx-frames-low\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_USECS: &[u8] = b"coalesce-tx-usecs\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_USECS_HIGH: &[u8] = b"coalesce-tx-usecs-high\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_USECS_IRQ: &[u8] = b"coalesce-tx-usecs-irq\0";
pub const NM_ETHTOOL_OPTNAME_COALESCE_TX_USECS_LOW: &[u8] = b"coalesce-tx-usecs-low\0";
pub const NM_ETHTOOL_OPTNAME_EEE_ENABLED: &[u8] = b"eee-enabled\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_ESP_HW_OFFLOAD: &[u8] = b"feature-esp-hw-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_ESP_TX_CSUM_HW_OFFLOAD: &[u8] = b"feature-esp-tx-csum-hw-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_FCOE_MTU: &[u8] = b"feature-fcoe-mtu\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_GRO: &[u8] = b"feature-gro\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_GSO: &[u8] = b"feature-gso\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_HIGHDMA: &[u8] = b"feature-highdma\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_HW_TC_OFFLOAD: &[u8] = b"feature-hw-tc-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_L2_FWD_OFFLOAD: &[u8] = b"feature-l2-fwd-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_LOOPBACK: &[u8] = b"feature-loopback\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_LRO: &[u8] = b"feature-lro\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_MACSEC_HW_OFFLOAD: &[u8] = b"feature-macsec-hw-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_NTUPLE: &[u8] = b"feature-ntuple\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX: &[u8] = b"feature-rx\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RXHASH: &[u8] = b"feature-rxhash\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RXVLAN: &[u8] = b"feature-rxvlan\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_ALL: &[u8] = b"feature-rx-all\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_FCS: &[u8] = b"feature-rx-fcs\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_GRO_HW: &[u8] = b"feature-rx-gro-hw\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_GRO_LIST: &[u8] = b"feature-rx-gro-list\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_UDP_GRO_FORWARDING: &[u8] = b"feature-rx-udp-gro-forwarding\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_UDP_TUNNEL_PORT_OFFLOAD: &[u8] = b"feature-rx-udp_tunnel-port-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_FILTER: &[u8] = b"feature-rx-vlan-filter\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_STAG_FILTER: &[u8] = b"feature-rx-vlan-stag-filter\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_STAG_HW_PARSE: &[u8] = b"feature-rx-vlan-stag-hw-parse\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_SG: &[u8] = b"feature-sg\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TLS_HW_RECORD: &[u8] = b"feature-tls-hw-record\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TLS_HW_RX_OFFLOAD: &[u8] = b"feature-tls-hw-rx-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TLS_HW_TX_OFFLOAD: &[u8] = b"feature-tls-hw-tx-offload\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TSO: &[u8] = b"feature-tso\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX: &[u8] = b"feature-tx\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TXVLAN: &[u8] = b"feature-txvlan\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_FCOE_CRC: &[u8] = b"feature-tx-checksum-fcoe-crc\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IPV4: &[u8] = b"feature-tx-checksum-ipv4\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IPV6: &[u8] = b"feature-tx-checksum-ipv6\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IP_GENERIC: &[u8] = b"feature-tx-checksum-ip-generic\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_SCTP: &[u8] = b"feature-tx-checksum-sctp\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_ESP_SEGMENTATION: &[u8] = b"feature-tx-esp-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_FCOE_SEGMENTATION: &[u8] = b"feature-tx-fcoe-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GRE_CSUM_SEGMENTATION: &[u8] = b"feature-tx-gre-csum-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GRE_SEGMENTATION: &[u8] = b"feature-tx-gre-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GSO_LIST: &[u8] = b"feature-tx-gso-list\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GSO_PARTIAL: &[u8] = b"feature-tx-gso-partial\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GSO_ROBUST: &[u8] = b"feature-tx-gso-robust\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_IPXIP4_SEGMENTATION: &[u8] = b"feature-tx-ipxip4-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_IPXIP6_SEGMENTATION: &[u8] = b"feature-tx-ipxip6-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_NOCACHE_COPY: &[u8] = b"feature-tx-nocache-copy\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCATTER_GATHER: &[u8] = b"feature-tx-scatter-gather\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCATTER_GATHER_FRAGLIST: &[u8] = b"feature-tx-scatter-gather-fraglist\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCTP_SEGMENTATION: &[u8] = b"feature-tx-sctp-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP6_SEGMENTATION: &[u8] = b"feature-tx-tcp6-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_ECN_SEGMENTATION: &[u8] = b"feature-tx-tcp-ecn-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_MANGLEID_SEGMENTATION: &[u8] = b"feature-tx-tcp-mangleid-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_SEGMENTATION: &[u8] = b"feature-tx-tcp-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TUNNEL_REMCSUM_SEGMENTATION: &[u8] = b"feature-tx-tunnel-remcsum-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_SEGMENTATION: &[u8] = b"feature-tx-udp-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_TNL_CSUM_SEGMENTATION: &[u8] = b"feature-tx-udp_tnl-csum-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_TNL_SEGMENTATION: &[u8] = b"feature-tx-udp_tnl-segmentation\0";
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_VLAN_STAG_HW_INSERT: &[u8] = b"feature-tx-vlan-stag-hw-insert\0";
pub const NM_ETHTOOL_OPTNAME_PAUSE_AUTONEG: &[u8] = b"pause-autoneg\0";
pub const NM_ETHTOOL_OPTNAME_PAUSE_RX: &[u8] = b"pause-rx\0";
pub const NM_ETHTOOL_OPTNAME_PAUSE_TX: &[u8] = b"pause-tx\0";
pub const NM_ETHTOOL_OPTNAME_RING_RX: &[u8] = b"ring-rx\0";
pub const NM_ETHTOOL_OPTNAME_RING_RX_JUMBO: &[u8] = b"ring-rx-jumbo\0";
pub const NM_ETHTOOL_OPTNAME_RING_RX_MINI: &[u8] = b"ring-rx-mini\0";
pub const NM_ETHTOOL_OPTNAME_RING_TX: &[u8] = b"ring-tx\0";
pub const NM_IP_ADDRESS_ATTRIBUTE_LABEL: &[u8] = b"label\0";
pub const NM_IP_CONFIG_ADDRESSES: &[u8] = b"addresses\0";
pub const NM_IP_CONFIG_DOMAINS: &[u8] = b"domains\0";
pub const NM_IP_CONFIG_FAMILY: &[u8] = b"family\0";
pub const NM_IP_CONFIG_GATEWAY: &[u8] = b"gateway\0";
pub const NM_IP_CONFIG_NAMESERVERS: &[u8] = b"nameservers\0";
pub const NM_IP_CONFIG_ROUTES: &[u8] = b"routes\0";
pub const NM_IP_CONFIG_SEARCHES: &[u8] = b"searches\0";
pub const NM_IP_CONFIG_WINS_SERVERS: &[u8] = b"wins-servers\0";
pub const NM_IP_ROUTE_ATTRIBUTE_ADVMSS: &[u8] = b"advmss\0";
pub const NM_IP_ROUTE_ATTRIBUTE_CWND: &[u8] = b"cwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_FROM: &[u8] = b"from\0";
pub const NM_IP_ROUTE_ATTRIBUTE_INITCWND: &[u8] = b"initcwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_INITRWND: &[u8] = b"initrwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_ADVMSS: &[u8] = b"lock-advmss\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND: &[u8] = b"lock-cwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND: &[u8] = b"lock-initcwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_INITRWND: &[u8] = b"lock-initrwnd\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU: &[u8] = b"lock-mtu\0";
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_WINDOW: &[u8] = b"lock-window\0";
pub const NM_IP_ROUTE_ATTRIBUTE_MTU: &[u8] = b"mtu\0";
pub const NM_IP_ROUTE_ATTRIBUTE_ONLINK: &[u8] = b"onlink\0";
pub const NM_IP_ROUTE_ATTRIBUTE_QUICKACK: &[u8] = b"quickack\0";
pub const NM_IP_ROUTE_ATTRIBUTE_RTO_MIN: &[u8] = b"rto_min\0";
pub const NM_IP_ROUTE_ATTRIBUTE_SCOPE: &[u8] = b"scope\0";
pub const NM_IP_ROUTE_ATTRIBUTE_SRC: &[u8] = b"src\0";
pub const NM_IP_ROUTE_ATTRIBUTE_TABLE: &[u8] = b"table\0";
pub const NM_IP_ROUTE_ATTRIBUTE_TOS: &[u8] = b"tos\0";
pub const NM_IP_ROUTE_ATTRIBUTE_TYPE: &[u8] = b"type\0";
pub const NM_IP_ROUTE_ATTRIBUTE_WEIGHT: &[u8] = b"weight\0";
pub const NM_IP_ROUTE_ATTRIBUTE_WINDOW: &[u8] = b"window\0";
pub const NM_LLDP_ATTR_CHASSIS_ID: &[u8] = b"chassis-id\0";
pub const NM_LLDP_ATTR_CHASSIS_ID_TYPE: &[u8] = b"chassis-id-type\0";
pub const NM_LLDP_ATTR_DESTINATION: &[u8] = b"destination\0";
pub const NM_LLDP_ATTR_IEEE_802_1_PPVID: &[u8] = b"ieee-802-1-ppvid\0";
pub const NM_LLDP_ATTR_IEEE_802_1_PPVIDS: &[u8] = b"ieee-802-1-ppvids\0";
pub const NM_LLDP_ATTR_IEEE_802_1_PPVID_FLAGS: &[u8] = b"ieee-802-1-ppvid-flags\0";
pub const NM_LLDP_ATTR_IEEE_802_1_PVID: &[u8] = b"ieee-802-1-pvid\0";
pub const NM_LLDP_ATTR_IEEE_802_1_VID: &[u8] = b"ieee-802-1-vid\0";
pub const NM_LLDP_ATTR_IEEE_802_1_VLANS: &[u8] = b"ieee-802-1-vlans\0";
pub const NM_LLDP_ATTR_IEEE_802_1_VLAN_NAME: &[u8] = b"ieee-802-1-vlan-name\0";
pub const NM_LLDP_ATTR_IEEE_802_3_MAC_PHY_CONF: &[u8] = b"ieee-802-3-mac-phy-conf\0";
pub const NM_LLDP_ATTR_IEEE_802_3_MAX_FRAME_SIZE: &[u8] = b"ieee-802-3-max-frame-size\0";
pub const NM_LLDP_ATTR_IEEE_802_3_POWER_VIA_MDI: &[u8] = b"ieee-802-3-power-via-mdi\0";
pub const NM_LLDP_ATTR_MANAGEMENT_ADDRESSES: &[u8] = b"management-addresses\0";
pub const NM_LLDP_ATTR_MUD_URL: &[u8] = b"mud-url\0";
pub const NM_LLDP_ATTR_PORT_DESCRIPTION: &[u8] = b"port-description\0";
pub const NM_LLDP_ATTR_PORT_ID: &[u8] = b"port-id\0";
pub const NM_LLDP_ATTR_PORT_ID_TYPE: &[u8] = b"port-id-type\0";
pub const NM_LLDP_ATTR_RAW: &[u8] = b"raw\0";
pub const NM_LLDP_ATTR_SYSTEM_CAPABILITIES: &[u8] = b"system-capabilities\0";
pub const NM_LLDP_ATTR_SYSTEM_DESCRIPTION: &[u8] = b"system-description\0";
pub const NM_LLDP_ATTR_SYSTEM_NAME: &[u8] = b"system-name\0";
pub const NM_LLDP_DEST_NEAREST_BRIDGE: &[u8] = b"nearest-bridge\0";
pub const NM_LLDP_DEST_NEAREST_CUSTOMER_BRIDGE: &[u8] = b"nearest-customer-bridge\0";
pub const NM_LLDP_DEST_NEAREST_NON_TPMR_BRIDGE: &[u8] = b"nearest-non-tpmr-bridge\0";
pub const NM_MAJOR_VERSION: c_int = 1;
pub const NM_MICRO_VERSION: c_int = 0;
pub const NM_MINOR_VERSION: c_int = 50;
pub const NM_OBJECT_CLIENT: &[u8] = b"client\0";
pub const NM_OBJECT_PATH: &[u8] = b"path\0";
pub const NM_REMOTE_CONNECTION_DBUS_CONNECTION: &[u8] = b"dbus-connection\0";
pub const NM_REMOTE_CONNECTION_FILENAME: &[u8] = b"filename\0";
pub const NM_REMOTE_CONNECTION_FLAGS: &[u8] = b"flags\0";
pub const NM_REMOTE_CONNECTION_PATH: &[u8] = b"path\0";
pub const NM_REMOTE_CONNECTION_UNSAVED: &[u8] = b"unsaved\0";
pub const NM_REMOTE_CONNECTION_VERSION_ID: &[u8] = b"version-id\0";
pub const NM_REMOTE_CONNECTION_VISIBLE: &[u8] = b"visible\0";
pub const NM_SECRET_AGENT_OLD_AUTO_REGISTER: &[u8] = b"auto-register\0";
pub const NM_SECRET_AGENT_OLD_CAPABILITIES: &[u8] = b"capabilities\0";
pub const NM_SECRET_AGENT_OLD_DBUS_CONNECTION: &[u8] = b"dbus-connection\0";
pub const NM_SECRET_AGENT_OLD_IDENTIFIER: &[u8] = b"identifier\0";
pub const NM_SECRET_AGENT_OLD_REGISTERED: &[u8] = b"registered\0";
pub const NM_SECRET_TAG_DYNAMIC_CHALLENGE: &[u8] = b"x-dynamic-challenge:\0";
pub const NM_SECRET_TAG_DYNAMIC_CHALLENGE_ECHO: &[u8] = b"x-dynamic-challenge-echo:\0";
pub const NM_SECRET_TAG_VPN_MSG: &[u8] = b"x-vpn-message:\0";
pub const NM_SETTING_6LOWPAN_PARENT: &[u8] = b"parent\0";
pub const NM_SETTING_6LOWPAN_SETTING_NAME: &[u8] = b"6lowpan\0";
pub const NM_SETTING_802_1X_ALTSUBJECT_MATCHES: &[u8] = b"altsubject-matches\0";
pub const NM_SETTING_802_1X_ANONYMOUS_IDENTITY: &[u8] = b"anonymous-identity\0";
pub const NM_SETTING_802_1X_AUTH_TIMEOUT: &[u8] = b"auth-timeout\0";
pub const NM_SETTING_802_1X_CA_CERT: &[u8] = b"ca-cert\0";
pub const NM_SETTING_802_1X_CA_CERT_PASSWORD: &[u8] = b"ca-cert-password\0";
pub const NM_SETTING_802_1X_CA_CERT_PASSWORD_FLAGS: &[u8] = b"ca-cert-password-flags\0";
pub const NM_SETTING_802_1X_CA_PATH: &[u8] = b"ca-path\0";
pub const NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PATH: &[u8] = b"file://\0";
pub const NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PKCS11: &[u8] = b"pkcs11:\0";
pub const NM_SETTING_802_1X_CLIENT_CERT: &[u8] = b"client-cert\0";
pub const NM_SETTING_802_1X_CLIENT_CERT_PASSWORD: &[u8] = b"client-cert-password\0";
pub const NM_SETTING_802_1X_CLIENT_CERT_PASSWORD_FLAGS: &[u8] = b"client-cert-password-flags\0";
pub const NM_SETTING_802_1X_DOMAIN_MATCH: &[u8] = b"domain-match\0";
pub const NM_SETTING_802_1X_DOMAIN_SUFFIX_MATCH: &[u8] = b"domain-suffix-match\0";
pub const NM_SETTING_802_1X_EAP: &[u8] = b"eap\0";
pub const NM_SETTING_802_1X_IDENTITY: &[u8] = b"identity\0";
pub const NM_SETTING_802_1X_OPENSSL_CIPHERS: &[u8] = b"openssl-ciphers\0";
pub const NM_SETTING_802_1X_OPTIONAL: &[u8] = b"optional\0";
pub const NM_SETTING_802_1X_PAC_FILE: &[u8] = b"pac-file\0";
pub const NM_SETTING_802_1X_PASSWORD: &[u8] = b"password\0";
pub const NM_SETTING_802_1X_PASSWORD_FLAGS: &[u8] = b"password-flags\0";
pub const NM_SETTING_802_1X_PASSWORD_RAW: &[u8] = b"password-raw\0";
pub const NM_SETTING_802_1X_PASSWORD_RAW_FLAGS: &[u8] = b"password-raw-flags\0";
pub const NM_SETTING_802_1X_PHASE1_AUTH_FLAGS: &[u8] = b"phase1-auth-flags\0";
pub const NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING: &[u8] = b"phase1-fast-provisioning\0";
pub const NM_SETTING_802_1X_PHASE1_PEAPLABEL: &[u8] = b"phase1-peaplabel\0";
pub const NM_SETTING_802_1X_PHASE1_PEAPVER: &[u8] = b"phase1-peapver\0";
pub const NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES: &[u8] = b"phase2-altsubject-matches\0";
pub const NM_SETTING_802_1X_PHASE2_AUTH: &[u8] = b"phase2-auth\0";
pub const NM_SETTING_802_1X_PHASE2_AUTHEAP: &[u8] = b"phase2-autheap\0";
pub const NM_SETTING_802_1X_PHASE2_CA_CERT: &[u8] = b"phase2-ca-cert\0";
pub const NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD: &[u8] = b"phase2-ca-cert-password\0";
pub const NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD_FLAGS: &[u8] = b"phase2-ca-cert-password-flags\0";
pub const NM_SETTING_802_1X_PHASE2_CA_PATH: &[u8] = b"phase2-ca-path\0";
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT: &[u8] = b"phase2-client-cert\0";
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD: &[u8] = b"phase2-client-cert-password\0";
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD_FLAGS: &[u8] = b"phase2-client-cert-password-flags\0";
pub const NM_SETTING_802_1X_PHASE2_DOMAIN_MATCH: &[u8] = b"phase2-domain-match\0";
pub const NM_SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH: &[u8] = b"phase2-domain-suffix-match\0";
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY: &[u8] = b"phase2-private-key\0";
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD: &[u8] = b"phase2-private-key-password\0";
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS: &[u8] = b"phase2-private-key-password-flags\0";
pub const NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH: &[u8] = b"phase2-subject-match\0";
pub const NM_SETTING_802_1X_PIN: &[u8] = b"pin\0";
pub const NM_SETTING_802_1X_PIN_FLAGS: &[u8] = b"pin-flags\0";
pub const NM_SETTING_802_1X_PRIVATE_KEY: &[u8] = b"private-key\0";
pub const NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD: &[u8] = b"private-key-password\0";
pub const NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS: &[u8] = b"private-key-password-flags\0";
pub const NM_SETTING_802_1X_SETTING_NAME: &[u8] = b"802-1x\0";
pub const NM_SETTING_802_1X_SUBJECT_MATCH: &[u8] = b"subject-match\0";
pub const NM_SETTING_802_1X_SYSTEM_CA_CERTS: &[u8] = b"system-ca-certs\0";
pub const NM_SETTING_ADSL_ENCAPSULATION: &[u8] = b"encapsulation\0";
pub const NM_SETTING_ADSL_ENCAPSULATION_LLC: &[u8] = b"llc\0";
pub const NM_SETTING_ADSL_ENCAPSULATION_VCMUX: &[u8] = b"vcmux\0";
pub const NM_SETTING_ADSL_PASSWORD: &[u8] = b"password\0";
pub const NM_SETTING_ADSL_PASSWORD_FLAGS: &[u8] = b"password-flags\0";
pub const NM_SETTING_ADSL_PROTOCOL: &[u8] = b"protocol\0";
pub const NM_SETTING_ADSL_PROTOCOL_IPOATM: &[u8] = b"ipoatm\0";
pub const NM_SETTING_ADSL_PROTOCOL_PPPOA: &[u8] = b"pppoa\0";
pub const NM_SETTING_ADSL_PROTOCOL_PPPOE: &[u8] = b"pppoe\0";
pub const NM_SETTING_ADSL_SETTING_NAME: &[u8] = b"adsl\0";
pub const NM_SETTING_ADSL_USERNAME: &[u8] = b"username\0";
pub const NM_SETTING_ADSL_VCI: &[u8] = b"vci\0";
pub const NM_SETTING_ADSL_VPI: &[u8] = b"vpi\0";
pub const NM_SETTING_BLUETOOTH_BDADDR: &[u8] = b"bdaddr\0";
pub const NM_SETTING_BLUETOOTH_SETTING_NAME: &[u8] = b"bluetooth\0";
pub const NM_SETTING_BLUETOOTH_TYPE: &[u8] = b"type\0";
pub const NM_SETTING_BLUETOOTH_TYPE_DUN: &[u8] = b"dun\0";
pub const NM_SETTING_BLUETOOTH_TYPE_NAP: &[u8] = b"nap\0";
pub const NM_SETTING_BLUETOOTH_TYPE_PANU: &[u8] = b"panu\0";
pub const NM_SETTING_BOND_OPTIONS: &[u8] = b"options\0";
pub const NM_SETTING_BOND_OPTION_ACTIVE_SLAVE: &[u8] = b"active_slave\0";
pub const NM_SETTING_BOND_OPTION_AD_ACTOR_SYSTEM: &[u8] = b"ad_actor_system\0";
pub const NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO: &[u8] = b"ad_actor_sys_prio\0";
pub const NM_SETTING_BOND_OPTION_AD_SELECT: &[u8] = b"ad_select\0";
pub const NM_SETTING_BOND_OPTION_AD_USER_PORT_KEY: &[u8] = b"ad_user_port_key\0";
pub const NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE: &[u8] = b"all_slaves_active\0";
pub const NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS: &[u8] = b"arp_all_targets\0";
pub const NM_SETTING_BOND_OPTION_ARP_INTERVAL: &[u8] = b"arp_interval\0";
pub const NM_SETTING_BOND_OPTION_ARP_IP_TARGET: &[u8] = b"arp_ip_target\0";
pub const NM_SETTING_BOND_OPTION_ARP_MISSED_MAX: &[u8] = b"arp_missed_max\0";
pub const NM_SETTING_BOND_OPTION_ARP_VALIDATE: &[u8] = b"arp_validate\0";
pub const NM_SETTING_BOND_OPTION_BALANCE_SLB: &[u8] = b"balance-slb\0";
pub const NM_SETTING_BOND_OPTION_DOWNDELAY: &[u8] = b"downdelay\0";
pub const NM_SETTING_BOND_OPTION_FAIL_OVER_MAC: &[u8] = b"fail_over_mac\0";
pub const NM_SETTING_BOND_OPTION_LACP_ACTIVE: &[u8] = b"lacp_active\0";
pub const NM_SETTING_BOND_OPTION_LACP_RATE: &[u8] = b"lacp_rate\0";
pub const NM_SETTING_BOND_OPTION_LP_INTERVAL: &[u8] = b"lp_interval\0";
pub const NM_SETTING_BOND_OPTION_MIIMON: &[u8] = b"miimon\0";
pub const NM_SETTING_BOND_OPTION_MIN_LINKS: &[u8] = b"min_links\0";
pub const NM_SETTING_BOND_OPTION_MODE: &[u8] = b"mode\0";
pub const NM_SETTING_BOND_OPTION_NS_IP6_TARGET: &[u8] = b"ns_ip6_target\0";
pub const NM_SETTING_BOND_OPTION_NUM_GRAT_ARP: &[u8] = b"num_grat_arp\0";
pub const NM_SETTING_BOND_OPTION_NUM_UNSOL_NA: &[u8] = b"num_unsol_na\0";
pub const NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE: &[u8] = b"packets_per_slave\0";
pub const NM_SETTING_BOND_OPTION_PEER_NOTIF_DELAY: &[u8] = b"peer_notif_delay\0";
pub const NM_SETTING_BOND_OPTION_PRIMARY: &[u8] = b"primary\0";
pub const NM_SETTING_BOND_OPTION_PRIMARY_RESELECT: &[u8] = b"primary_reselect\0";
pub const NM_SETTING_BOND_OPTION_RESEND_IGMP: &[u8] = b"resend_igmp\0";
pub const NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB: &[u8] = b"tlb_dynamic_lb\0";
pub const NM_SETTING_BOND_OPTION_UPDELAY: &[u8] = b"updelay\0";
pub const NM_SETTING_BOND_OPTION_USE_CARRIER: &[u8] = b"use_carrier\0";
pub const NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY: &[u8] = b"xmit_hash_policy\0";
pub const NM_SETTING_BOND_PORT_PRIO: &[u8] = b"prio\0";
pub const NM_SETTING_BOND_PORT_QUEUE_ID: &[u8] = b"queue-id\0";
pub const NM_SETTING_BOND_PORT_SETTING_NAME: &[u8] = b"bond-port\0";
pub const NM_SETTING_BOND_SETTING_NAME: &[u8] = b"bond\0";
pub const NM_SETTING_BRIDGE_AGEING_TIME: &[u8] = b"ageing-time\0";
pub const NM_SETTING_BRIDGE_FORWARD_DELAY: &[u8] = b"forward-delay\0";
pub const NM_SETTING_BRIDGE_GROUP_ADDRESS: &[u8] = b"group-address\0";
pub const NM_SETTING_BRIDGE_GROUP_FORWARD_MASK: &[u8] = b"group-forward-mask\0";
pub const NM_SETTING_BRIDGE_HELLO_TIME: &[u8] = b"hello-time\0";
pub const NM_SETTING_BRIDGE_MAC_ADDRESS: &[u8] = b"mac-address\0";
pub const NM_SETTING_BRIDGE_MAX_AGE: &[u8] = b"max-age\0";
pub const NM_SETTING_BRIDGE_MULTICAST_HASH_MAX: &[u8] = b"multicast-hash-max\0";
pub const NM_SETTING_BRIDGE_MULTICAST_LAST_MEMBER_COUNT: &[u8] = b"multicast-last-member-count\0";
pub const NM_SETTING_BRIDGE_MULTICAST_LAST_MEMBER_INTERVAL: &[u8] = b"multicast-last-member-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_MEMBERSHIP_INTERVAL: &[u8] = b"multicast-membership-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERIER: &[u8] = b"multicast-querier\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERIER_INTERVAL: &[u8] = b"multicast-querier-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERY_INTERVAL: &[u8] = b"multicast-query-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERY_RESPONSE_INTERVAL: &[u8] = b"multicast-query-response-interval\0";
pub const NM_SETTING_BRIDGE_MULTICAST_QUERY_USE_IFADDR: &[u8] = b"multicast-query-use-ifaddr\0";
pub const NM_SETTING_BRIDGE_MULTICAST_ROUTER: &[u8] = b"multicast-router\0";
pub const NM_SETTING_BRIDGE_MULTICAST_SNOOPING: &[u8] = b"multicast-snooping\0";
pub const NM_SETTING_BRIDGE_MULTICAST_STARTUP_QUERY_COUNT: &[u8] = b"multicast-startup-query-count\0";
pub const NM_SETTING_BRIDGE_MULTICAST_STARTUP_QUERY_INTERVAL: &[u8] = b"multicast-startup-query-interval\0";
pub const NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE: &[u8] = b"hairpin-mode\0";
pub const NM_SETTING_BRIDGE_PORT_PATH_COST: &[u8] = b"path-cost\0";
pub const NM_SETTING_BRIDGE_PORT_PRIORITY: &[u8] = b"priority\0";
pub const NM_SETTING_BRIDGE_PORT_SETTING_NAME: &[u8] = b"bridge-port\0";
pub const NM_SETTING_BRIDGE_PORT_VLANS: &[u8] = b"vlans\0";
pub const NM_SETTING_BRIDGE_PRIORITY: &[u8] = b"priority\0";
pub const NM_SETTING_BRIDGE_SETTING_NAME: &[u8] = b"bridge\0";
pub const NM_SETTING_BRIDGE_STP: &[u8] = b"stp\0";
pub const NM_SETTING_BRIDGE_VLANS: &[u8] = b"vlans\0";
pub const NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID: &[u8] = b"vlan-default-pvid\0";
pub const NM_SETTING_BRIDGE_VLAN_FILTERING: &[u8] = b"vlan-filtering\0";
pub const NM_SETTING_BRIDGE_VLAN_PROTOCOL: &[u8] = b"vlan-protocol\0";
pub const NM_SETTING_BRIDGE_VLAN_STATS_ENABLED: &[u8] = b"vlan-stats-enabled\0";
pub const NM_SETTING_CDMA_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_CDMA_NUMBER: &[u8] = b"number\0";
pub const NM_SETTING_CDMA_PASSWORD: &[u8] = b"password\0";
pub const NM_SETTING_CDMA_PASSWORD_FLAGS: &[u8] = b"password-flags\0";
pub const NM_SETTING_CDMA_SETTING_NAME: &[u8] = b"cdma\0";
pub const NM_SETTING_CDMA_USERNAME: &[u8] = b"username\0";
pub const NM_SETTING_CONNECTION_AUTH_RETRIES: &[u8] = b"auth-retries\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT: &[u8] = b"autoconnect\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PORTS: &[u8] = b"autoconnect-ports\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY: &[u8] = b"autoconnect-priority\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT: c_int = 0;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX: c_int = 999;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN: c_int = -999;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES: &[u8] = b"autoconnect-retries\0";
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES: &[u8] = b"autoconnect-slaves\0";
pub const NM_SETTING_CONNECTION_CONTROLLER: &[u8] = b"controller\0";
pub const NM_SETTING_CONNECTION_DNS_OVER_TLS: &[u8] = b"dns-over-tls\0";
pub const NM_SETTING_CONNECTION_DOWN_ON_POWEROFF: &[u8] = b"down-on-poweroff\0";
pub const NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT: &[u8] = b"gateway-ping-timeout\0";
pub const NM_SETTING_CONNECTION_ID: &[u8] = b"id\0";
pub const NM_SETTING_CONNECTION_INTERFACE_NAME: &[u8] = b"interface-name\0";
pub const NM_SETTING_CONNECTION_LLDP: &[u8] = b"lldp\0";
pub const NM_SETTING_CONNECTION_LLMNR: &[u8] = b"llmnr\0";
pub const NM_SETTING_CONNECTION_MASTER: &[u8] = b"master\0";
pub const NM_SETTING_CONNECTION_MDNS: &[u8] = b"mdns\0";
pub const NM_SETTING_CONNECTION_METERED: &[u8] = b"metered\0";
pub const NM_SETTING_CONNECTION_MPTCP_FLAGS: &[u8] = b"mptcp-flags\0";
pub const NM_SETTING_CONNECTION_MUD_URL: &[u8] = b"mud-url\0";
pub const NM_SETTING_CONNECTION_MULTI_CONNECT: &[u8] = b"multi-connect\0";
pub const NM_SETTING_CONNECTION_PERMISSIONS: &[u8] = b"permissions\0";
pub const NM_SETTING_CONNECTION_PORT_TYPE: &[u8] = b"port-type\0";
pub const NM_SETTING_CONNECTION_READ_ONLY: &[u8] = b"read-only\0";
pub const NM_SETTING_CONNECTION_SECONDARIES: &[u8] = b"secondaries\0";
pub const NM_SETTING_CONNECTION_SETTING_NAME: &[u8] = b"connection\0";
pub const NM_SETTING_CONNECTION_SLAVE_TYPE: &[u8] = b"slave-type\0";
pub const NM_SETTING_CONNECTION_STABLE_ID: &[u8] = b"stable-id\0";
pub const NM_SETTING_CONNECTION_TIMESTAMP: &[u8] = b"timestamp\0";
pub const NM_SETTING_CONNECTION_TYPE: &[u8] = b"type\0";
pub const NM_SETTING_CONNECTION_UUID: &[u8] = b"uuid\0";
pub const NM_SETTING_CONNECTION_WAIT_ACTIVATION_DELAY: &[u8] = b"wait-activation-delay\0";
pub const NM_SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT: &[u8] = b"wait-device-timeout\0";
pub const NM_SETTING_CONNECTION_ZONE: &[u8] = b"zone\0";
pub const NM_SETTING_DCB_APP_FCOE_FLAGS: &[u8] = b"app-fcoe-flags\0";
pub const NM_SETTING_DCB_APP_FCOE_MODE: &[u8] = b"app-fcoe-mode\0";
pub const NM_SETTING_DCB_APP_FCOE_PRIORITY: &[u8] = b"app-fcoe-priority\0";
pub const NM_SETTING_DCB_APP_FIP_FLAGS: &[u8] = b"app-fip-flags\0";
pub const NM_SETTING_DCB_APP_FIP_PRIORITY: &[u8] = b"app-fip-priority\0";
pub const NM_SETTING_DCB_APP_ISCSI_FLAGS: &[u8] = b"app-iscsi-flags\0";
pub const NM_SETTING_DCB_APP_ISCSI_PRIORITY: &[u8] = b"app-iscsi-priority\0";
pub const NM_SETTING_DCB_FCOE_MODE_FABRIC: &[u8] = b"fabric\0";
pub const NM_SETTING_DCB_FCOE_MODE_VN2VN: &[u8] = b"vn2vn\0";
pub const NM_SETTING_DCB_PRIORITY_BANDWIDTH: &[u8] = b"priority-bandwidth\0";
pub const NM_SETTING_DCB_PRIORITY_FLOW_CONTROL: &[u8] = b"priority-flow-control\0";
pub const NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS: &[u8] = b"priority-flow-control-flags\0";
pub const NM_SETTING_DCB_PRIORITY_GROUP_BANDWIDTH: &[u8] = b"priority-group-bandwidth\0";
pub const NM_SETTING_DCB_PRIORITY_GROUP_FLAGS: &[u8] = b"priority-group-flags\0";
pub const NM_SETTING_DCB_PRIORITY_GROUP_ID: &[u8] = b"priority-group-id\0";
pub const NM_SETTING_DCB_PRIORITY_STRICT_BANDWIDTH: &[u8] = b"priority-strict-bandwidth\0";
pub const NM_SETTING_DCB_PRIORITY_TRAFFIC_CLASS: &[u8] = b"priority-traffic-class\0";
pub const NM_SETTING_DCB_SETTING_NAME: &[u8] = b"dcb\0";
pub const NM_SETTING_DNS_OPTION_ATTEMPTS: &[u8] = b"attempts\0";
pub const NM_SETTING_DNS_OPTION_DEBUG: &[u8] = b"debug\0";
pub const NM_SETTING_DNS_OPTION_EDNS0: &[u8] = b"edns0\0";
pub const NM_SETTING_DNS_OPTION_INET6: &[u8] = b"inet6\0";
pub const NM_SETTING_DNS_OPTION_INTERNAL_NO_ADD_EDNS0: &[u8] = b"_no-add-edns0\0";
pub const NM_SETTING_DNS_OPTION_INTERNAL_NO_ADD_TRUST_AD: &[u8] = b"_no-add-trust-ad\0";
pub const NM_SETTING_DNS_OPTION_IP6_BYTESTRING: &[u8] = b"ip6-bytestring\0";
pub const NM_SETTING_DNS_OPTION_IP6_DOTINT: &[u8] = b"ip6-dotint\0";
pub const NM_SETTING_DNS_OPTION_NDOTS: &[u8] = b"ndots\0";
pub const NM_SETTING_DNS_OPTION_NO_AAAA: &[u8] = b"no-aaaa\0";
pub const NM_SETTING_DNS_OPTION_NO_CHECK_NAMES: &[u8] = b"no-check-names\0";
pub const NM_SETTING_DNS_OPTION_NO_IP6_DOTINT: &[u8] = b"no-ip6-dotint\0";
pub const NM_SETTING_DNS_OPTION_NO_RELOAD: &[u8] = b"no-reload\0";
pub const NM_SETTING_DNS_OPTION_NO_TLD_QUERY: &[u8] = b"no-tld-query\0";
pub const NM_SETTING_DNS_OPTION_ROTATE: &[u8] = b"rotate\0";
pub const NM_SETTING_DNS_OPTION_SINGLE_REQUEST: &[u8] = b"single-request\0";
pub const NM_SETTING_DNS_OPTION_SINGLE_REQUEST_REOPEN: &[u8] = b"single-request-reopen\0";
pub const NM_SETTING_DNS_OPTION_TIMEOUT: &[u8] = b"timeout\0";
pub const NM_SETTING_DNS_OPTION_TRUST_AD: &[u8] = b"trust-ad\0";
pub const NM_SETTING_DNS_OPTION_USE_VC: &[u8] = b"use-vc\0";
pub const NM_SETTING_DUMMY_SETTING_NAME: &[u8] = b"dummy\0";
pub const NM_SETTING_ETHTOOL_SETTING_NAME: &[u8] = b"ethtool\0";
pub const NM_SETTING_GENERIC_DEVICE_HANDLER: &[u8] = b"device-handler\0";
pub const NM_SETTING_GENERIC_SETTING_NAME: &[u8] = b"generic\0";
pub const NM_SETTING_GSM_APN: &[u8] = b"apn\0";
pub const NM_SETTING_GSM_AUTO_CONFIG: &[u8] = b"auto-config\0";
pub const NM_SETTING_GSM_DEVICE_ID: &[u8] = b"device-id\0";
pub const NM_SETTING_GSM_HOME_ONLY: &[u8] = b"home-only\0";
pub const NM_SETTING_GSM_INITIAL_EPS_BEARER_APN: &[u8] = b"initial-eps-bearer-apn\0";
pub const NM_SETTING_GSM_INITIAL_EPS_BEARER_CONFIGURE: &[u8] = b"initial-eps-bearer-configure\0";
pub const NM_SETTING_GSM_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_GSM_NETWORK_ID: &[u8] = b"network-id\0";
pub const NM_SETTING_GSM_NUMBER: &[u8] = b"number\0";
pub const NM_SETTING_GSM_PASSWORD: &[u8] = b"password\0";
pub const NM_SETTING_GSM_PASSWORD_FLAGS: &[u8] = b"password-flags\0";
pub const NM_SETTING_GSM_PIN: &[u8] = b"pin\0";
pub const NM_SETTING_GSM_PIN_FLAGS: &[u8] = b"pin-flags\0";
pub const NM_SETTING_GSM_SETTING_NAME: &[u8] = b"gsm\0";
pub const NM_SETTING_GSM_SIM_ID: &[u8] = b"sim-id\0";
pub const NM_SETTING_GSM_SIM_OPERATOR_ID: &[u8] = b"sim-operator-id\0";
pub const NM_SETTING_GSM_USERNAME: &[u8] = b"username\0";
pub const NM_SETTING_HOSTNAME_FROM_DHCP: &[u8] = b"from-dhcp\0";
pub const NM_SETTING_HOSTNAME_FROM_DNS_LOOKUP: &[u8] = b"from-dns-lookup\0";
pub const NM_SETTING_HOSTNAME_ONLY_FROM_DEFAULT: &[u8] = b"only-from-default\0";
pub const NM_SETTING_HOSTNAME_PRIORITY: &[u8] = b"priority\0";
pub const NM_SETTING_HOSTNAME_SETTING_NAME: &[u8] = b"hostname\0";
pub const NM_SETTING_HSR_MULTICAST_SPEC: &[u8] = b"multicast-spec\0";
pub const NM_SETTING_HSR_PORT1: &[u8] = b"port1\0";
pub const NM_SETTING_HSR_PORT2: &[u8] = b"port2\0";
pub const NM_SETTING_HSR_PRP: &[u8] = b"prp\0";
pub const NM_SETTING_HSR_SETTING_NAME: &[u8] = b"hsr\0";
pub const NM_SETTING_INFINIBAND_MAC_ADDRESS: &[u8] = b"mac-address\0";
pub const NM_SETTING_INFINIBAND_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_INFINIBAND_PARENT: &[u8] = b"parent\0";
pub const NM_SETTING_INFINIBAND_P_KEY: &[u8] = b"p-key\0";
pub const NM_SETTING_INFINIBAND_SETTING_NAME: &[u8] = b"infiniband\0";
pub const NM_SETTING_INFINIBAND_TRANSPORT_MODE: &[u8] = b"transport-mode\0";
pub const NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID: &[u8] = b"dhcp-client-id\0";
pub const NM_SETTING_IP4_CONFIG_DHCP_FQDN: &[u8] = b"dhcp-fqdn\0";
pub const NM_SETTING_IP4_CONFIG_DHCP_VENDOR_CLASS_IDENTIFIER: &[u8] = b"dhcp-vendor-class-identifier\0";
pub const NM_SETTING_IP4_CONFIG_LINK_LOCAL: &[u8] = b"link-local\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_AUTO: &[u8] = b"auto\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_DISABLED: &[u8] = b"disabled\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL: &[u8] = b"link-local\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_MANUAL: &[u8] = b"manual\0";
pub const NM_SETTING_IP4_CONFIG_METHOD_SHARED: &[u8] = b"shared\0";
pub const NM_SETTING_IP4_CONFIG_SETTING_NAME: &[u8] = b"ipv4\0";
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE: &[u8] = b"addr-gen-mode\0";
pub const NM_SETTING_IP6_CONFIG_DHCP_DUID: &[u8] = b"dhcp-duid\0";
pub const NM_SETTING_IP6_CONFIG_DHCP_PD_HINT: &[u8] = b"dhcp-pd-hint\0";
pub const NM_SETTING_IP6_CONFIG_IP6_PRIVACY: &[u8] = b"ip6-privacy\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_AUTO: &[u8] = b"auto\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_DHCP: &[u8] = b"dhcp\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_DISABLED: &[u8] = b"disabled\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_IGNORE: &[u8] = b"ignore\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL: &[u8] = b"link-local\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_MANUAL: &[u8] = b"manual\0";
pub const NM_SETTING_IP6_CONFIG_METHOD_SHARED: &[u8] = b"shared\0";
pub const NM_SETTING_IP6_CONFIG_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_IP6_CONFIG_RA_TIMEOUT: &[u8] = b"ra-timeout\0";
pub const NM_SETTING_IP6_CONFIG_SETTING_NAME: &[u8] = b"ipv6\0";
pub const NM_SETTING_IP6_CONFIG_TEMP_PREFERRED_LIFETIME: &[u8] = b"temp-preferred-lifetime\0";
pub const NM_SETTING_IP6_CONFIG_TEMP_VALID_LIFETIME: &[u8] = b"temp-valid-lifetime\0";
pub const NM_SETTING_IP6_CONFIG_TOKEN: &[u8] = b"token\0";
pub const NM_SETTING_IP_CONFIG_ADDRESSES: &[u8] = b"addresses\0";
pub const NM_SETTING_IP_CONFIG_AUTO_ROUTE_EXT_GW: &[u8] = b"auto-route-ext-gw\0";
pub const NM_SETTING_IP_CONFIG_DAD_TIMEOUT: &[u8] = b"dad-timeout\0";
pub const NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX: c_int = 30000;
pub const NM_SETTING_IP_CONFIG_DHCP_DSCP: &[u8] = b"dhcp-dscp\0";
pub const NM_SETTING_IP_CONFIG_DHCP_HOSTNAME: &[u8] = b"dhcp-hostname\0";
pub const NM_SETTING_IP_CONFIG_DHCP_HOSTNAME_FLAGS: &[u8] = b"dhcp-hostname-flags\0";
pub const NM_SETTING_IP_CONFIG_DHCP_IAID: &[u8] = b"dhcp-iaid\0";
pub const NM_SETTING_IP_CONFIG_DHCP_REJECT_SERVERS: &[u8] = b"dhcp-reject-servers\0";
pub const NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME: &[u8] = b"dhcp-send-hostname\0";
pub const NM_SETTING_IP_CONFIG_DHCP_SEND_RELEASE: &[u8] = b"dhcp-send-release\0";
pub const NM_SETTING_IP_CONFIG_DHCP_TIMEOUT: &[u8] = b"dhcp-timeout\0";
pub const NM_SETTING_IP_CONFIG_DNS: &[u8] = b"dns\0";
pub const NM_SETTING_IP_CONFIG_DNS_OPTIONS: &[u8] = b"dns-options\0";
pub const NM_SETTING_IP_CONFIG_DNS_PRIORITY: &[u8] = b"dns-priority\0";
pub const NM_SETTING_IP_CONFIG_DNS_SEARCH: &[u8] = b"dns-search\0";
pub const NM_SETTING_IP_CONFIG_GATEWAY: &[u8] = b"gateway\0";
pub const NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS: &[u8] = b"ignore-auto-dns\0";
pub const NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES: &[u8] = b"ignore-auto-routes\0";
pub const NM_SETTING_IP_CONFIG_MAY_FAIL: &[u8] = b"may-fail\0";
pub const NM_SETTING_IP_CONFIG_METHOD: &[u8] = b"method\0";
pub const NM_SETTING_IP_CONFIG_NEVER_DEFAULT: &[u8] = b"never-default\0";
pub const NM_SETTING_IP_CONFIG_REPLACE_LOCAL_RULE: &[u8] = b"replace-local-rule\0";
pub const NM_SETTING_IP_CONFIG_REQUIRED_TIMEOUT: &[u8] = b"required-timeout\0";
pub const NM_SETTING_IP_CONFIG_ROUTES: &[u8] = b"routes\0";
pub const NM_SETTING_IP_CONFIG_ROUTE_METRIC: &[u8] = b"route-metric\0";
pub const NM_SETTING_IP_CONFIG_ROUTE_TABLE: &[u8] = b"route-table\0";
pub const NM_SETTING_IP_CONFIG_ROUTING_RULES: &[u8] = b"routing-rules\0";
pub const NM_SETTING_IP_TUNNEL_ENCAPSULATION_LIMIT: &[u8] = b"encapsulation-limit\0";
pub const NM_SETTING_IP_TUNNEL_FLAGS: &[u8] = b"flags\0";
pub const NM_SETTING_IP_TUNNEL_FLOW_LABEL: &[u8] = b"flow-label\0";
pub const NM_SETTING_IP_TUNNEL_FWMARK: &[u8] = b"fwmark\0";
pub const NM_SETTING_IP_TUNNEL_INPUT_KEY: &[u8] = b"input-key\0";
pub const NM_SETTING_IP_TUNNEL_LOCAL: &[u8] = b"local\0";
pub const NM_SETTING_IP_TUNNEL_MODE: &[u8] = b"mode\0";
pub const NM_SETTING_IP_TUNNEL_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_IP_TUNNEL_OUTPUT_KEY: &[u8] = b"output-key\0";
pub const NM_SETTING_IP_TUNNEL_PARENT: &[u8] = b"parent\0";
pub const NM_SETTING_IP_TUNNEL_PATH_MTU_DISCOVERY: &[u8] = b"path-mtu-discovery\0";
pub const NM_SETTING_IP_TUNNEL_REMOTE: &[u8] = b"remote\0";
pub const NM_SETTING_IP_TUNNEL_SETTING_NAME: &[u8] = b"ip-tunnel\0";
pub const NM_SETTING_IP_TUNNEL_TOS: &[u8] = b"tos\0";
pub const NM_SETTING_IP_TUNNEL_TTL: &[u8] = b"ttl\0";
pub const NM_SETTING_LINK_GRO_MAX_SIZE: &[u8] = b"gro-max-size\0";
pub const NM_SETTING_LINK_GSO_MAX_SEGMENTS: &[u8] = b"gso-max-segments\0";
pub const NM_SETTING_LINK_GSO_MAX_SIZE: &[u8] = b"gso-max-size\0";
pub const NM_SETTING_LINK_SETTING_NAME: &[u8] = b"link\0";
pub const NM_SETTING_LINK_TX_QUEUE_LENGTH: &[u8] = b"tx-queue-length\0";
pub const NM_SETTING_LOOPBACK_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_LOOPBACK_SETTING_NAME: &[u8] = b"loopback\0";
pub const NM_SETTING_MACSEC_ENCRYPT: &[u8] = b"encrypt\0";
pub const NM_SETTING_MACSEC_MKA_CAK: &[u8] = b"mka-cak\0";
pub const NM_SETTING_MACSEC_MKA_CAK_FLAGS: &[u8] = b"mka-cak-flags\0";
pub const NM_SETTING_MACSEC_MKA_CAK_LENGTH: c_int = 32;
pub const NM_SETTING_MACSEC_MKA_CKN: &[u8] = b"mka-ckn\0";
pub const NM_SETTING_MACSEC_MKA_CKN_LENGTH: c_int = 64;
pub const NM_SETTING_MACSEC_MODE: &[u8] = b"mode\0";
pub const NM_SETTING_MACSEC_OFFLOAD: &[u8] = b"offload\0";
pub const NM_SETTING_MACSEC_PARENT: &[u8] = b"parent\0";
pub const NM_SETTING_MACSEC_PORT: &[u8] = b"port\0";
pub const NM_SETTING_MACSEC_SEND_SCI: &[u8] = b"send-sci\0";
pub const NM_SETTING_MACSEC_SETTING_NAME: &[u8] = b"macsec\0";
pub const NM_SETTING_MACSEC_VALIDATION: &[u8] = b"validation\0";
pub const NM_SETTING_MACVLAN_MODE: &[u8] = b"mode\0";
pub const NM_SETTING_MACVLAN_PARENT: &[u8] = b"parent\0";
pub const NM_SETTING_MACVLAN_PROMISCUOUS: &[u8] = b"promiscuous\0";
pub const NM_SETTING_MACVLAN_SETTING_NAME: &[u8] = b"macvlan\0";
pub const NM_SETTING_MACVLAN_TAP: &[u8] = b"tap\0";
pub const NM_SETTING_MATCH_DRIVER: &[u8] = b"driver\0";
pub const NM_SETTING_MATCH_INTERFACE_NAME: &[u8] = b"interface-name\0";
pub const NM_SETTING_MATCH_KERNEL_COMMAND_LINE: &[u8] = b"kernel-command-line\0";
pub const NM_SETTING_MATCH_PATH: &[u8] = b"path\0";
pub const NM_SETTING_MATCH_SETTING_NAME: &[u8] = b"match\0";
pub const NM_SETTING_NAME: &[u8] = b"name\0";
pub const NM_SETTING_OLPC_MESH_CHANNEL: &[u8] = b"channel\0";
pub const NM_SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS: &[u8] = b"dhcp-anycast-address\0";
pub const NM_SETTING_OLPC_MESH_SETTING_NAME: &[u8] = b"802-11-olpc-mesh\0";
pub const NM_SETTING_OLPC_MESH_SSID: &[u8] = b"ssid\0";
pub const NM_SETTING_OVS_BRIDGE_DATAPATH_TYPE: &[u8] = b"datapath-type\0";
pub const NM_SETTING_OVS_BRIDGE_FAIL_MODE: &[u8] = b"fail-mode\0";
pub const NM_SETTING_OVS_BRIDGE_MCAST_SNOOPING_ENABLE: &[u8] = b"mcast-snooping-enable\0";
pub const NM_SETTING_OVS_BRIDGE_RSTP_ENABLE: &[u8] = b"rstp-enable\0";
pub const NM_SETTING_OVS_BRIDGE_SETTING_NAME: &[u8] = b"ovs-bridge\0";
pub const NM_SETTING_OVS_BRIDGE_STP_ENABLE: &[u8] = b"stp-enable\0";
pub const NM_SETTING_OVS_DPDK_DEVARGS: &[u8] = b"devargs\0";
pub const NM_SETTING_OVS_DPDK_N_RXQ: &[u8] = b"n-rxq\0";
pub const NM_SETTING_OVS_DPDK_N_RXQ_DESC: &[u8] = b"n-rxq-desc\0";
pub const NM_SETTING_OVS_DPDK_N_TXQ_DESC: &[u8] = b"n-txq-desc\0";
pub const NM_SETTING_OVS_DPDK_SETTING_NAME: &[u8] = b"ovs-dpdk\0";
pub const NM_SETTING_OVS_EXTERNAL_IDS_DATA: &[u8] = b"data\0";
pub const NM_SETTING_OVS_EXTERNAL_IDS_SETTING_NAME: &[u8] = b"ovs-external-ids\0";
pub const NM_SETTING_OVS_INTERFACE_OFPORT_REQUEST: &[u8] = b"ofport-request\0";
pub const NM_SETTING_OVS_INTERFACE_SETTING_NAME: &[u8] = b"ovs-interface\0";
pub const NM_SETTING_OVS_INTERFACE_TYPE: &[u8] = b"type\0";
pub const NM_SETTING_OVS_OTHER_CONFIG_DATA: &[u8] = b"data\0";
pub const NM_SETTING_OVS_OTHER_CONFIG_SETTING_NAME: &[u8] = b"ovs-other-config\0";
pub const NM_SETTING_OVS_PATCH_PEER: &[u8] = b"peer\0";
pub const NM_SETTING_OVS_PATCH_SETTING_NAME: &[u8] = b"ovs-patch\0";
pub const NM_SETTING_OVS_PORT_BOND_DOWNDELAY: &[u8] = b"bond-downdelay\0";
pub const NM_SETTING_OVS_PORT_BOND_MODE: &[u8] = b"bond-mode\0";
pub const NM_SETTING_OVS_PORT_BOND_UPDELAY: &[u8] = b"bond-updelay\0";
pub const NM_SETTING_OVS_PORT_LACP: &[u8] = b"lacp\0";
pub const NM_SETTING_OVS_PORT_SETTING_NAME: &[u8] = b"ovs-port\0";
pub const NM_SETTING_OVS_PORT_TAG: &[u8] = b"tag\0";
pub const NM_SETTING_OVS_PORT_TRUNKS: &[u8] = b"trunks\0";
pub const NM_SETTING_OVS_PORT_VLAN_MODE: &[u8] = b"vlan-mode\0";
pub const NM_SETTING_PARAM_FUZZY_IGNORE: c_int = 2048;
pub const NM_SETTING_PARAM_REQUIRED: c_int = 512;
pub const NM_SETTING_PARAM_SECRET: c_int = 1024;
pub const NM_SETTING_PPPOE_PARENT: &[u8] = b"parent\0";
pub const NM_SETTING_PPPOE_PASSWORD: &[u8] = b"password\0";
pub const NM_SETTING_PPPOE_PASSWORD_FLAGS: &[u8] = b"password-flags\0";
pub const NM_SETTING_PPPOE_SERVICE: &[u8] = b"service\0";
pub const NM_SETTING_PPPOE_SETTING_NAME: &[u8] = b"pppoe\0";
pub const NM_SETTING_PPPOE_USERNAME: &[u8] = b"username\0";
pub const NM_SETTING_PPP_BAUD: &[u8] = b"baud\0";
pub const NM_SETTING_PPP_CRTSCTS: &[u8] = b"crtscts\0";
pub const NM_SETTING_PPP_LCP_ECHO_FAILURE: &[u8] = b"lcp-echo-failure\0";
pub const NM_SETTING_PPP_LCP_ECHO_INTERVAL: &[u8] = b"lcp-echo-interval\0";
pub const NM_SETTING_PPP_MPPE_STATEFUL: &[u8] = b"mppe-stateful\0";
pub const NM_SETTING_PPP_MRU: &[u8] = b"mru\0";
pub const NM_SETTING_PPP_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_PPP_NOAUTH: &[u8] = b"noauth\0";
pub const NM_SETTING_PPP_NOBSDCOMP: &[u8] = b"nobsdcomp\0";
pub const NM_SETTING_PPP_NODEFLATE: &[u8] = b"nodeflate\0";
pub const NM_SETTING_PPP_NO_VJ_COMP: &[u8] = b"no-vj-comp\0";
pub const NM_SETTING_PPP_REFUSE_CHAP: &[u8] = b"refuse-chap\0";
pub const NM_SETTING_PPP_REFUSE_EAP: &[u8] = b"refuse-eap\0";
pub const NM_SETTING_PPP_REFUSE_MSCHAP: &[u8] = b"refuse-mschap\0";
pub const NM_SETTING_PPP_REFUSE_MSCHAPV2: &[u8] = b"refuse-mschapv2\0";
pub const NM_SETTING_PPP_REFUSE_PAP: &[u8] = b"refuse-pap\0";
pub const NM_SETTING_PPP_REQUIRE_MPPE: &[u8] = b"require-mppe\0";
pub const NM_SETTING_PPP_REQUIRE_MPPE_128: &[u8] = b"require-mppe-128\0";
pub const NM_SETTING_PPP_SETTING_NAME: &[u8] = b"ppp\0";
pub const NM_SETTING_PROXY_BROWSER_ONLY: &[u8] = b"browser-only\0";
pub const NM_SETTING_PROXY_METHOD: &[u8] = b"method\0";
pub const NM_SETTING_PROXY_PAC_SCRIPT: &[u8] = b"pac-script\0";
pub const NM_SETTING_PROXY_PAC_URL: &[u8] = b"pac-url\0";
pub const NM_SETTING_PROXY_SETTING_NAME: &[u8] = b"proxy\0";
pub const NM_SETTING_SERIAL_BAUD: &[u8] = b"baud\0";
pub const NM_SETTING_SERIAL_BITS: &[u8] = b"bits\0";
pub const NM_SETTING_SERIAL_PARITY: &[u8] = b"parity\0";
pub const NM_SETTING_SERIAL_SEND_DELAY: &[u8] = b"send-delay\0";
pub const NM_SETTING_SERIAL_SETTING_NAME: &[u8] = b"serial\0";
pub const NM_SETTING_SERIAL_STOPBITS: &[u8] = b"stopbits\0";
pub const NM_SETTING_SRIOV_AUTOPROBE_DRIVERS: &[u8] = b"autoprobe-drivers\0";
pub const NM_SETTING_SRIOV_ESWITCH_ENCAP_MODE: &[u8] = b"eswitch-encap-mode\0";
pub const NM_SETTING_SRIOV_ESWITCH_INLINE_MODE: &[u8] = b"eswitch-inline-mode\0";
pub const NM_SETTING_SRIOV_ESWITCH_MODE: &[u8] = b"eswitch-mode\0";
pub const NM_SETTING_SRIOV_SETTING_NAME: &[u8] = b"sriov\0";
pub const NM_SETTING_SRIOV_TOTAL_VFS: &[u8] = b"total-vfs\0";
pub const NM_SETTING_SRIOV_VFS: &[u8] = b"vfs\0";
pub const NM_SETTING_TC_CONFIG_QDISCS: &[u8] = b"qdiscs\0";
pub const NM_SETTING_TC_CONFIG_SETTING_NAME: &[u8] = b"tc\0";
pub const NM_SETTING_TC_CONFIG_TFILTERS: &[u8] = b"tfilters\0";
pub const NM_SETTING_TEAM_CONFIG: &[u8] = b"config\0";
pub const NM_SETTING_TEAM_LINK_WATCHERS: &[u8] = b"link-watchers\0";
pub const NM_SETTING_TEAM_MCAST_REJOIN_COUNT: &[u8] = b"mcast-rejoin-count\0";
pub const NM_SETTING_TEAM_MCAST_REJOIN_INTERVAL: &[u8] = b"mcast-rejoin-interval\0";
pub const NM_SETTING_TEAM_NOTIFY_MCAST_COUNT_ACTIVEBACKUP_DEFAULT: c_int = 1;
pub const NM_SETTING_TEAM_NOTIFY_PEERS_COUNT: &[u8] = b"notify-peers-count\0";
pub const NM_SETTING_TEAM_NOTIFY_PEERS_COUNT_ACTIVEBACKUP_DEFAULT: c_int = 1;
pub const NM_SETTING_TEAM_NOTIFY_PEERS_INTERVAL: &[u8] = b"notify-peers-interval\0";
pub const NM_SETTING_TEAM_PORT_CONFIG: &[u8] = b"config\0";
pub const NM_SETTING_TEAM_PORT_LACP_KEY: &[u8] = b"lacp-key\0";
pub const NM_SETTING_TEAM_PORT_LACP_PRIO: &[u8] = b"lacp-prio\0";
pub const NM_SETTING_TEAM_PORT_LACP_PRIO_DEFAULT: c_int = 255;
pub const NM_SETTING_TEAM_PORT_LINK_WATCHERS: &[u8] = b"link-watchers\0";
pub const NM_SETTING_TEAM_PORT_PRIO: &[u8] = b"prio\0";
pub const NM_SETTING_TEAM_PORT_QUEUE_ID: &[u8] = b"queue-id\0";
pub const NM_SETTING_TEAM_PORT_QUEUE_ID_DEFAULT: c_int = -1;
pub const NM_SETTING_TEAM_PORT_SETTING_NAME: &[u8] = b"team-port\0";
pub const NM_SETTING_TEAM_PORT_STICKY: &[u8] = b"sticky\0";
pub const NM_SETTING_TEAM_RUNNER: &[u8] = b"runner\0";
pub const NM_SETTING_TEAM_RUNNER_ACTIVE: &[u8] = b"runner-active\0";
pub const NM_SETTING_TEAM_RUNNER_ACTIVEBACKUP: &[u8] = b"activebackup\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY: &[u8] = b"runner-agg-select-policy\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_BANDWIDTH: &[u8] = b"bandwidth\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_COUNT: &[u8] = b"count\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_LACP_PRIO: &[u8] = b"lacp_prio\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_LACP_PRIO_STABLE: &[u8] = b"lacp_prio_stable\0";
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_PORT_CONFIG: &[u8] = b"port_config\0";
pub const NM_SETTING_TEAM_RUNNER_BROADCAST: &[u8] = b"broadcast\0";
pub const NM_SETTING_TEAM_RUNNER_FAST_RATE: &[u8] = b"runner-fast-rate\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY: &[u8] = b"runner-hwaddr-policy\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_BY_ACTIVE: &[u8] = b"by_active\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_ONLY_ACTIVE: &[u8] = b"only_active\0";
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_SAME_ALL: &[u8] = b"same_all\0";
pub const NM_SETTING_TEAM_RUNNER_LACP: &[u8] = b"lacp\0";
pub const NM_SETTING_TEAM_RUNNER_LOADBALANCE: &[u8] = b"loadbalance\0";
pub const NM_SETTING_TEAM_RUNNER_MIN_PORTS: &[u8] = b"runner-min-ports\0";
pub const NM_SETTING_TEAM_RUNNER_RANDOM: &[u8] = b"random\0";
pub const NM_SETTING_TEAM_RUNNER_ROUNDROBIN: &[u8] = b"roundrobin\0";
pub const NM_SETTING_TEAM_RUNNER_SYS_PRIO: &[u8] = b"runner-sys-prio\0";
pub const NM_SETTING_TEAM_RUNNER_SYS_PRIO_DEFAULT: c_int = 65535;
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER: &[u8] = b"runner-tx-balancer\0";
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER_INTERVAL: &[u8] = b"runner-tx-balancer-interval\0";
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER_INTERVAL_DEFAULT: c_int = 50;
pub const NM_SETTING_TEAM_RUNNER_TX_HASH: &[u8] = b"runner-tx-hash\0";
pub const NM_SETTING_TEAM_SETTING_NAME: &[u8] = b"team\0";
pub const NM_SETTING_TUN_GROUP: &[u8] = b"group\0";
pub const NM_SETTING_TUN_MODE: &[u8] = b"mode\0";
pub const NM_SETTING_TUN_MULTI_QUEUE: &[u8] = b"multi-queue\0";
pub const NM_SETTING_TUN_OWNER: &[u8] = b"owner\0";
pub const NM_SETTING_TUN_PI: &[u8] = b"pi\0";
pub const NM_SETTING_TUN_SETTING_NAME: &[u8] = b"tun\0";
pub const NM_SETTING_TUN_VNET_HDR: &[u8] = b"vnet-hdr\0";
pub const NM_SETTING_USER_DATA: &[u8] = b"data\0";
pub const NM_SETTING_USER_SETTING_NAME: &[u8] = b"user\0";
pub const NM_SETTING_VETH_PEER: &[u8] = b"peer\0";
pub const NM_SETTING_VETH_SETTING_NAME: &[u8] = b"veth\0";
pub const NM_SETTING_VLAN_EGRESS_PRIORITY_MAP: &[u8] = b"egress-priority-map\0";
pub const NM_SETTING_VLAN_FLAGS: &[u8] = b"flags\0";
pub const NM_SETTING_VLAN_ID: &[u8] = b"id\0";
pub const NM_SETTING_VLAN_INGRESS_PRIORITY_MAP: &[u8] = b"ingress-priority-map\0";
pub const NM_SETTING_VLAN_PARENT: &[u8] = b"parent\0";
pub const NM_SETTING_VLAN_PROTOCOL: &[u8] = b"protocol\0";
pub const NM_SETTING_VLAN_SETTING_NAME: &[u8] = b"vlan\0";
pub const NM_SETTING_VPN_DATA: &[u8] = b"data\0";
pub const NM_SETTING_VPN_PERSISTENT: &[u8] = b"persistent\0";
pub const NM_SETTING_VPN_SECRETS: &[u8] = b"secrets\0";
pub const NM_SETTING_VPN_SERVICE_TYPE: &[u8] = b"service-type\0";
pub const NM_SETTING_VPN_SETTING_NAME: &[u8] = b"vpn\0";
pub const NM_SETTING_VPN_TIMEOUT: &[u8] = b"timeout\0";
pub const NM_SETTING_VPN_USER_NAME: &[u8] = b"user-name\0";
pub const NM_SETTING_VRF_SETTING_NAME: &[u8] = b"vrf\0";
pub const NM_SETTING_VRF_TABLE: &[u8] = b"table\0";
pub const NM_SETTING_VXLAN_AGEING: &[u8] = b"ageing\0";
pub const NM_SETTING_VXLAN_DESTINATION_PORT: &[u8] = b"destination-port\0";
pub const NM_SETTING_VXLAN_ID: &[u8] = b"id\0";
pub const NM_SETTING_VXLAN_L2_MISS: &[u8] = b"l2-miss\0";
pub const NM_SETTING_VXLAN_L3_MISS: &[u8] = b"l3-miss\0";
pub const NM_SETTING_VXLAN_LEARNING: &[u8] = b"learning\0";
pub const NM_SETTING_VXLAN_LIMIT: &[u8] = b"limit\0";
pub const NM_SETTING_VXLAN_LOCAL: &[u8] = b"local\0";
pub const NM_SETTING_VXLAN_PARENT: &[u8] = b"parent\0";
pub const NM_SETTING_VXLAN_PROXY: &[u8] = b"proxy\0";
pub const NM_SETTING_VXLAN_REMOTE: &[u8] = b"remote\0";
pub const NM_SETTING_VXLAN_RSC: &[u8] = b"rsc\0";
pub const NM_SETTING_VXLAN_SETTING_NAME: &[u8] = b"vxlan\0";
pub const NM_SETTING_VXLAN_SOURCE_PORT_MAX: &[u8] = b"source-port-max\0";
pub const NM_SETTING_VXLAN_SOURCE_PORT_MIN: &[u8] = b"source-port-min\0";
pub const NM_SETTING_VXLAN_TOS: &[u8] = b"tos\0";
pub const NM_SETTING_VXLAN_TTL: &[u8] = b"ttl\0";
pub const NM_SETTING_WIFI_P2P_PEER: &[u8] = b"peer\0";
pub const NM_SETTING_WIFI_P2P_SETTING_NAME: &[u8] = b"wifi-p2p\0";
pub const NM_SETTING_WIFI_P2P_WFD_IES: &[u8] = b"wfd-ies\0";
pub const NM_SETTING_WIFI_P2P_WPS_METHOD: &[u8] = b"wps-method\0";
pub const NM_SETTING_WIMAX_MAC_ADDRESS: &[u8] = b"mac-address\0";
pub const NM_SETTING_WIMAX_NETWORK_NAME: &[u8] = b"network-name\0";
pub const NM_SETTING_WIMAX_SETTING_NAME: &[u8] = b"wimax\0";
pub const NM_SETTING_WIRED_ACCEPT_ALL_MAC_ADDRESSES: &[u8] = b"accept-all-mac-addresses\0";
pub const NM_SETTING_WIRED_AUTO_NEGOTIATE: &[u8] = b"auto-negotiate\0";
pub const NM_SETTING_WIRED_CLONED_MAC_ADDRESS: &[u8] = b"cloned-mac-address\0";
pub const NM_SETTING_WIRED_DUPLEX: &[u8] = b"duplex\0";
pub const NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK: &[u8] = b"generate-mac-address-mask\0";
pub const NM_SETTING_WIRED_MAC_ADDRESS: &[u8] = b"mac-address\0";
pub const NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST: &[u8] = b"mac-address-blacklist\0";
pub const NM_SETTING_WIRED_MAC_ADDRESS_DENYLIST: &[u8] = b"mac-address-denylist\0";
pub const NM_SETTING_WIRED_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_WIRED_PORT: &[u8] = b"port\0";
pub const NM_SETTING_WIRED_S390_NETTYPE: &[u8] = b"s390-nettype\0";
pub const NM_SETTING_WIRED_S390_OPTIONS: &[u8] = b"s390-options\0";
pub const NM_SETTING_WIRED_S390_SUBCHANNELS: &[u8] = b"s390-subchannels\0";
pub const NM_SETTING_WIRED_SETTING_NAME: &[u8] = b"802-3-ethernet\0";
pub const NM_SETTING_WIRED_SPEED: &[u8] = b"speed\0";
pub const NM_SETTING_WIRED_WAKE_ON_LAN: &[u8] = b"wake-on-lan\0";
pub const NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD: &[u8] = b"wake-on-lan-password\0";
pub const NM_SETTING_WIREGUARD_FWMARK: &[u8] = b"fwmark\0";
pub const NM_SETTING_WIREGUARD_IP4_AUTO_DEFAULT_ROUTE: &[u8] = b"ip4-auto-default-route\0";
pub const NM_SETTING_WIREGUARD_IP6_AUTO_DEFAULT_ROUTE: &[u8] = b"ip6-auto-default-route\0";
pub const NM_SETTING_WIREGUARD_LISTEN_PORT: &[u8] = b"listen-port\0";
pub const NM_SETTING_WIREGUARD_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_WIREGUARD_PEERS: &[u8] = b"peers\0";
pub const NM_SETTING_WIREGUARD_PEER_ROUTES: &[u8] = b"peer-routes\0";
pub const NM_SETTING_WIREGUARD_PRIVATE_KEY: &[u8] = b"private-key\0";
pub const NM_SETTING_WIREGUARD_PRIVATE_KEY_FLAGS: &[u8] = b"private-key-flags\0";
pub const NM_SETTING_WIREGUARD_SETTING_NAME: &[u8] = b"wireguard\0";
pub const NM_SETTING_WIRELESS_AP_ISOLATION: &[u8] = b"ap-isolation\0";
pub const NM_SETTING_WIRELESS_BAND: &[u8] = b"band\0";
pub const NM_SETTING_WIRELESS_BSSID: &[u8] = b"bssid\0";
pub const NM_SETTING_WIRELESS_CHANNEL: &[u8] = b"channel\0";
pub const NM_SETTING_WIRELESS_CHANNEL_WIDTH: &[u8] = b"channel-width\0";
pub const NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS: &[u8] = b"cloned-mac-address\0";
pub const NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK: &[u8] = b"generate-mac-address-mask\0";
pub const NM_SETTING_WIRELESS_HIDDEN: &[u8] = b"hidden\0";
pub const NM_SETTING_WIRELESS_MAC_ADDRESS: &[u8] = b"mac-address\0";
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST: &[u8] = b"mac-address-blacklist\0";
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_DENYLIST: &[u8] = b"mac-address-denylist\0";
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION: &[u8] = b"mac-address-randomization\0";
pub const NM_SETTING_WIRELESS_MODE: &[u8] = b"mode\0";
pub const NM_SETTING_WIRELESS_MODE_ADHOC: &[u8] = b"adhoc\0";
pub const NM_SETTING_WIRELESS_MODE_AP: &[u8] = b"ap\0";
pub const NM_SETTING_WIRELESS_MODE_INFRA: &[u8] = b"infrastructure\0";
pub const NM_SETTING_WIRELESS_MODE_MESH: &[u8] = b"mesh\0";
pub const NM_SETTING_WIRELESS_MTU: &[u8] = b"mtu\0";
pub const NM_SETTING_WIRELESS_POWERSAVE: &[u8] = b"powersave\0";
pub const NM_SETTING_WIRELESS_RATE: &[u8] = b"rate\0";
pub const NM_SETTING_WIRELESS_SECURITY_AUTH_ALG: &[u8] = b"auth-alg\0";
pub const NM_SETTING_WIRELESS_SECURITY_FILS: &[u8] = b"fils\0";
pub const NM_SETTING_WIRELESS_SECURITY_GROUP: &[u8] = b"group\0";
pub const NM_SETTING_WIRELESS_SECURITY_KEY_MGMT: &[u8] = b"key-mgmt\0";
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD: &[u8] = b"leap-password\0";
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS: &[u8] = b"leap-password-flags\0";
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME: &[u8] = b"leap-username\0";
pub const NM_SETTING_WIRELESS_SECURITY_PAIRWISE: &[u8] = b"pairwise\0";
pub const NM_SETTING_WIRELESS_SECURITY_PMF: &[u8] = b"pmf\0";
pub const NM_SETTING_WIRELESS_SECURITY_PROTO: &[u8] = b"proto\0";
pub const NM_SETTING_WIRELESS_SECURITY_PSK: &[u8] = b"psk\0";
pub const NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS: &[u8] = b"psk-flags\0";
pub const NM_SETTING_WIRELESS_SECURITY_SETTING_NAME: &[u8] = b"802-11-wireless-security\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY0: &[u8] = b"wep-key0\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY1: &[u8] = b"wep-key1\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY2: &[u8] = b"wep-key2\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY3: &[u8] = b"wep-key3\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS: &[u8] = b"wep-key-flags\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE: &[u8] = b"wep-key-type\0";
pub const NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX: &[u8] = b"wep-tx-keyidx\0";
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD: &[u8] = b"wps-method\0";
pub const NM_SETTING_WIRELESS_SEEN_BSSIDS: &[u8] = b"seen-bssids\0";
pub const NM_SETTING_WIRELESS_SETTING_NAME: &[u8] = b"802-11-wireless\0";
pub const NM_SETTING_WIRELESS_SSID: &[u8] = b"ssid\0";
pub const NM_SETTING_WIRELESS_TX_POWER: &[u8] = b"tx-power\0";
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN: &[u8] = b"wake-on-wlan\0";
pub const NM_SETTING_WPAN_CHANNEL: &[u8] = b"channel\0";
pub const NM_SETTING_WPAN_CHANNEL_DEFAULT: c_int = -1;
pub const NM_SETTING_WPAN_MAC_ADDRESS: &[u8] = b"mac-address\0";
pub const NM_SETTING_WPAN_PAGE: &[u8] = b"page\0";
pub const NM_SETTING_WPAN_PAGE_DEFAULT: c_int = -1;
pub const NM_SETTING_WPAN_PAN_ID: &[u8] = b"pan-id\0";
pub const NM_SETTING_WPAN_SETTING_NAME: &[u8] = b"wpan\0";
pub const NM_SETTING_WPAN_SHORT_ADDRESS: &[u8] = b"short-address\0";
pub const NM_SRIOV_VF_ATTRIBUTE_MAC: &[u8] = b"mac\0";
pub const NM_SRIOV_VF_ATTRIBUTE_MAX_TX_RATE: &[u8] = b"max-tx-rate\0";
pub const NM_SRIOV_VF_ATTRIBUTE_MIN_TX_RATE: &[u8] = b"min-tx-rate\0";
pub const NM_SRIOV_VF_ATTRIBUTE_SPOOF_CHECK: &[u8] = b"spoof-check\0";
pub const NM_SRIOV_VF_ATTRIBUTE_TRUST: &[u8] = b"trust\0";
pub const NM_TEAM_LINK_WATCHER_ARP_PING: &[u8] = b"arp_ping\0";
pub const NM_TEAM_LINK_WATCHER_ETHTOOL: &[u8] = b"ethtool\0";
pub const NM_TEAM_LINK_WATCHER_NSNA_PING: &[u8] = b"nsna_ping\0";
pub const NM_UTILS_HWADDR_LEN_MAX: c_int = 20;
pub const NM_VLAN_FLAGS_ALL: c_int = 15;
pub const NM_VPN_CONNECTION_BANNER: &[u8] = b"banner\0";
pub const NM_VPN_CONNECTION_VPN_STATE: &[u8] = b"vpn-state\0";
pub const NM_VPN_DBUS_PLUGIN_INTERFACE: &[u8] = b"org.freedesktop.NetworkManager.VPN.Plugin\0";
pub const NM_VPN_DBUS_PLUGIN_PATH: &[u8] = b"/org/freedesktop/NetworkManager/VPN/Plugin\0";
pub const NM_VPN_EDITOR_PLUGIN_DESCRIPTION: &[u8] = b"description\0";
pub const NM_VPN_EDITOR_PLUGIN_NAME: &[u8] = b"name\0";
pub const NM_VPN_EDITOR_PLUGIN_SERVICE: &[u8] = b"service\0";
pub const NM_VPN_PLUGIN_CAN_PERSIST: &[u8] = b"can-persist\0";
pub const NM_VPN_PLUGIN_CONFIG_BANNER: &[u8] = b"banner\0";
pub const NM_VPN_PLUGIN_CONFIG_EXT_GATEWAY: &[u8] = b"gateway\0";
pub const NM_VPN_PLUGIN_CONFIG_HAS_IP4: &[u8] = b"has-ip4\0";
pub const NM_VPN_PLUGIN_CONFIG_HAS_IP6: &[u8] = b"has-ip6\0";
pub const NM_VPN_PLUGIN_CONFIG_MTU: &[u8] = b"mtu\0";
pub const NM_VPN_PLUGIN_CONFIG_PROXY_PAC: &[u8] = b"pac\0";
pub const NM_VPN_PLUGIN_CONFIG_TUNDEV: &[u8] = b"tundev\0";
pub const NM_VPN_PLUGIN_INFO_FILENAME: &[u8] = b"filename\0";
pub const NM_VPN_PLUGIN_INFO_KEYFILE: &[u8] = b"keyfile\0";
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_CONNECTION: &[u8] = b"VPN Connection\0";
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_GNOME: &[u8] = b"GNOME\0";
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_LIBNM: &[u8] = b"libnm\0";
pub const NM_VPN_PLUGIN_INFO_NAME: &[u8] = b"name\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_ADDRESS: &[u8] = b"address\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_DNS: &[u8] = b"dns\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_DOMAIN: &[u8] = b"domain\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_DOMAINS: &[u8] = b"domains\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY: &[u8] = b"internal-gateway\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_MSS: &[u8] = b"mss\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_NBNS: &[u8] = b"nbns\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT: &[u8] = b"never-default\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_PREFIX: &[u8] = b"prefix\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES: &[u8] = b"preserve-routes\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_PTP: &[u8] = b"ptp\0";
pub const NM_VPN_PLUGIN_IP4_CONFIG_ROUTES: &[u8] = b"routes\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_ADDRESS: &[u8] = b"address\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_DNS: &[u8] = b"dns\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_DOMAIN: &[u8] = b"domain\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_DOMAINS: &[u8] = b"domains\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY: &[u8] = b"internal-gateway\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_MSS: &[u8] = b"mss\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT: &[u8] = b"never-default\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_PREFIX: &[u8] = b"prefix\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES: &[u8] = b"preserve-routes\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_PTP: &[u8] = b"ptp\0";
pub const NM_VPN_PLUGIN_IP6_CONFIG_ROUTES: &[u8] = b"routes\0";
pub const NM_VPN_PLUGIN_OLD_DBUS_SERVICE_NAME: &[u8] = b"service-name\0";
pub const NM_VPN_PLUGIN_OLD_STATE: &[u8] = b"state\0";
pub const NM_VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME: &[u8] = b"service-name\0";
pub const NM_VPN_SERVICE_PLUGIN_DBUS_WATCH_PEER: &[u8] = b"watch-peer\0";
pub const NM_VPN_SERVICE_PLUGIN_STATE: &[u8] = b"state\0";
pub const NM_WIFI_P2P_PEER_FLAGS: &[u8] = b"flags\0";
pub const NM_WIFI_P2P_PEER_HW_ADDRESS: &[u8] = b"hw-address\0";
pub const NM_WIFI_P2P_PEER_LAST_SEEN: &[u8] = b"last-seen\0";
pub const NM_WIFI_P2P_PEER_MANUFACTURER: &[u8] = b"manufacturer\0";
pub const NM_WIFI_P2P_PEER_MODEL: &[u8] = b"model\0";
pub const NM_WIFI_P2P_PEER_MODEL_NUMBER: &[u8] = b"model-number\0";
pub const NM_WIFI_P2P_PEER_NAME: &[u8] = b"name\0";
pub const NM_WIFI_P2P_PEER_SERIAL: &[u8] = b"serial\0";
pub const NM_WIFI_P2P_PEER_STRENGTH: &[u8] = b"strength\0";
pub const NM_WIFI_P2P_PEER_WFD_IES: &[u8] = b"wfd-ies\0";
pub const NM_WIMAX_NSP_NAME: &[u8] = b"name\0";
pub const NM_WIMAX_NSP_NETWORK_TYPE: &[u8] = b"network-type\0";
pub const NM_WIMAX_NSP_SIGNAL_QUALITY: &[u8] = b"signal-quality\0";
pub const NM_WIREGUARD_PEER_ATTR_ALLOWED_IPS: &[u8] = b"allowed-ips\0";
pub const NM_WIREGUARD_PEER_ATTR_ENDPOINT: &[u8] = b"endpoint\0";
pub const NM_WIREGUARD_PEER_ATTR_PERSISTENT_KEEPALIVE: &[u8] = b"persistent-keepalive\0";
pub const NM_WIREGUARD_PEER_ATTR_PRESHARED_KEY: &[u8] = b"preshared-key\0";
pub const NM_WIREGUARD_PEER_ATTR_PRESHARED_KEY_FLAGS: &[u8] = b"preshared-key-flags\0";
pub const NM_WIREGUARD_PEER_ATTR_PUBLIC_KEY: &[u8] = b"public-key\0";
pub const NM_WIREGUARD_PUBLIC_KEY_LEN: c_int = 32;
pub const NM_WIREGUARD_SYMMETRIC_KEY_LEN: c_int = 32;

// Flags
pub type NM80211ApFlags = c_uint;
pub const NM_802_11_AP_FLAGS_NONE: NM80211ApFlags = 0;
pub const NM_802_11_AP_FLAGS_PRIVACY: NM80211ApFlags = 1;
pub const NM_802_11_AP_FLAGS_WPS: NM80211ApFlags = 2;
pub const NM_802_11_AP_FLAGS_WPS_PBC: NM80211ApFlags = 4;
pub const NM_802_11_AP_FLAGS_WPS_PIN: NM80211ApFlags = 8;

pub type NM80211ApSecurityFlags = c_uint;
pub const NM_802_11_AP_SEC_NONE: NM80211ApSecurityFlags = 0;
pub const NM_802_11_AP_SEC_PAIR_WEP40: NM80211ApSecurityFlags = 1;
pub const NM_802_11_AP_SEC_PAIR_WEP104: NM80211ApSecurityFlags = 2;
pub const NM_802_11_AP_SEC_PAIR_TKIP: NM80211ApSecurityFlags = 4;
pub const NM_802_11_AP_SEC_PAIR_CCMP: NM80211ApSecurityFlags = 8;
pub const NM_802_11_AP_SEC_GROUP_WEP40: NM80211ApSecurityFlags = 16;
pub const NM_802_11_AP_SEC_GROUP_WEP104: NM80211ApSecurityFlags = 32;
pub const NM_802_11_AP_SEC_GROUP_TKIP: NM80211ApSecurityFlags = 64;
pub const NM_802_11_AP_SEC_GROUP_CCMP: NM80211ApSecurityFlags = 128;
pub const NM_802_11_AP_SEC_KEY_MGMT_PSK: NM80211ApSecurityFlags = 256;
pub const NM_802_11_AP_SEC_KEY_MGMT_802_1X: NM80211ApSecurityFlags = 512;
pub const NM_802_11_AP_SEC_KEY_MGMT_SAE: NM80211ApSecurityFlags = 1024;
pub const NM_802_11_AP_SEC_KEY_MGMT_OWE: NM80211ApSecurityFlags = 2048;
pub const NM_802_11_AP_SEC_KEY_MGMT_OWE_TM: NM80211ApSecurityFlags = 4096;
pub const NM_802_11_AP_SEC_KEY_MGMT_EAP_SUITE_B_192: NM80211ApSecurityFlags = 8192;

pub type NMActivationStateFlags = c_uint;
pub const NM_ACTIVATION_STATE_FLAG_NONE: NMActivationStateFlags = 0;
pub const NM_ACTIVATION_STATE_FLAG_IS_CONTROLLER: NMActivationStateFlags = 1;
pub const NM_ACTIVATION_STATE_FLAG_IS_PORT: NMActivationStateFlags = 2;
pub const NM_ACTIVATION_STATE_FLAG_LAYER2_READY: NMActivationStateFlags = 4;
pub const NM_ACTIVATION_STATE_FLAG_IP4_READY: NMActivationStateFlags = 8;
pub const NM_ACTIVATION_STATE_FLAG_IP6_READY: NMActivationStateFlags = 16;
pub const NM_ACTIVATION_STATE_FLAG_CONTROLLER_HAS_PORTS: NMActivationStateFlags = 32;
pub const NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY: NMActivationStateFlags = 64;
pub const NM_ACTIVATION_STATE_FLAG_EXTERNAL: NMActivationStateFlags = 128;

pub type NMBluetoothCapabilities = c_uint;
pub const NM_BT_CAPABILITY_NONE: NMBluetoothCapabilities = 0;
pub const NM_BT_CAPABILITY_DUN: NMBluetoothCapabilities = 1;
pub const NM_BT_CAPABILITY_NAP: NMBluetoothCapabilities = 2;

pub type NMCheckpointCreateFlags = c_uint;
pub const NM_CHECKPOINT_CREATE_FLAG_NONE: NMCheckpointCreateFlags = 0;
pub const NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL: NMCheckpointCreateFlags = 1;
pub const NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS: NMCheckpointCreateFlags = 2;
pub const NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES: NMCheckpointCreateFlags = 4;
pub const NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING: NMCheckpointCreateFlags = 8;
pub const NM_CHECKPOINT_CREATE_FLAG_NO_PRESERVE_EXTERNAL_PORTS: NMCheckpointCreateFlags = 16;
pub const NM_CHECKPOINT_CREATE_FLAG_TRACK_INTERNAL_GLOBAL_DNS: NMCheckpointCreateFlags = 32;

pub type NMClientInstanceFlags = c_uint;
pub const NM_CLIENT_INSTANCE_FLAGS_NONE: NMClientInstanceFlags = 0;
pub const NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS: NMClientInstanceFlags = 1;
pub const NM_CLIENT_INSTANCE_FLAGS_INITIALIZED_GOOD: NMClientInstanceFlags = 2;
pub const NM_CLIENT_INSTANCE_FLAGS_INITIALIZED_BAD: NMClientInstanceFlags = 4;

pub type NMConnectionSerializationFlags = c_uint;
pub const NM_CONNECTION_SERIALIZE_ALL: NMConnectionSerializationFlags = 0;
pub const NM_CONNECTION_SERIALIZE_WITH_NON_SECRET: NMConnectionSerializationFlags = 1;
pub const NM_CONNECTION_SERIALIZE_NO_SECRETS: NMConnectionSerializationFlags = 1;
pub const NM_CONNECTION_SERIALIZE_WITH_SECRETS: NMConnectionSerializationFlags = 2;
pub const NM_CONNECTION_SERIALIZE_ONLY_SECRETS: NMConnectionSerializationFlags = 2;
pub const NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED: NMConnectionSerializationFlags = 4;
pub const NM_CONNECTION_SERIALIZE_WITH_SECRETS_SYSTEM_OWNED: NMConnectionSerializationFlags = 8;
pub const NM_CONNECTION_SERIALIZE_WITH_SECRETS_NOT_SAVED: NMConnectionSerializationFlags = 16;

pub type NMDeviceCapabilities = c_uint;
pub const NM_DEVICE_CAP_NONE: NMDeviceCapabilities = 0;
pub const NM_DEVICE_CAP_NM_SUPPORTED: NMDeviceCapabilities = 1;
pub const NM_DEVICE_CAP_CARRIER_DETECT: NMDeviceCapabilities = 2;
pub const NM_DEVICE_CAP_IS_SOFTWARE: NMDeviceCapabilities = 4;
pub const NM_DEVICE_CAP_SRIOV: NMDeviceCapabilities = 8;

pub type NMDeviceInterfaceFlags = c_uint;
pub const NM_DEVICE_INTERFACE_FLAG_UP: NMDeviceInterfaceFlags = 1;
pub const NM_DEVICE_INTERFACE_FLAG_LOWER_UP: NMDeviceInterfaceFlags = 2;
pub const NM_DEVICE_INTERFACE_FLAG_PROMISC: NMDeviceInterfaceFlags = 4;
pub const NM_DEVICE_INTERFACE_FLAG_CARRIER: NMDeviceInterfaceFlags = 65536;
pub const NM_DEVICE_INTERFACE_FLAG_LLDP_CLIENT_ENABLED: NMDeviceInterfaceFlags = 131072;

pub type NMDeviceModemCapabilities = c_uint;
pub const NM_DEVICE_MODEM_CAPABILITY_NONE: NMDeviceModemCapabilities = 0;
pub const NM_DEVICE_MODEM_CAPABILITY_POTS: NMDeviceModemCapabilities = 1;
pub const NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO: NMDeviceModemCapabilities = 2;
pub const NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS: NMDeviceModemCapabilities = 4;
pub const NM_DEVICE_MODEM_CAPABILITY_LTE: NMDeviceModemCapabilities = 8;
pub const NM_DEVICE_MODEM_CAPABILITY_5GNR: NMDeviceModemCapabilities = 64;

pub type NMDeviceReapplyFlags = c_uint;
pub const NM_DEVICE_REAPPLY_FLAGS_NONE: NMDeviceReapplyFlags = 0;
pub const NM_DEVICE_REAPPLY_FLAGS_PRESERVE_EXTERNAL_IP: NMDeviceReapplyFlags = 1;

pub type NMDeviceWifiCapabilities = c_uint;
pub const NM_WIFI_DEVICE_CAP_NONE: NMDeviceWifiCapabilities = 0;
pub const NM_WIFI_DEVICE_CAP_CIPHER_WEP40: NMDeviceWifiCapabilities = 1;
pub const NM_WIFI_DEVICE_CAP_CIPHER_WEP104: NMDeviceWifiCapabilities = 2;
pub const NM_WIFI_DEVICE_CAP_CIPHER_TKIP: NMDeviceWifiCapabilities = 4;
pub const NM_WIFI_DEVICE_CAP_CIPHER_CCMP: NMDeviceWifiCapabilities = 8;
pub const NM_WIFI_DEVICE_CAP_WPA: NMDeviceWifiCapabilities = 16;
pub const NM_WIFI_DEVICE_CAP_RSN: NMDeviceWifiCapabilities = 32;
pub const NM_WIFI_DEVICE_CAP_AP: NMDeviceWifiCapabilities = 64;
pub const NM_WIFI_DEVICE_CAP_ADHOC: NMDeviceWifiCapabilities = 128;
pub const NM_WIFI_DEVICE_CAP_FREQ_VALID: NMDeviceWifiCapabilities = 256;
pub const NM_WIFI_DEVICE_CAP_FREQ_2GHZ: NMDeviceWifiCapabilities = 512;
pub const NM_WIFI_DEVICE_CAP_FREQ_5GHZ: NMDeviceWifiCapabilities = 1024;
pub const NM_WIFI_DEVICE_CAP_FREQ_6GHZ: NMDeviceWifiCapabilities = 2048;
pub const NM_WIFI_DEVICE_CAP_MESH: NMDeviceWifiCapabilities = 4096;
pub const NM_WIFI_DEVICE_CAP_IBSS_RSN: NMDeviceWifiCapabilities = 8192;

pub type NMDhcpHostnameFlags = c_uint;
pub const NM_DHCP_HOSTNAME_FLAG_NONE: NMDhcpHostnameFlags = 0;
pub const NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE: NMDhcpHostnameFlags = 1;
pub const NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED: NMDhcpHostnameFlags = 2;
pub const NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE: NMDhcpHostnameFlags = 4;
pub const NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS: NMDhcpHostnameFlags = 8;

pub type NMIPAddressCmpFlags = c_uint;
pub const NM_IP_ADDRESS_CMP_FLAGS_NONE: NMIPAddressCmpFlags = 0;
pub const NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS: NMIPAddressCmpFlags = 1;

pub type NMIPRoutingRuleAsStringFlags = c_uint;
pub const NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE: NMIPRoutingRuleAsStringFlags = 0;
pub const NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET: NMIPRoutingRuleAsStringFlags = 1;
pub const NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6: NMIPRoutingRuleAsStringFlags = 2;
pub const NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE: NMIPRoutingRuleAsStringFlags = 4;

pub type NMIPTunnelFlags = c_uint;
pub const NM_IP_TUNNEL_FLAG_NONE: NMIPTunnelFlags = 0;
pub const NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT: NMIPTunnelFlags = 1;
pub const NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS: NMIPTunnelFlags = 2;
pub const NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL: NMIPTunnelFlags = 4;
pub const NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV: NMIPTunnelFlags = 8;
pub const NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY: NMIPTunnelFlags = 16;
pub const NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK: NMIPTunnelFlags = 32;

pub type NMKeyfileHandlerFlags = c_uint;
pub const NM_KEYFILE_HANDLER_FLAGS_NONE: NMKeyfileHandlerFlags = 0;

pub type NMManagerReloadFlags = c_uint;
pub const NM_MANAGER_RELOAD_FLAG_CONF: NMManagerReloadFlags = 1;
pub const NM_MANAGER_RELOAD_FLAG_DNS_RC: NMManagerReloadFlags = 2;
pub const NM_MANAGER_RELOAD_FLAG_DNS_FULL: NMManagerReloadFlags = 4;

pub type NMMptcpFlags = c_uint;
pub const NM_MPTCP_FLAGS_NONE: NMMptcpFlags = 0;
pub const NM_MPTCP_FLAGS_DISABLED: NMMptcpFlags = 1;
pub const NM_MPTCP_FLAGS_ENABLED: NMMptcpFlags = 2;
pub const NM_MPTCP_FLAGS_ALSO_WITHOUT_SYSCTL: NMMptcpFlags = 4;
pub const NM_MPTCP_FLAGS_ALSO_WITHOUT_DEFAULT_ROUTE: NMMptcpFlags = 8;
pub const NM_MPTCP_FLAGS_SIGNAL: NMMptcpFlags = 16;
pub const NM_MPTCP_FLAGS_SUBFLOW: NMMptcpFlags = 32;
pub const NM_MPTCP_FLAGS_BACKUP: NMMptcpFlags = 64;
pub const NM_MPTCP_FLAGS_FULLMESH: NMMptcpFlags = 128;

pub type NMRadioFlags = c_uint;
pub const NM_RADIO_FLAG_NONE: NMRadioFlags = 0;
pub const NM_RADIO_FLAG_WLAN_AVAILABLE: NMRadioFlags = 1;
pub const NM_RADIO_FLAG_WWAN_AVAILABLE: NMRadioFlags = 2;

pub type NMSecretAgentCapabilities = c_uint;
pub const NM_SECRET_AGENT_CAPABILITY_NONE: NMSecretAgentCapabilities = 0;
pub const NM_SECRET_AGENT_CAPABILITY_VPN_HINTS: NMSecretAgentCapabilities = 1;
pub const NM_SECRET_AGENT_CAPABILITY_LAST: NMSecretAgentCapabilities = 1;

pub type NMSecretAgentGetSecretsFlags = c_uint;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE: NMSecretAgentGetSecretsFlags = 0;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION: NMSecretAgentGetSecretsFlags = 1;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW: NMSecretAgentGetSecretsFlags = 2;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED: NMSecretAgentGetSecretsFlags = 4;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE: NMSecretAgentGetSecretsFlags = 8;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM: NMSecretAgentGetSecretsFlags = 2147483648;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS: NMSecretAgentGetSecretsFlags = 1073741824;

pub type NMSetting8021xAuthFlags = c_uint;
pub const NM_SETTING_802_1X_AUTH_FLAGS_NONE: NMSetting8021xAuthFlags = 0;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE: NMSetting8021xAuthFlags = 1;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE: NMSetting8021xAuthFlags = 2;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE: NMSetting8021xAuthFlags = 4;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_DISABLE_TIME_CHECKS: NMSetting8021xAuthFlags = 8;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_3_DISABLE: NMSetting8021xAuthFlags = 16;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_ENABLE: NMSetting8021xAuthFlags = 32;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_ENABLE: NMSetting8021xAuthFlags = 64;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_ENABLE: NMSetting8021xAuthFlags = 128;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_3_ENABLE: NMSetting8021xAuthFlags = 256;
pub const NM_SETTING_802_1X_AUTH_FLAGS_ALL: NMSetting8021xAuthFlags = 511;

pub type NMSettingDcbFlags = c_uint;
pub const NM_SETTING_DCB_FLAG_NONE: NMSettingDcbFlags = 0;
pub const NM_SETTING_DCB_FLAG_ENABLE: NMSettingDcbFlags = 1;
pub const NM_SETTING_DCB_FLAG_ADVERTISE: NMSettingDcbFlags = 2;
pub const NM_SETTING_DCB_FLAG_WILLING: NMSettingDcbFlags = 4;

pub type NMSettingSecretFlags = c_uint;
pub const NM_SETTING_SECRET_FLAG_NONE: NMSettingSecretFlags = 0;
pub const NM_SETTING_SECRET_FLAG_AGENT_OWNED: NMSettingSecretFlags = 1;
pub const NM_SETTING_SECRET_FLAG_NOT_SAVED: NMSettingSecretFlags = 2;
pub const NM_SETTING_SECRET_FLAG_NOT_REQUIRED: NMSettingSecretFlags = 4;

pub type NMSettingWiredWakeOnLan = c_uint;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_PHY: NMSettingWiredWakeOnLan = 2;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST: NMSettingWiredWakeOnLan = 4;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST: NMSettingWiredWakeOnLan = 8;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST: NMSettingWiredWakeOnLan = 16;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_ARP: NMSettingWiredWakeOnLan = 32;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC: NMSettingWiredWakeOnLan = 64;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT: NMSettingWiredWakeOnLan = 1;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE: NMSettingWiredWakeOnLan = 32768;

pub type NMSettingWirelessSecurityWpsMethod = c_uint;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT: NMSettingWirelessSecurityWpsMethod = 0;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED: NMSettingWirelessSecurityWpsMethod = 1;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO: NMSettingWirelessSecurityWpsMethod = 2;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC: NMSettingWirelessSecurityWpsMethod = 4;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN: NMSettingWirelessSecurityWpsMethod = 8;

pub type NMSettingWirelessWakeOnWLan = c_uint;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY: NMSettingWirelessWakeOnWLan = 2;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT: NMSettingWirelessWakeOnWLan = 4;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC: NMSettingWirelessWakeOnWLan = 8;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE: NMSettingWirelessWakeOnWLan = 16;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST: NMSettingWirelessWakeOnWLan = 32;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE: NMSettingWirelessWakeOnWLan = 64;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE: NMSettingWirelessWakeOnWLan = 128;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP: NMSettingWirelessWakeOnWLan = 256;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL: NMSettingWirelessWakeOnWLan = 510;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT: NMSettingWirelessWakeOnWLan = 1;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE: NMSettingWirelessWakeOnWLan = 32768;

pub type NMSettingsAddConnection2Flags = c_uint;
pub const NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE: NMSettingsAddConnection2Flags = 0;
pub const NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK: NMSettingsAddConnection2Flags = 1;
pub const NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY: NMSettingsAddConnection2Flags = 2;
pub const NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT: NMSettingsAddConnection2Flags = 32;

pub type NMSettingsConnectionFlags = c_uint;
pub const NM_SETTINGS_CONNECTION_FLAG_NONE: NMSettingsConnectionFlags = 0;
pub const NM_SETTINGS_CONNECTION_FLAG_UNSAVED: NMSettingsConnectionFlags = 1;
pub const NM_SETTINGS_CONNECTION_FLAG_NM_GENERATED: NMSettingsConnectionFlags = 2;
pub const NM_SETTINGS_CONNECTION_FLAG_VOLATILE: NMSettingsConnectionFlags = 4;
pub const NM_SETTINGS_CONNECTION_FLAG_EXTERNAL: NMSettingsConnectionFlags = 8;

pub type NMSettingsUpdate2Flags = c_uint;
pub const NM_SETTINGS_UPDATE2_FLAG_NONE: NMSettingsUpdate2Flags = 0;
pub const NM_SETTINGS_UPDATE2_FLAG_TO_DISK: NMSettingsUpdate2Flags = 1;
pub const NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY: NMSettingsUpdate2Flags = 2;
pub const NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED: NMSettingsUpdate2Flags = 4;
pub const NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY: NMSettingsUpdate2Flags = 8;
pub const NM_SETTINGS_UPDATE2_FLAG_VOLATILE: NMSettingsUpdate2Flags = 16;
pub const NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT: NMSettingsUpdate2Flags = 32;
pub const NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY: NMSettingsUpdate2Flags = 64;

pub type NMTeamLinkWatcherArpPingFlags = c_uint;
pub const NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_ACTIVE: NMTeamLinkWatcherArpPingFlags = 2;
pub const NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_INACTIVE: NMTeamLinkWatcherArpPingFlags = 4;
pub const NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_SEND_ALWAYS: NMTeamLinkWatcherArpPingFlags = 8;

pub type NMVlanFlags = c_uint;
pub const NM_VLAN_FLAG_REORDER_HEADERS: NMVlanFlags = 1;
pub const NM_VLAN_FLAG_GVRP: NMVlanFlags = 2;
pub const NM_VLAN_FLAG_LOOSE_BINDING: NMVlanFlags = 4;
pub const NM_VLAN_FLAG_MVRP: NMVlanFlags = 8;

pub type NMVpnEditorPluginCapability = c_uint;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE: NMVpnEditorPluginCapability = 0;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT: NMVpnEditorPluginCapability = 1;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT: NMVpnEditorPluginCapability = 2;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6: NMVpnEditorPluginCapability = 4;

// Callbacks
pub type NMKeyfileReadHandler = Option<unsafe extern "C" fn(*mut glib::GKeyFile, *mut NMConnection, NMKeyfileHandlerType, *mut NMKeyfileHandlerData, *mut c_void) -> gboolean>;
pub type NMKeyfileWriteHandler = Option<unsafe extern "C" fn(*mut NMConnection, *mut glib::GKeyFile, NMKeyfileHandlerType, *mut NMKeyfileHandlerData, *mut c_void) -> gboolean>;
pub type NMSecretAgentOldDeleteSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GError, gpointer)>;
pub type NMSecretAgentOldGetSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GVariant, *mut glib::GError, gpointer)>;
pub type NMSecretAgentOldSaveSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GError, gpointer)>;
pub type NMSettingClearSecretsWithFlagsFn = Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, NMSettingSecretFlags, gpointer) -> gboolean>;
pub type NMSettingValueIterFn = Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, *const gobject::GValue, gobject::GParamFlags, gpointer)>;
pub type NMUtilsCheckFilePredicate = Option<unsafe extern "C" fn(*const c_char, *const stat, gpointer, *mut *mut glib::GError) -> gboolean>;
pub type NMUtilsFileSearchInPathsPredicate = Option<unsafe extern "C" fn(*const c_char, gpointer) -> gboolean>;
pub type NMUtilsPredicateStr = Option<unsafe extern "C" fn(*const c_char) -> gboolean>;
pub type NMVpnIterFunc = Option<unsafe extern "C" fn(*const c_char, *const c_char, gpointer)>;

// Records
#[repr(C)]
#[allow(dead_code)]
pub struct _NMAccessPointClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMAccessPointClass = _NMAccessPointClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMActiveConnectionClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMActiveConnectionClass = _NMActiveConnectionClass;

#[repr(C)]
#[allow(dead_code)]
pub struct NMBridgeVlan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMBridgeVlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMBridgeVlan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMCheckpointClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMCheckpointClass = _NMCheckpointClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMClientClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMClientClass = _NMClientClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMConnectionInterface {
    pub parent: gobject::GTypeInterface,
    pub secrets_updated: Option<unsafe extern "C" fn(*mut NMConnection, *const c_char)>,
    pub secrets_cleared: Option<unsafe extern "C" fn(*mut NMConnection)>,
    pub changed: Option<unsafe extern "C" fn(*mut NMConnection)>,
}

impl ::std::fmt::Debug for NMConnectionInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMConnectionInterface @ {self:p}"))
         .field("parent", &self.parent)
         .field("secrets_updated", &self.secrets_updated)
         .field("secrets_cleared", &self.secrets_cleared)
         .field("changed", &self.changed)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDevice6LowpanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDevice6LowpanClass = _NMDevice6LowpanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceAdslClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceAdslClass = _NMDeviceAdslClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceBondClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceBondClass = _NMDeviceBondClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceBridgeClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceBridgeClass = _NMDeviceBridgeClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceBtClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceBtClass = _NMDeviceBtClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceClass = _NMDeviceClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceDummyClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceDummyClass = _NMDeviceDummyClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceEthernetClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceEthernetClass = _NMDeviceEthernetClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceGenericClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceGenericClass = _NMDeviceGenericClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceHsrClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceHsrClass = _NMDeviceHsrClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceIPTunnelClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceIPTunnelClass = _NMDeviceIPTunnelClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceInfinibandClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceInfinibandClass = _NMDeviceInfinibandClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceLoopbackClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceLoopbackClass = _NMDeviceLoopbackClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceMacsecClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceMacsecClass = _NMDeviceMacsecClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceMacvlanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceMacvlanClass = _NMDeviceMacvlanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceModemClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceModemClass = _NMDeviceModemClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceOlpcMeshClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceOlpcMeshClass = _NMDeviceOlpcMeshClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceOvsBridgeClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceOvsBridgeClass = _NMDeviceOvsBridgeClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceOvsInterfaceClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceOvsInterfaceClass = _NMDeviceOvsInterfaceClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceOvsPortClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceOvsPortClass = _NMDeviceOvsPortClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDevicePppClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDevicePppClass = _NMDevicePppClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceTeamClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceTeamClass = _NMDeviceTeamClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceTunClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceTunClass = _NMDeviceTunClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceVethClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceVethClass = _NMDeviceVethClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceVlanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceVlanClass = _NMDeviceVlanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceVrfClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceVrfClass = _NMDeviceVrfClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceVxlanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceVxlanClass = _NMDeviceVxlanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceWifiClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceWifiClass = _NMDeviceWifiClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceWifiP2PClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceWifiP2PClass = _NMDeviceWifiP2PClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceWimaxClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceWimaxClass = _NMDeviceWimaxClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceWireGuardClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceWireGuardClass = _NMDeviceWireGuardClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDeviceWpanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDeviceWpanClass = _NMDeviceWpanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMDhcpConfigClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMDhcpConfigClass = _NMDhcpConfigClass;

#[repr(C)]
#[allow(dead_code)]
pub struct NMDnsEntry {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDnsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDnsEntry @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMIPAddress {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMIPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPAddress @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMIPConfigClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMIPConfigClass = _NMIPConfigClass;

#[repr(C)]
#[allow(dead_code)]
pub struct NMIPRoute {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMIPRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPRoute @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMIPRoutingRule {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMIPRoutingRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPRoutingRule @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMKeyfileHandlerData {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMKeyfileHandlerData = _NMKeyfileHandlerData;

#[repr(C)]
#[allow(dead_code)]
pub struct NMLldpNeighbor {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMLldpNeighbor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMLldpNeighbor @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMObjectClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMObjectClass = _NMObjectClass;

#[repr(C)]
#[allow(dead_code)]
pub struct NMRange {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMRange @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMRemoteConnectionClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMRemoteConnectionClass = _NMRemoteConnectionClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMSecretAgentOldClass {
    pub parent: gobject::GObjectClass,
    pub get_secrets: Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *const c_char, *const c_char, *mut *const c_char, NMSecretAgentGetSecretsFlags, NMSecretAgentOldGetSecretsFunc, gpointer)>,
    pub cancel_get_secrets: Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *const c_char, *const c_char)>,
    pub save_secrets: Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *const c_char, NMSecretAgentOldSaveSecretsFunc, gpointer)>,
    pub delete_secrets: Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *const c_char, NMSecretAgentOldDeleteSecretsFunc, gpointer)>,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMSecretAgentOldClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSecretAgentOldClass @ {self:p}"))
         .field("parent", &self.parent)
         .field("get_secrets", &self.get_secrets)
         .field("cancel_get_secrets", &self.cancel_get_secrets)
         .field("save_secrets", &self.save_secrets)
         .field("delete_secrets", &self.delete_secrets)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSetting6LowpanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSetting6LowpanClass = _NMSetting6LowpanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSetting8021xClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSetting8021xClass = _NMSetting8021xClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingAdslClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingAdslClass = _NMSettingAdslClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingBluetoothClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingBluetoothClass = _NMSettingBluetoothClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingBondClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingBondClass = _NMSettingBondClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingBondPortClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingBondPortClass = _NMSettingBondPortClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingBridgeClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingBridgeClass = _NMSettingBridgeClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingBridgePortClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingBridgePortClass = _NMSettingBridgePortClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingCdmaClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingCdmaClass = _NMSettingCdmaClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingClass = _NMSettingClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingConnectionClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingConnectionClass = _NMSettingConnectionClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingDcbClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingDcbClass = _NMSettingDcbClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingDummyClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingDummyClass = _NMSettingDummyClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingEthtoolClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingEthtoolClass = _NMSettingEthtoolClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingGenericClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingGenericClass = _NMSettingGenericClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingGsmClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingGsmClass = _NMSettingGsmClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingHostnameClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingHostnameClass = _NMSettingHostnameClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingHsrClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingHsrClass = _NMSettingHsrClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingIP4ConfigClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingIP4ConfigClass = _NMSettingIP4ConfigClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingIP6ConfigClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingIP6ConfigClass = _NMSettingIP6ConfigClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingIPConfigClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingIPConfigClass = _NMSettingIPConfigClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingIPTunnelClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingIPTunnelClass = _NMSettingIPTunnelClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingInfinibandClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingInfinibandClass = _NMSettingInfinibandClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingLinkClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingLinkClass = _NMSettingLinkClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingLoopbackClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingLoopbackClass = _NMSettingLoopbackClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingMacsecClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingMacsecClass = _NMSettingMacsecClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingMacvlanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingMacvlanClass = _NMSettingMacvlanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingMatchClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingMatchClass = _NMSettingMatchClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingOlpcMeshClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingOlpcMeshClass = _NMSettingOlpcMeshClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingOvsBridgeClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingOvsBridgeClass = _NMSettingOvsBridgeClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingOvsDpdkClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingOvsDpdkClass = _NMSettingOvsDpdkClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingOvsExternalIDsClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingOvsExternalIDsClass = _NMSettingOvsExternalIDsClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingOvsInterfaceClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingOvsInterfaceClass = _NMSettingOvsInterfaceClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingOvsOtherConfigClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingOvsOtherConfigClass = _NMSettingOvsOtherConfigClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingOvsPatchClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingOvsPatchClass = _NMSettingOvsPatchClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingOvsPortClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingOvsPortClass = _NMSettingOvsPortClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingPppClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingPppClass = _NMSettingPppClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingPppoeClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingPppoeClass = _NMSettingPppoeClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingProxyClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingProxyClass = _NMSettingProxyClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingSerialClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingSerialClass = _NMSettingSerialClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingSriovClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingSriovClass = _NMSettingSriovClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingTCConfigClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingTCConfigClass = _NMSettingTCConfigClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingTeamClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingTeamClass = _NMSettingTeamClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingTeamPortClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingTeamPortClass = _NMSettingTeamPortClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingTunClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingTunClass = _NMSettingTunClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingUserClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingUserClass = _NMSettingUserClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingVethClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingVethClass = _NMSettingVethClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingVlanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingVlanClass = _NMSettingVlanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingVpnClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingVpnClass = _NMSettingVpnClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingVrfClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingVrfClass = _NMSettingVrfClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingVxlanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingVxlanClass = _NMSettingVxlanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingWifiP2PClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingWifiP2PClass = _NMSettingWifiP2PClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingWimaxClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingWimaxClass = _NMSettingWimaxClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingWireGuardClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingWireGuardClass = _NMSettingWireGuardClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingWiredClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingWiredClass = _NMSettingWiredClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingWirelessClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingWirelessClass = _NMSettingWirelessClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingWirelessSecurityClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingWirelessSecurityClass = _NMSettingWirelessSecurityClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSettingWpanClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSettingWpanClass = _NMSettingWpanClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMSimpleConnectionClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMSimpleConnectionClass = _NMSimpleConnectionClass;

#[repr(C)]
#[allow(dead_code)]
pub struct NMSriovVF {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSriovVF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSriovVF @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMTCAction {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMTCAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMTCAction @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMTCQdisc {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMTCQdisc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMTCQdisc @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMTCTfilter {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMTCTfilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMTCTfilter @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMTeamLinkWatcher {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMTeamLinkWatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMTeamLinkWatcher @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMVariantAttributeSpec {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMVariantAttributeSpec = _NMVariantAttributeSpec;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMVpnConnectionClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMVpnConnectionClass = _NMVpnConnectionClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMVpnEditorInterface {
    pub g_iface: gobject::GTypeInterface,
    pub get_widget: Option<unsafe extern "C" fn(*mut NMVpnEditor) -> *mut gobject::GObject>,
    pub placeholder: Option<unsafe extern "C" fn()>,
    pub update_connection: Option<unsafe extern "C" fn(*mut NMVpnEditor, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub changed: Option<unsafe extern "C" fn(*mut NMVpnEditor)>,
}

impl ::std::fmt::Debug for NMVpnEditorInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnEditorInterface @ {self:p}"))
         .field("g_iface", &self.g_iface)
         .field("get_widget", &self.get_widget)
         .field("placeholder", &self.placeholder)
         .field("update_connection", &self.update_connection)
         .field("changed", &self.changed)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMVpnEditorPluginInterface {
    pub g_iface: gobject::GTypeInterface,
    pub get_editor: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *mut NMConnection, *mut *mut glib::GError) -> *mut NMVpnEditor>,
    pub get_capabilities: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin) -> NMVpnEditorPluginCapability>,
    pub import_from_file: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *const c_char, *mut *mut glib::GError) -> *mut NMConnection>,
    pub export_to_file: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *const c_char, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub get_suggested_filename: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *mut NMConnection) -> *mut c_char>,
    pub notify_plugin_info_set: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *mut NMVpnPluginInfo)>,
    pub get_vt: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *mut size_t) -> *const NMVpnEditorPluginVT>,
}

impl ::std::fmt::Debug for NMVpnEditorPluginInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnEditorPluginInterface @ {self:p}"))
         .field("g_iface", &self.g_iface)
         .field("get_editor", &self.get_editor)
         .field("get_capabilities", &self.get_capabilities)
         .field("import_from_file", &self.import_from_file)
         .field("export_to_file", &self.export_to_file)
         .field("get_suggested_filename", &self.get_suggested_filename)
         .field("notify_plugin_info_set", &self.notify_plugin_info_set)
         .field("get_vt", &self.get_vt)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMVpnEditorPluginVT {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMVpnEditorPluginVT = _NMVpnEditorPluginVT;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMVpnPluginInfoClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMVpnPluginInfoClass = _NMVpnPluginInfoClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMVpnPluginOldClass {
    pub parent: gobject::GObjectClass,
    pub state_changed: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, NMVpnServiceState)>,
    pub ip4_config: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut glib::GVariant)>,
    pub login_banner: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *const c_char)>,
    pub failure: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, NMVpnPluginFailure)>,
    pub quit: Option<unsafe extern "C" fn(*mut NMVpnPluginOld)>,
    pub config: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut glib::GVariant)>,
    pub ip6_config: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut glib::GVariant)>,
    pub connect: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub need_secrets: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut NMConnection, *mut *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub disconnect: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut *mut glib::GError) -> gboolean>,
    pub new_secrets: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub connect_interactive: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut NMConnection, *mut glib::GVariant, *mut *mut glib::GError) -> gboolean>,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMVpnPluginOldClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginOldClass @ {self:p}"))
         .field("parent", &self.parent)
         .field("state_changed", &self.state_changed)
         .field("ip4_config", &self.ip4_config)
         .field("login_banner", &self.login_banner)
         .field("failure", &self.failure)
         .field("quit", &self.quit)
         .field("config", &self.config)
         .field("ip6_config", &self.ip6_config)
         .field("connect", &self.connect)
         .field("need_secrets", &self.need_secrets)
         .field("disconnect", &self.disconnect)
         .field("new_secrets", &self.new_secrets)
         .field("connect_interactive", &self.connect_interactive)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMVpnServicePluginClass {
    pub parent: gobject::GObjectClass,
    pub state_changed: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, NMVpnServiceState)>,
    pub ip4_config: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut glib::GVariant)>,
    pub login_banner: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *const c_char)>,
    pub failure: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, NMVpnPluginFailure)>,
    pub quit: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin)>,
    pub config: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut glib::GVariant)>,
    pub ip6_config: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut glib::GVariant)>,
    pub connect: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub need_secrets: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut NMConnection, *mut *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub disconnect: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut *mut glib::GError) -> gboolean>,
    pub new_secrets: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub connect_interactive: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut NMConnection, *mut glib::GVariant, *mut *mut glib::GError) -> gboolean>,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMVpnServicePluginClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnServicePluginClass @ {self:p}"))
         .field("parent", &self.parent)
         .field("state_changed", &self.state_changed)
         .field("ip4_config", &self.ip4_config)
         .field("login_banner", &self.login_banner)
         .field("failure", &self.failure)
         .field("quit", &self.quit)
         .field("config", &self.config)
         .field("ip6_config", &self.ip6_config)
         .field("connect", &self.connect)
         .field("need_secrets", &self.need_secrets)
         .field("disconnect", &self.disconnect)
         .field("new_secrets", &self.new_secrets)
         .field("connect_interactive", &self.connect_interactive)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _NMWifiP2PPeerClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMWifiP2PPeerClass = _NMWifiP2PPeerClass;

#[repr(C)]
#[allow(dead_code)]
pub struct _NMWimaxNspClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type NMWimaxNspClass = _NMWimaxNspClass;

#[repr(C)]
#[allow(dead_code)]
pub struct NMWireGuardPeer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMWireGuardPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMWireGuardPeer @ {self:p}"))
         .finish()
    }
}

// Classes
#[repr(C)]
#[allow(dead_code)]
pub struct NMAccessPoint {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMAccessPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMAccessPoint @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMActiveConnection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMActiveConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMActiveConnection @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMCheckpoint {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMCheckpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMCheckpoint @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMClient {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMClient @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDevice {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDevice @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDevice6Lowpan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDevice6Lowpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDevice6Lowpan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceAdsl {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceAdsl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceAdsl @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceBond {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceBond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBond @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceBridge {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBridge @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceBt {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceBt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBt @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceDummy {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceDummy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceDummy @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceEthernet {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceEthernet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceEthernet @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceGeneric {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceGeneric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceGeneric @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceHsr {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceHsr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceHsr @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceIPTunnel {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceIPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceIPTunnel @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceInfiniband {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceInfiniband {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceInfiniband @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceLoopback {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceLoopback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceLoopback @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceMacsec {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceMacsec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceMacsec @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceMacvlan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceMacvlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceMacvlan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceModem {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceModem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceModem @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceOlpcMesh {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceOlpcMesh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOlpcMesh @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceOvsBridge {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceOvsBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOvsBridge @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceOvsInterface {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceOvsInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOvsInterface @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceOvsPort {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceOvsPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOvsPort @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDevicePpp {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDevicePpp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDevicePpp @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceTeam {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceTeam @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceTun {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceTun {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceTun @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceVeth {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceVeth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVeth @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceVlan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceVlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVlan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceVrf {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceVrf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVrf @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceVxlan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceVxlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVxlan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceWifi {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceWifi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWifi @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceWifiP2P {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceWifiP2P {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWifiP2P @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceWimax {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceWimax {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWimax @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceWireGuard {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceWireGuard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWireGuard @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDeviceWpan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDeviceWpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWpan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMDhcpConfig {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMDhcpConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDhcpConfig @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMIPConfig {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMIPConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPConfig @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMObject {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMObject @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMRemoteConnection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMRemoteConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMRemoteConnection @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMSecretAgentOld {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMSecretAgentOld {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSecretAgentOld @ {self:p}"))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSetting {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSetting6Lowpan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSetting6Lowpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting6Lowpan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSetting8021x {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSetting8021x {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting8021x @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingAdsl {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingAdsl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingAdsl @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingBluetooth {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingBluetooth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBluetooth @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingBond {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingBond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBond @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingBondPort {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingBondPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBondPort @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingBridge {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridge @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingBridgePort {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingBridgePort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridgePort @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingCdma {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingCdma {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingCdma @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingConnection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingConnection @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingDcb {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingDcb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDcb @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingDummy {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingDummy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDummy @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingEthtool {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingEthtool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingEthtool @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingGeneric {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingGeneric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGeneric @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingGsm {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingGsm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGsm @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingHostname {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingHostname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingHostname @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingHsr {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingHsr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingHsr @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingIP4Config {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingIP4Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP4Config @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingIP6Config {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingIP6Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP6Config @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingIPConfig {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingIPConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPConfig @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingIPTunnel {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingIPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPTunnel @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingInfiniband {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingInfiniband {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingInfiniband @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingLink {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingLink @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingLoopback {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingLoopback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingLoopback @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingMacsec {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingMacsec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacsec @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingMacvlan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingMacvlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacvlan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingMatch {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMatch @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingOlpcMesh {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingOlpcMesh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOlpcMesh @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingOvsBridge {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingOvsBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsBridge @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingOvsDpdk {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingOvsDpdk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsDpdk @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingOvsExternalIDs {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingOvsExternalIDs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsExternalIDs @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingOvsInterface {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingOvsInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsInterface @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingOvsOtherConfig {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingOvsOtherConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsOtherConfig @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingOvsPatch {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingOvsPatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsPatch @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingOvsPort {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingOvsPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsPort @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingPpp {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingPpp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPpp @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingPppoe {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingPppoe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPppoe @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingProxy {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingProxy @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingSerial {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingSerial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingSerial @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingSriov {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingSriov {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingSriov @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingTCConfig {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingTCConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTCConfig @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingTeam {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeam @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingTeamPort {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingTeamPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeamPort @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingTun {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingTun {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTun @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingUser {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingUser @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingVeth {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingVeth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVeth @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingVlan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingVlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVlan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingVpn {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingVpn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVpn @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingVrf {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingVrf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVrf @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingVxlan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingVxlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVxlan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingWifiP2P {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingWifiP2P {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWifiP2P @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingWimax {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingWimax {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWimax @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingWireGuard {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingWireGuard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWireGuard @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingWired {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingWired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWired @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingWireless {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingWireless {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWireless @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingWirelessSecurity {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingWirelessSecurity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWirelessSecurity @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSettingWpan {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSettingWpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWpan @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMSimpleConnection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMSimpleConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSimpleConnection @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMVpnConnection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMVpnConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnConnection @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMVpnPluginInfo {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMVpnPluginInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginInfo @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMVpnPluginOld {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMVpnPluginOld {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginOld @ {self:p}"))
         .field("parent", &self.parent)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct NMVpnServicePlugin {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMVpnServicePlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnServicePlugin @ {self:p}"))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMWifiP2PPeer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMWifiP2PPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMWifiP2PPeer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMWimaxNsp {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMWimaxNsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMWimaxNsp @ {self:p}"))
         .finish()
    }
}

// Interfaces
#[repr(C)]
#[allow(dead_code)]
pub struct NMConnection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMConnection @ {self:p}")
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMVpnEditor {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMVpnEditor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMVpnEditor @ {self:p}")
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct NMVpnEditorPlugin {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for NMVpnEditorPlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMVpnEditorPlugin @ {self:p}")
    }
}


extern "C" {

    //=========================================================================
    // NM80211Mode
    //=========================================================================
    pub fn nm_802_11_mode_get_type() -> GType;

    //=========================================================================
    // NMActiveConnectionState
    //=========================================================================
    pub fn nm_active_connection_state_get_type() -> GType;

    //=========================================================================
    // NMActiveConnectionStateReason
    //=========================================================================
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_active_connection_state_reason_get_type() -> GType;

    //=========================================================================
    // NMAgentManagerError
    //=========================================================================
    pub fn nm_agent_manager_error_get_type() -> GType;
    pub fn nm_agent_manager_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMCapability
    //=========================================================================
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_capability_get_type() -> GType;

    //=========================================================================
    // NMClientError
    //=========================================================================
    pub fn nm_client_error_get_type() -> GType;
    pub fn nm_client_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMClientPermission
    //=========================================================================
    pub fn nm_client_permission_get_type() -> GType;

    //=========================================================================
    // NMClientPermissionResult
    //=========================================================================
    pub fn nm_client_permission_result_get_type() -> GType;

    //=========================================================================
    // NMConnectionError
    //=========================================================================
    pub fn nm_connection_error_get_type() -> GType;
    pub fn nm_connection_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMConnectionMultiConnect
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_connection_multi_connect_get_type() -> GType;

    //=========================================================================
    // NMConnectivityState
    //=========================================================================
    pub fn nm_connectivity_state_get_type() -> GType;

    //=========================================================================
    // NMCryptoError
    //=========================================================================
    pub fn nm_crypto_error_get_type() -> GType;
    pub fn nm_crypto_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMDeviceError
    //=========================================================================
    pub fn nm_device_error_get_type() -> GType;
    pub fn nm_device_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMDeviceState
    //=========================================================================
    pub fn nm_device_state_get_type() -> GType;

    //=========================================================================
    // NMDeviceStateReason
    //=========================================================================
    pub fn nm_device_state_reason_get_type() -> GType;

    //=========================================================================
    // NMDeviceType
    //=========================================================================
    pub fn nm_device_type_get_type() -> GType;

    //=========================================================================
    // NMIPTunnelMode
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_ip_tunnel_mode_get_type() -> GType;

    //=========================================================================
    // NMKeyfileHandlerType
    //=========================================================================
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_keyfile_handler_type_get_type() -> GType;

    //=========================================================================
    // NMKeyfileWarnSeverity
    //=========================================================================
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_keyfile_warn_severity_get_type() -> GType;

    //=========================================================================
    // NMManagerError
    //=========================================================================
    pub fn nm_manager_error_get_type() -> GType;
    pub fn nm_manager_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMMetered
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_metered_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentError
    //=========================================================================
    pub fn nm_secret_agent_error_get_type() -> GType;
    pub fn nm_secret_agent_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMSetting8021xCKFormat
    //=========================================================================
    pub fn nm_setting_802_1x_ck_format_get_type() -> GType;

    //=========================================================================
    // NMSetting8021xCKScheme
    //=========================================================================
    pub fn nm_setting_802_1x_ck_scheme_get_type() -> GType;

    //=========================================================================
    // NMSettingCompareFlags
    //=========================================================================
    pub fn nm_setting_compare_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionAutoconnectSlaves
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_connection_autoconnect_slaves_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionDnsOverTls
    //=========================================================================
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn nm_setting_connection_dns_over_tls_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionDownOnPoweroff
    //=========================================================================
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_connection_down_on_poweroff_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionLldp
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_connection_lldp_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionLlmnr
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_connection_llmnr_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionMdns
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_connection_mdns_get_type() -> GType;

    //=========================================================================
    // NMSettingDiffResult
    //=========================================================================
    pub fn nm_setting_diff_result_get_type() -> GType;

    //=========================================================================
    // NMSettingIP4LinkLocal
    //=========================================================================
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    pub fn nm_setting_ip4_link_local_get_type() -> GType;

    //=========================================================================
    // NMSettingIP6ConfigAddrGenMode
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip6_config_addr_gen_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingIP6ConfigPrivacy
    //=========================================================================
    pub fn nm_setting_ip6_config_privacy_get_type() -> GType;

    //=========================================================================
    // NMSettingMacRandomization
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_mac_randomization_get_type() -> GType;

    //=========================================================================
    // NMSettingMacsecMode
    //=========================================================================
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingMacsecOffload
    //=========================================================================
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_macsec_offload_get_type() -> GType;

    //=========================================================================
    // NMSettingMacsecValidation
    //=========================================================================
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_validation_get_type() -> GType;

    //=========================================================================
    // NMSettingMacvlanMode
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_macvlan_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingProxyMethod
    //=========================================================================
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_proxy_method_get_type() -> GType;

    //=========================================================================
    // NMSettingSerialParity
    //=========================================================================
    pub fn nm_setting_serial_parity_get_type() -> GType;

    //=========================================================================
    // NMSettingTunMode
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_tun_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessChannelWidth
    //=========================================================================
    #[cfg(feature = "v1_50")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
    pub fn nm_setting_wireless_channel_width_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessPowersave
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_wireless_powersave_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessSecurityFils
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_wireless_security_fils_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessSecurityPmf
    //=========================================================================
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_wireless_security_pmf_get_type() -> GType;

    //=========================================================================
    // NMSettingsError
    //=========================================================================
    pub fn nm_settings_error_get_type() -> GType;
    pub fn nm_settings_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMSriovEswitchEncapMode
    //=========================================================================
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_sriov_eswitch_encap_mode_get_type() -> GType;

    //=========================================================================
    // NMSriovEswitchInlineMode
    //=========================================================================
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_sriov_eswitch_inline_mode_get_type() -> GType;

    //=========================================================================
    // NMSriovEswitchMode
    //=========================================================================
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_sriov_eswitch_mode_get_type() -> GType;

    //=========================================================================
    // NMSriovVFVlanProtocol
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_vlan_protocol_get_type() -> GType;

    //=========================================================================
    // NMState
    //=========================================================================
    pub fn nm_state_get_type() -> GType;

    //=========================================================================
    // NMTernary
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_ternary_get_type() -> GType;

    //=========================================================================
    // NMUtilsSecurityType
    //=========================================================================
    pub fn nm_utils_security_type_get_type() -> GType;

    //=========================================================================
    // NMVersionInfoCapability
    //=========================================================================
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_version_info_capability_get_type() -> GType;

    //=========================================================================
    // NMVlanPriorityMap
    //=========================================================================
    pub fn nm_vlan_priority_map_get_type() -> GType;

    //=========================================================================
    // NMVpnConnectionState
    //=========================================================================
    pub fn nm_vpn_connection_state_get_type() -> GType;

    //=========================================================================
    // NMVpnConnectionStateReason
    //=========================================================================
    pub fn nm_vpn_connection_state_reason_get_type() -> GType;

    //=========================================================================
    // NMVpnPluginError
    //=========================================================================
    pub fn nm_vpn_plugin_error_get_type() -> GType;
    pub fn nm_vpn_plugin_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMVpnPluginFailure
    //=========================================================================
    pub fn nm_vpn_plugin_failure_get_type() -> GType;

    //=========================================================================
    // NMVpnServiceState
    //=========================================================================
    pub fn nm_vpn_service_state_get_type() -> GType;

    //=========================================================================
    // NMWepKeyType
    //=========================================================================
    pub fn nm_wep_key_type_get_type() -> GType;

    //=========================================================================
    // NMWimaxNspNetworkType
    //=========================================================================
    pub fn nm_wimax_nsp_network_type_get_type() -> GType;

    //=========================================================================
    // NM80211ApFlags
    //=========================================================================
    pub fn nm_802_11_ap_flags_get_type() -> GType;

    //=========================================================================
    // NM80211ApSecurityFlags
    //=========================================================================
    pub fn nm_802_11_ap_security_flags_get_type() -> GType;

    //=========================================================================
    // NMActivationStateFlags
    //=========================================================================
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_activation_state_flags_get_type() -> GType;

    //=========================================================================
    // NMBluetoothCapabilities
    //=========================================================================
    pub fn nm_bluetooth_capabilities_get_type() -> GType;

    //=========================================================================
    // NMCheckpointCreateFlags
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_checkpoint_create_flags_get_type() -> GType;

    //=========================================================================
    // NMClientInstanceFlags
    //=========================================================================
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_instance_flags_get_type() -> GType;

    //=========================================================================
    // NMConnectionSerializationFlags
    //=========================================================================
    pub fn nm_connection_serialization_flags_get_type() -> GType;

    //=========================================================================
    // NMDeviceCapabilities
    //=========================================================================
    pub fn nm_device_capabilities_get_type() -> GType;

    //=========================================================================
    // NMDeviceInterfaceFlags
    //=========================================================================
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_device_interface_flags_get_type() -> GType;

    //=========================================================================
    // NMDeviceModemCapabilities
    //=========================================================================
    pub fn nm_device_modem_capabilities_get_type() -> GType;

    //=========================================================================
    // NMDeviceReapplyFlags
    //=========================================================================
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_device_reapply_flags_get_type() -> GType;

    //=========================================================================
    // NMDeviceWifiCapabilities
    //=========================================================================
    pub fn nm_device_wifi_capabilities_get_type() -> GType;

    //=========================================================================
    // NMDhcpHostnameFlags
    //=========================================================================
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_dhcp_hostname_flags_get_type() -> GType;

    //=========================================================================
    // NMIPAddressCmpFlags
    //=========================================================================
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_ip_address_cmp_flags_get_type() -> GType;

    //=========================================================================
    // NMIPRoutingRuleAsStringFlags
    //=========================================================================
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_as_string_flags_get_type() -> GType;

    //=========================================================================
    // NMIPTunnelFlags
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_ip_tunnel_flags_get_type() -> GType;

    //=========================================================================
    // NMKeyfileHandlerFlags
    //=========================================================================
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_keyfile_handler_flags_get_type() -> GType;

    //=========================================================================
    // NMManagerReloadFlags
    //=========================================================================
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_manager_reload_flags_get_type() -> GType;

    //=========================================================================
    // NMMptcpFlags
    //=========================================================================
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    pub fn nm_mptcp_flags_get_type() -> GType;

    //=========================================================================
    // NMRadioFlags
    //=========================================================================
    #[cfg(feature = "v1_38")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
    pub fn nm_radio_flags_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentCapabilities
    //=========================================================================
    pub fn nm_secret_agent_capabilities_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentGetSecretsFlags
    //=========================================================================
    pub fn nm_secret_agent_get_secrets_flags_get_type() -> GType;

    //=========================================================================
    // NMSetting8021xAuthFlags
    //=========================================================================
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_auth_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingDcbFlags
    //=========================================================================
    pub fn nm_setting_dcb_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingSecretFlags
    //=========================================================================
    pub fn nm_setting_secret_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingWiredWakeOnLan
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_wired_wake_on_lan_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessSecurityWpsMethod
    //=========================================================================
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_wireless_security_wps_method_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessWakeOnWLan
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_wireless_wake_on_wlan_get_type() -> GType;

    //=========================================================================
    // NMSettingsAddConnection2Flags
    //=========================================================================
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_settings_add_connection2_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingsConnectionFlags
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_settings_connection_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingsUpdate2Flags
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_settings_update2_flags_get_type() -> GType;

    //=========================================================================
    // NMTeamLinkWatcherArpPingFlags
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_arp_ping_flags_get_type() -> GType;

    //=========================================================================
    // NMVlanFlags
    //=========================================================================
    pub fn nm_vlan_flags_get_type() -> GType;

    //=========================================================================
    // NMVpnEditorPluginCapability
    //=========================================================================
    pub fn nm_vpn_editor_plugin_capability_get_type() -> GType;

    //=========================================================================
    // NMBridgeVlan
    //=========================================================================
    pub fn nm_bridge_vlan_get_type() -> GType;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_new(vid_start: u16, vid_end: u16) -> *mut NMBridgeVlan;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_cmp(a: *const NMBridgeVlan, b: *const NMBridgeVlan) -> c_int;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_get_vid_range(vlan: *const NMBridgeVlan, vid_start: *mut u16, vid_end: *mut u16) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_is_pvid(vlan: *const NMBridgeVlan) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_is_sealed(vlan: *const NMBridgeVlan) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_is_untagged(vlan: *const NMBridgeVlan) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_new_clone(vlan: *const NMBridgeVlan) -> *mut NMBridgeVlan;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_ref(vlan: *mut NMBridgeVlan) -> *mut NMBridgeVlan;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_seal(vlan: *mut NMBridgeVlan);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_set_pvid(vlan: *mut NMBridgeVlan, value: gboolean);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_set_untagged(vlan: *mut NMBridgeVlan, value: gboolean);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_to_str(vlan: *const NMBridgeVlan, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_unref(vlan: *mut NMBridgeVlan);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_bridge_vlan_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMBridgeVlan;

    //=========================================================================
    // NMDnsEntry
    //=========================================================================
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_dns_entry_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_dns_entry_get_domains(entry: *mut NMDnsEntry) -> *const *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_dns_entry_get_interface(entry: *mut NMDnsEntry) -> *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_dns_entry_get_nameservers(entry: *mut NMDnsEntry) -> *const *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_dns_entry_get_priority(entry: *mut NMDnsEntry) -> c_int;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_dns_entry_get_vpn(entry: *mut NMDnsEntry) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_dns_entry_unref(entry: *mut NMDnsEntry);

    //=========================================================================
    // NMIPAddress
    //=========================================================================
    pub fn nm_ip_address_get_type() -> GType;
    pub fn nm_ip_address_new(family: c_int, addr: *const c_char, prefix: c_uint, error: *mut *mut glib::GError) -> *mut NMIPAddress;
    pub fn nm_ip_address_new_binary(family: c_int, addr: gconstpointer, prefix: c_uint, error: *mut *mut glib::GError) -> *mut NMIPAddress;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_ip_address_cmp_full(a: *const NMIPAddress, b: *const NMIPAddress, cmp_flags: NMIPAddressCmpFlags) -> c_int;
    #[cfg(feature = "v1_32")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_32")))]
    pub fn nm_ip_address_dup(address: *mut NMIPAddress) -> *mut NMIPAddress;
    pub fn nm_ip_address_equal(address: *mut NMIPAddress, other: *mut NMIPAddress) -> gboolean;
    pub fn nm_ip_address_get_address(address: *mut NMIPAddress) -> *const c_char;
    pub fn nm_ip_address_get_address_binary(address: *mut NMIPAddress, addr: gpointer);
    pub fn nm_ip_address_get_attribute(address: *mut NMIPAddress, name: *const c_char) -> *mut glib::GVariant;
    pub fn nm_ip_address_get_attribute_names(address: *mut NMIPAddress) -> *mut *mut c_char;
    pub fn nm_ip_address_get_family(address: *mut NMIPAddress) -> c_int;
    pub fn nm_ip_address_get_prefix(address: *mut NMIPAddress) -> c_uint;
    pub fn nm_ip_address_ref(address: *mut NMIPAddress);
    pub fn nm_ip_address_set_address(address: *mut NMIPAddress, addr: *const c_char);
    pub fn nm_ip_address_set_address_binary(address: *mut NMIPAddress, addr: gconstpointer);
    pub fn nm_ip_address_set_attribute(address: *mut NMIPAddress, name: *const c_char, value: *mut glib::GVariant);
    pub fn nm_ip_address_set_prefix(address: *mut NMIPAddress, prefix: c_uint);
    pub fn nm_ip_address_unref(address: *mut NMIPAddress);

    //=========================================================================
    // NMIPRoute
    //=========================================================================
    pub fn nm_ip_route_get_type() -> GType;
    pub fn nm_ip_route_new(family: c_int, dest: *const c_char, prefix: c_uint, next_hop: *const c_char, metric: i64, error: *mut *mut glib::GError) -> *mut NMIPRoute;
    pub fn nm_ip_route_new_binary(family: c_int, dest: gconstpointer, prefix: c_uint, next_hop: gconstpointer, metric: i64, error: *mut *mut glib::GError) -> *mut NMIPRoute;
    #[cfg(feature = "v1_32")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_32")))]
    pub fn nm_ip_route_dup(route: *mut NMIPRoute) -> *mut NMIPRoute;
    pub fn nm_ip_route_equal(route: *mut NMIPRoute, other: *mut NMIPRoute) -> gboolean;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_ip_route_equal_full(route: *mut NMIPRoute, other: *mut NMIPRoute, cmp_flags: c_uint) -> gboolean;
    pub fn nm_ip_route_get_attribute(route: *mut NMIPRoute, name: *const c_char) -> *mut glib::GVariant;
    pub fn nm_ip_route_get_attribute_names(route: *mut NMIPRoute) -> *mut *mut c_char;
    pub fn nm_ip_route_get_dest(route: *mut NMIPRoute) -> *const c_char;
    pub fn nm_ip_route_get_dest_binary(route: *mut NMIPRoute, dest: gpointer);
    pub fn nm_ip_route_get_family(route: *mut NMIPRoute) -> c_int;
    pub fn nm_ip_route_get_metric(route: *mut NMIPRoute) -> i64;
    pub fn nm_ip_route_get_next_hop(route: *mut NMIPRoute) -> *const c_char;
    pub fn nm_ip_route_get_next_hop_binary(route: *mut NMIPRoute, next_hop: gpointer) -> gboolean;
    pub fn nm_ip_route_get_prefix(route: *mut NMIPRoute) -> c_uint;
    pub fn nm_ip_route_ref(route: *mut NMIPRoute);
    pub fn nm_ip_route_set_attribute(route: *mut NMIPRoute, name: *const c_char, value: *mut glib::GVariant);
    pub fn nm_ip_route_set_dest(route: *mut NMIPRoute, dest: *const c_char);
    pub fn nm_ip_route_set_dest_binary(route: *mut NMIPRoute, dest: gconstpointer);
    pub fn nm_ip_route_set_metric(route: *mut NMIPRoute, metric: i64);
    pub fn nm_ip_route_set_next_hop(route: *mut NMIPRoute, next_hop: *const c_char);
    pub fn nm_ip_route_set_next_hop_binary(route: *mut NMIPRoute, next_hop: gconstpointer);
    pub fn nm_ip_route_set_prefix(route: *mut NMIPRoute, prefix: c_uint);
    pub fn nm_ip_route_unref(route: *mut NMIPRoute);
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_ip_route_attribute_validate(name: *const c_char, value: *mut glib::GVariant, family: c_int, known: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_ip_route_get_variant_attribute_spec() -> *const *const NMVariantAttributeSpec;

    //=========================================================================
    // NMIPRoutingRule
    //=========================================================================
    pub fn nm_ip_routing_rule_get_type() -> GType;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_new(addr_family: c_int) -> *mut NMIPRoutingRule;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_cmp(rule: *const NMIPRoutingRule, other: *const NMIPRoutingRule) -> c_int;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_action(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_addr_family(self_: *const NMIPRoutingRule) -> c_int;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_destination_port_end(self_: *const NMIPRoutingRule) -> u16;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_destination_port_start(self_: *const NMIPRoutingRule) -> u16;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_from(self_: *const NMIPRoutingRule) -> *const c_char;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_from_len(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_fwmark(self_: *const NMIPRoutingRule) -> u32;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_fwmask(self_: *const NMIPRoutingRule) -> u32;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_iifname(self_: *const NMIPRoutingRule) -> *const c_char;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_invert(self_: *const NMIPRoutingRule) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_ipproto(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_oifname(self_: *const NMIPRoutingRule) -> *const c_char;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_priority(self_: *const NMIPRoutingRule) -> i64;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_source_port_end(self_: *const NMIPRoutingRule) -> u16;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_source_port_start(self_: *const NMIPRoutingRule) -> u16;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_ip_routing_rule_get_suppress_prefixlength(self_: *const NMIPRoutingRule) -> i32;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_table(self_: *const NMIPRoutingRule) -> u32;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_to(self_: *const NMIPRoutingRule) -> *const c_char;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_to_len(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_get_tos(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn nm_ip_routing_rule_get_uid_range(self_: *const NMIPRoutingRule, out_range_start: *mut u32, out_range_end: *mut u32) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_is_sealed(self_: *const NMIPRoutingRule) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_new_clone(rule: *const NMIPRoutingRule) -> *mut NMIPRoutingRule;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_ref(self_: *mut NMIPRoutingRule) -> *mut NMIPRoutingRule;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_seal(self_: *mut NMIPRoutingRule);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_action(self_: *mut NMIPRoutingRule, action: u8);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_destination_port(self_: *mut NMIPRoutingRule, start: u16, end: u16);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_from(self_: *mut NMIPRoutingRule, from: *const c_char, len: u8);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_fwmark(self_: *mut NMIPRoutingRule, fwmark: u32, fwmask: u32);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_iifname(self_: *mut NMIPRoutingRule, iifname: *const c_char);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_invert(self_: *mut NMIPRoutingRule, invert: gboolean);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_ipproto(self_: *mut NMIPRoutingRule, ipproto: u8);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_oifname(self_: *mut NMIPRoutingRule, oifname: *const c_char);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_priority(self_: *mut NMIPRoutingRule, priority: i64);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_source_port(self_: *mut NMIPRoutingRule, start: u16, end: u16);
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_ip_routing_rule_set_suppress_prefixlength(self_: *mut NMIPRoutingRule, suppress_prefixlength: i32);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_table(self_: *mut NMIPRoutingRule, table: u32);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_to(self_: *mut NMIPRoutingRule, to: *const c_char, len: u8);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_set_tos(self_: *mut NMIPRoutingRule, tos: u8);
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn nm_ip_routing_rule_set_uid_range(self_: *mut NMIPRoutingRule, uid_range_start: u32, uid_range_end: u32);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_to_string(self_: *const NMIPRoutingRule, to_string_flags: NMIPRoutingRuleAsStringFlags, extra_args: *mut glib::GHashTable, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_unref(self_: *mut NMIPRoutingRule);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_validate(self_: *const NMIPRoutingRule, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_ip_routing_rule_from_string(str: *const c_char, to_string_flags: NMIPRoutingRuleAsStringFlags, extra_args: *mut glib::GHashTable, error: *mut *mut glib::GError) -> *mut NMIPRoutingRule;

    //=========================================================================
    // NMKeyfileHandlerData
    //=========================================================================
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_keyfile_handler_data_fail_with_error(handler_data: *mut NMKeyfileHandlerData, src: *mut glib::GError);
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_keyfile_handler_data_get_context(handler_data: *const NMKeyfileHandlerData, out_kf_group_name: *mut *const c_char, out_kf_key_name: *mut *const c_char, out_cur_setting: *mut *mut NMSetting, out_cur_property_name: *mut *const c_char);
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_keyfile_handler_data_warn_get(handler_data: *const NMKeyfileHandlerData, out_message: *mut *const c_char, out_severity: *mut NMKeyfileWarnSeverity);

    //=========================================================================
    // NMLldpNeighbor
    //=========================================================================
    pub fn nm_lldp_neighbor_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_lldp_neighbor_new() -> *mut NMLldpNeighbor;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_lldp_neighbor_get_attr_names(neighbor: *mut NMLldpNeighbor) -> *mut *mut c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_lldp_neighbor_get_attr_string_value(neighbor: *mut NMLldpNeighbor, name: *const c_char, out_value: *mut *const c_char) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_lldp_neighbor_get_attr_type(neighbor: *mut NMLldpNeighbor, name: *const c_char) -> *const glib::GVariantType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_lldp_neighbor_get_attr_uint_value(neighbor: *mut NMLldpNeighbor, name: *const c_char, out_value: *mut c_uint) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_lldp_neighbor_get_attr_value(neighbor: *mut NMLldpNeighbor, name: *const c_char) -> *mut glib::GVariant;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_lldp_neighbor_ref(neighbor: *mut NMLldpNeighbor);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_lldp_neighbor_unref(neighbor: *mut NMLldpNeighbor);

    //=========================================================================
    // NMRange
    //=========================================================================
    pub fn nm_range_get_type() -> GType;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_range_new(start: u64, end: u64) -> *mut NMRange;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_range_cmp(a: *const NMRange, b: *const NMRange) -> c_int;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_range_get_range(range: *const NMRange, start: *mut u64, end: *mut u64) -> gboolean;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_range_ref(range: *const NMRange) -> *mut NMRange;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_range_to_str(range: *const NMRange) -> *mut c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_range_unref(range: *const NMRange);
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_range_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMRange;

    //=========================================================================
    // NMSriovVF
    //=========================================================================
    pub fn nm_sriov_vf_get_type() -> GType;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_new(index: c_uint) -> *mut NMSriovVF;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_add_vlan(vf: *mut NMSriovVF, vlan_id: c_uint) -> gboolean;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_dup(vf: *const NMSriovVF) -> *mut NMSriovVF;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_equal(vf: *const NMSriovVF, other: *const NMSriovVF) -> gboolean;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_get_attribute(vf: *const NMSriovVF, name: *const c_char) -> *mut glib::GVariant;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_get_attribute_names(vf: *const NMSriovVF) -> *mut *const c_char;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_get_index(vf: *const NMSriovVF) -> c_uint;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_get_vlan_ids(vf: *const NMSriovVF, length: *mut c_uint) -> *const c_uint;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_get_vlan_protocol(vf: *const NMSriovVF, vlan_id: c_uint) -> NMSriovVFVlanProtocol;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_get_vlan_qos(vf: *const NMSriovVF, vlan_id: c_uint) -> u32;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_ref(vf: *mut NMSriovVF);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_remove_vlan(vf: *mut NMSriovVF, vlan_id: c_uint) -> gboolean;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_set_attribute(vf: *mut NMSriovVF, name: *const c_char, value: *mut glib::GVariant);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_set_vlan_protocol(vf: *mut NMSriovVF, vlan_id: c_uint, protocol: NMSriovVFVlanProtocol);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_set_vlan_qos(vf: *mut NMSriovVF, vlan_id: c_uint, qos: u32);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_sriov_vf_unref(vf: *mut NMSriovVF);
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_sriov_vf_attribute_validate(name: *const c_char, value: *mut glib::GVariant, known: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMTCAction
    //=========================================================================
    pub fn nm_tc_action_get_type() -> GType;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_new(kind: *const c_char, error: *mut *mut glib::GError) -> *mut NMTCAction;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_dup(action: *mut NMTCAction) -> *mut NMTCAction;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_equal(action: *mut NMTCAction, other: *mut NMTCAction) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_get_attribute(action: *mut NMTCAction, name: *const c_char) -> *mut glib::GVariant;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_get_attribute_names(action: *mut NMTCAction) -> *mut *mut c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_get_kind(action: *mut NMTCAction) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_ref(action: *mut NMTCAction);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_set_attribute(action: *mut NMTCAction, name: *const c_char, value: *mut glib::GVariant);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_action_unref(action: *mut NMTCAction);

    //=========================================================================
    // NMTCQdisc
    //=========================================================================
    pub fn nm_tc_qdisc_get_type() -> GType;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_new(kind: *const c_char, parent: u32, error: *mut *mut glib::GError) -> *mut NMTCQdisc;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_dup(qdisc: *mut NMTCQdisc) -> *mut NMTCQdisc;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_equal(qdisc: *mut NMTCQdisc, other: *mut NMTCQdisc) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_tc_qdisc_get_attribute(qdisc: *mut NMTCQdisc, name: *const c_char) -> *mut glib::GVariant;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_tc_qdisc_get_attribute_names(qdisc: *mut NMTCQdisc) -> *mut *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_get_handle(qdisc: *mut NMTCQdisc) -> u32;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_get_kind(qdisc: *mut NMTCQdisc) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_get_parent(qdisc: *mut NMTCQdisc) -> u32;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_ref(qdisc: *mut NMTCQdisc);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_tc_qdisc_set_attribute(qdisc: *mut NMTCQdisc, name: *const c_char, value: *mut glib::GVariant);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_set_handle(qdisc: *mut NMTCQdisc, handle: u32);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_qdisc_unref(qdisc: *mut NMTCQdisc);

    //=========================================================================
    // NMTCTfilter
    //=========================================================================
    pub fn nm_tc_tfilter_get_type() -> GType;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_new(kind: *const c_char, parent: u32, error: *mut *mut glib::GError) -> *mut NMTCTfilter;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_dup(tfilter: *mut NMTCTfilter) -> *mut NMTCTfilter;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_equal(tfilter: *mut NMTCTfilter, other: *mut NMTCTfilter) -> gboolean;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_tc_tfilter_get_action(tfilter: *mut NMTCTfilter) -> *mut NMTCAction;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_get_handle(tfilter: *mut NMTCTfilter) -> u32;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_get_kind(tfilter: *mut NMTCTfilter) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_get_parent(tfilter: *mut NMTCTfilter) -> u32;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_ref(tfilter: *mut NMTCTfilter);
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_tc_tfilter_set_action(tfilter: *mut NMTCTfilter, action: *mut NMTCAction);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_set_handle(tfilter: *mut NMTCTfilter, handle: u32);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_tc_tfilter_unref(tfilter: *mut NMTCTfilter);

    //=========================================================================
    // NMTeamLinkWatcher
    //=========================================================================
    pub fn nm_team_link_watcher_get_type() -> GType;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_new_arp_ping(init_wait: c_int, interval: c_int, missed_max: c_int, target_host: *const c_char, source_host: *const c_char, flags: NMTeamLinkWatcherArpPingFlags, error: *mut *mut glib::GError) -> *mut NMTeamLinkWatcher;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_team_link_watcher_new_arp_ping2(init_wait: c_int, interval: c_int, missed_max: c_int, vlanid: c_int, target_host: *const c_char, source_host: *const c_char, flags: NMTeamLinkWatcherArpPingFlags, error: *mut *mut glib::GError) -> *mut NMTeamLinkWatcher;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_new_ethtool(delay_up: c_int, delay_down: c_int, error: *mut *mut glib::GError) -> *mut NMTeamLinkWatcher;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_new_nsna_ping(init_wait: c_int, interval: c_int, missed_max: c_int, target_host: *const c_char, error: *mut *mut glib::GError) -> *mut NMTeamLinkWatcher;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_dup(watcher: *const NMTeamLinkWatcher) -> *mut NMTeamLinkWatcher;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_equal(watcher: *const NMTeamLinkWatcher, other: *const NMTeamLinkWatcher) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_delay_down(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_delay_up(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_flags(watcher: *const NMTeamLinkWatcher) -> NMTeamLinkWatcherArpPingFlags;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_init_wait(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_interval(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_missed_max(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_name(watcher: *const NMTeamLinkWatcher) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_source_host(watcher: *const NMTeamLinkWatcher) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_get_target_host(watcher: *const NMTeamLinkWatcher) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_team_link_watcher_get_vlanid(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_ref(watcher: *mut NMTeamLinkWatcher);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_team_link_watcher_unref(watcher: *mut NMTeamLinkWatcher);

    //=========================================================================
    // NMWireGuardPeer
    //=========================================================================
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_get_type() -> GType;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_new() -> *mut NMWireGuardPeer;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_append_allowed_ip(self_: *mut NMWireGuardPeer, allowed_ip: *const c_char, accept_invalid: gboolean) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_clear_allowed_ips(self_: *mut NMWireGuardPeer);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_cmp(a: *const NMWireGuardPeer, b: *const NMWireGuardPeer, compare_flags: NMSettingCompareFlags) -> c_int;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_get_allowed_ip(self_: *const NMWireGuardPeer, idx: c_uint, out_is_valid: *mut gboolean) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_get_allowed_ips_len(self_: *const NMWireGuardPeer) -> c_uint;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_get_endpoint(self_: *const NMWireGuardPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_get_persistent_keepalive(self_: *const NMWireGuardPeer) -> u16;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_get_preshared_key(self_: *const NMWireGuardPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_get_preshared_key_flags(self_: *const NMWireGuardPeer) -> NMSettingSecretFlags;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_get_public_key(self_: *const NMWireGuardPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_is_sealed(self_: *const NMWireGuardPeer) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_is_valid(self_: *const NMWireGuardPeer, check_non_secrets: gboolean, check_secrets: gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_new_clone(self_: *const NMWireGuardPeer, with_secrets: gboolean) -> *mut NMWireGuardPeer;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_ref(self_: *mut NMWireGuardPeer) -> *mut NMWireGuardPeer;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_remove_allowed_ip(self_: *mut NMWireGuardPeer, idx: c_uint) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_seal(self_: *mut NMWireGuardPeer);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_set_endpoint(self_: *mut NMWireGuardPeer, endpoint: *const c_char, allow_invalid: gboolean) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_set_persistent_keepalive(self_: *mut NMWireGuardPeer, persistent_keepalive: u16);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_set_preshared_key(self_: *mut NMWireGuardPeer, preshared_key: *const c_char, accept_invalid: gboolean) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_set_preshared_key_flags(self_: *mut NMWireGuardPeer, preshared_key_flags: NMSettingSecretFlags);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_set_public_key(self_: *mut NMWireGuardPeer, public_key: *const c_char, accept_invalid: gboolean) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wireguard_peer_unref(self_: *mut NMWireGuardPeer);

    //=========================================================================
    // NMAccessPoint
    //=========================================================================
    pub fn nm_access_point_get_type() -> GType;
    pub fn nm_access_point_connection_valid(ap: *mut NMAccessPoint, connection: *mut NMConnection) -> gboolean;
    pub fn nm_access_point_filter_connections(ap: *mut NMAccessPoint, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_access_point_get_bandwidth(ap: *mut NMAccessPoint) -> u32;
    pub fn nm_access_point_get_bssid(ap: *mut NMAccessPoint) -> *const c_char;
    pub fn nm_access_point_get_flags(ap: *mut NMAccessPoint) -> NM80211ApFlags;
    pub fn nm_access_point_get_frequency(ap: *mut NMAccessPoint) -> u32;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_access_point_get_last_seen(ap: *mut NMAccessPoint) -> c_int;
    pub fn nm_access_point_get_max_bitrate(ap: *mut NMAccessPoint) -> u32;
    pub fn nm_access_point_get_mode(ap: *mut NMAccessPoint) -> NM80211Mode;
    pub fn nm_access_point_get_rsn_flags(ap: *mut NMAccessPoint) -> NM80211ApSecurityFlags;
    pub fn nm_access_point_get_ssid(ap: *mut NMAccessPoint) -> *mut glib::GBytes;
    pub fn nm_access_point_get_strength(ap: *mut NMAccessPoint) -> u8;
    pub fn nm_access_point_get_wpa_flags(ap: *mut NMAccessPoint) -> NM80211ApSecurityFlags;

    //=========================================================================
    // NMActiveConnection
    //=========================================================================
    pub fn nm_active_connection_get_type() -> GType;
    pub fn nm_active_connection_get_connection(connection: *mut NMActiveConnection) -> *mut NMRemoteConnection;
    pub fn nm_active_connection_get_connection_type(connection: *mut NMActiveConnection) -> *const c_char;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_active_connection_get_controller(connection: *mut NMActiveConnection) -> *mut NMDevice;
    pub fn nm_active_connection_get_default(connection: *mut NMActiveConnection) -> gboolean;
    pub fn nm_active_connection_get_default6(connection: *mut NMActiveConnection) -> gboolean;
    pub fn nm_active_connection_get_devices(connection: *mut NMActiveConnection) -> *const glib::GPtrArray;
    pub fn nm_active_connection_get_dhcp4_config(connection: *mut NMActiveConnection) -> *mut NMDhcpConfig;
    pub fn nm_active_connection_get_dhcp6_config(connection: *mut NMActiveConnection) -> *mut NMDhcpConfig;
    pub fn nm_active_connection_get_id(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_ip4_config(connection: *mut NMActiveConnection) -> *mut NMIPConfig;
    pub fn nm_active_connection_get_ip6_config(connection: *mut NMActiveConnection) -> *mut NMIPConfig;
    pub fn nm_active_connection_get_master(connection: *mut NMActiveConnection) -> *mut NMDevice;
    pub fn nm_active_connection_get_specific_object_path(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_state(connection: *mut NMActiveConnection) -> NMActiveConnectionState;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_active_connection_get_state_flags(connection: *mut NMActiveConnection) -> NMActivationStateFlags;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_active_connection_get_state_reason(connection: *mut NMActiveConnection) -> NMActiveConnectionStateReason;
    pub fn nm_active_connection_get_uuid(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_vpn(connection: *mut NMActiveConnection) -> gboolean;

    //=========================================================================
    // NMCheckpoint
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_checkpoint_get_type() -> GType;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_checkpoint_get_created(checkpoint: *mut NMCheckpoint) -> i64;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_checkpoint_get_devices(checkpoint: *mut NMCheckpoint) -> *const glib::GPtrArray;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_checkpoint_get_rollback_timeout(checkpoint: *mut NMCheckpoint) -> u32;

    //=========================================================================
    // NMClient
    //=========================================================================
    pub fn nm_client_get_type() -> GType;
    pub fn nm_client_new(cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut NMClient;
    pub fn nm_client_new_finish(result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMClient;
    pub fn nm_client_new_async(cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_client_wait_shutdown_finish(result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_activate_connection_async(client: *mut NMClient, connection: *mut NMConnection, device: *mut NMDevice, specific_object: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_activate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMActiveConnection;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_client_add_and_activate_connection2(client: *mut NMClient, partial: *mut NMConnection, device: *mut NMDevice, specific_object: *const c_char, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_client_add_and_activate_connection2_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, out_result: *mut *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut NMActiveConnection;
    pub fn nm_client_add_and_activate_connection_async(client: *mut NMClient, partial: *mut NMConnection, device: *mut NMDevice, specific_object: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_add_and_activate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMActiveConnection;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_client_add_connection2(client: *mut NMClient, settings: *mut glib::GVariant, flags: NMSettingsAddConnection2Flags, args: *mut glib::GVariant, ignore_out_result: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_client_add_connection2_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, out_result: *mut *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut NMRemoteConnection;
    pub fn nm_client_add_connection_async(client: *mut NMClient, connection: *mut NMConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_add_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMRemoteConnection;
    pub fn nm_client_check_connectivity(client: *mut NMClient, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> NMConnectivityState;
    pub fn nm_client_check_connectivity_async(client: *mut NMClient, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_check_connectivity_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> NMConnectivityState;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_checkpoint_adjust_rollback_timeout(client: *mut NMClient, checkpoint_path: *const c_char, add_timeout: u32, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_checkpoint_adjust_rollback_timeout_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_checkpoint_create(client: *mut NMClient, devices: *const glib::GPtrArray, rollback_timeout: u32, flags: NMCheckpointCreateFlags, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_checkpoint_create_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMCheckpoint;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_checkpoint_destroy(client: *mut NMClient, checkpoint_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_checkpoint_destroy_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_checkpoint_rollback(client: *mut NMClient, checkpoint_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_checkpoint_rollback_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GHashTable;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_client_connectivity_check_get_available(client: *mut NMClient) -> gboolean;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_client_connectivity_check_get_enabled(client: *mut NMClient) -> gboolean;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_client_connectivity_check_get_uri(client: *mut NMClient) -> *const c_char;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_client_connectivity_check_set_enabled(client: *mut NMClient, enabled: gboolean);
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_dbus_call(client: *mut NMClient, object_path: *const c_char, interface_name: *const c_char, method_name: *const c_char, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, timeout_msec: c_int, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_dbus_call_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_dbus_set_property(client: *mut NMClient, object_path: *const c_char, interface_name: *const c_char, property_name: *const c_char, value: *mut glib::GVariant, timeout_msec: c_int, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_dbus_set_property_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_deactivate_connection(client: *mut NMClient, active: *mut NMActiveConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_deactivate_connection_async(client: *mut NMClient, active: *mut NMActiveConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_deactivate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_get_activating_connection(client: *mut NMClient) -> *mut NMActiveConnection;
    pub fn nm_client_get_active_connections(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_client_get_all_devices(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_get_capabilities(client: *mut NMClient, length: *mut size_t) -> *const u32;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_client_get_checkpoints(client: *mut NMClient) -> *const glib::GPtrArray;
    pub fn nm_client_get_connection_by_id(client: *mut NMClient, id: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connection_by_path(client: *mut NMClient, path: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connection_by_uuid(client: *mut NMClient, uuid: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connections(client: *mut NMClient) -> *const glib::GPtrArray;
    pub fn nm_client_get_connectivity(client: *mut NMClient) -> NMConnectivityState;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_client_get_context_busy_watcher(self_: *mut NMClient) -> *mut gobject::GObject;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_client_get_dbus_connection(client: *mut NMClient) -> *mut gio::GDBusConnection;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_client_get_dbus_name_owner(client: *mut NMClient) -> *const c_char;
    pub fn nm_client_get_device_by_iface(client: *mut NMClient, iface: *const c_char) -> *mut NMDevice;
    pub fn nm_client_get_device_by_path(client: *mut NMClient, object_path: *const c_char) -> *mut NMDevice;
    pub fn nm_client_get_devices(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_client_get_dns_configuration(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_client_get_dns_mode(client: *mut NMClient) -> *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_client_get_dns_rc_manager(client: *mut NMClient) -> *const c_char;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_get_instance_flags(self_: *mut NMClient) -> NMClientInstanceFlags;
    pub fn nm_client_get_logging(client: *mut NMClient, level: *mut *mut c_char, domains: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_client_get_main_context(self_: *mut NMClient) -> *mut glib::GMainContext;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_client_get_metered(client: *mut NMClient) -> NMMetered;
    pub fn nm_client_get_nm_running(client: *mut NMClient) -> gboolean;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_get_object_by_path(client: *mut NMClient, dbus_path: *const c_char) -> *mut NMObject;
    pub fn nm_client_get_permission_result(client: *mut NMClient, permission: NMClientPermission) -> NMClientPermissionResult;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_client_get_permissions_state(self_: *mut NMClient) -> NMTernary;
    pub fn nm_client_get_primary_connection(client: *mut NMClient) -> *mut NMActiveConnection;
    #[cfg(feature = "v1_38")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
    pub fn nm_client_get_radio_flags(client: *mut NMClient) -> NMRadioFlags;
    pub fn nm_client_get_startup(client: *mut NMClient) -> gboolean;
    pub fn nm_client_get_state(client: *mut NMClient) -> NMState;
    pub fn nm_client_get_version(client: *mut NMClient) -> *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_client_get_version_info(client: *mut NMClient, length: *mut size_t) -> *const u32;
    pub fn nm_client_load_connections(client: *mut NMClient, filenames: *mut *mut c_char, failures: *mut *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_load_connections_async(client: *mut NMClient, filenames: *mut *mut c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_load_connections_finish(client: *mut NMClient, failures: *mut *mut *mut c_char, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_networking_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_networking_set_enabled(client: *mut NMClient, enabled: gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_client_reload(client: *mut NMClient, flags: NMManagerReloadFlags, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_reload_connections(client: *mut NMClient, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_reload_connections_async(client: *mut NMClient, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_reload_connections_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_client_reload_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_save_hostname(client: *mut NMClient, hostname: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_save_hostname_async(client: *mut NMClient, hostname: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_save_hostname_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_set_logging(client: *mut NMClient, level: *const c_char, domains: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_client_wait_shutdown(client: *mut NMClient, integrate_maincontext: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_wimax_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wimax_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wimax_set_enabled(client: *mut NMClient, enabled: gboolean);
    pub fn nm_client_wireless_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wireless_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wireless_set_enabled(client: *mut NMClient, enabled: gboolean);
    pub fn nm_client_wwan_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wwan_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wwan_set_enabled(client: *mut NMClient, enabled: gboolean);

    //=========================================================================
    // NMDevice
    //=========================================================================
    pub fn nm_device_get_type() -> GType;
    pub fn nm_device_disambiguate_names(devices: *mut *mut NMDevice, num_devices: c_int) -> *mut *mut c_char;
    pub fn nm_device_connection_compatible(device: *mut NMDevice, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_connection_valid(device: *mut NMDevice, connection: *mut NMConnection) -> gboolean;
    pub fn nm_device_delete(device: *mut NMDevice, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_delete_async(device: *mut NMDevice, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_delete_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_disconnect(device: *mut NMDevice, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_disconnect_async(device: *mut NMDevice, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_disconnect_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_filter_connections(device: *mut NMDevice, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    pub fn nm_device_get_active_connection(device: *mut NMDevice) -> *mut NMActiveConnection;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_get_applied_connection(device: *mut NMDevice, flags: u32, version_id: *mut u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut NMConnection;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_get_applied_connection_async(device: *mut NMDevice, flags: u32, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_get_applied_connection_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, version_id: *mut u64, error: *mut *mut glib::GError) -> *mut NMConnection;
    pub fn nm_device_get_autoconnect(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_get_available_connections(device: *mut NMDevice) -> *const glib::GPtrArray;
    pub fn nm_device_get_capabilities(device: *mut NMDevice) -> NMDeviceCapabilities;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_device_get_connectivity(device: *mut NMDevice, addr_family: c_int) -> NMConnectivityState;
    pub fn nm_device_get_description(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_device_type(device: *mut NMDevice) -> NMDeviceType;
    pub fn nm_device_get_dhcp4_config(device: *mut NMDevice) -> *mut NMDhcpConfig;
    pub fn nm_device_get_dhcp6_config(device: *mut NMDevice) -> *mut NMDhcpConfig;
    pub fn nm_device_get_driver(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_driver_version(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_firmware_missing(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_get_firmware_version(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_hw_address(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_iface(device: *mut NMDevice) -> *const c_char;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_device_get_interface_flags(device: *mut NMDevice) -> NMDeviceInterfaceFlags;
    pub fn nm_device_get_ip4_config(device: *mut NMDevice) -> *mut NMIPConfig;
    pub fn nm_device_get_ip6_config(device: *mut NMDevice) -> *mut NMIPConfig;
    pub fn nm_device_get_ip_iface(device: *mut NMDevice) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_get_lldp_neighbors(device: *mut NMDevice) -> *mut glib::GPtrArray;
    pub fn nm_device_get_managed(device: *mut NMDevice) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_get_metered(device: *mut NMDevice) -> NMMetered;
    pub fn nm_device_get_mtu(device: *mut NMDevice) -> u32;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_get_nm_plugin_missing(device: *mut NMDevice) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_device_get_path(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_physical_port_id(device: *mut NMDevice) -> *const c_char;
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn nm_device_get_ports(device: *mut NMDevice) -> *const glib::GPtrArray;
    pub fn nm_device_get_product(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_setting_type(device: *mut NMDevice) -> GType;
    pub fn nm_device_get_state(device: *mut NMDevice) -> NMDeviceState;
    pub fn nm_device_get_state_reason(device: *mut NMDevice) -> NMDeviceStateReason;
    pub fn nm_device_get_type_description(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_udi(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_vendor(device: *mut NMDevice) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_is_real(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_is_software(device: *mut NMDevice) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_reapply(device: *mut NMDevice, connection: *mut NMConnection, version_id: u64, flags: u32, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_reapply_async(device: *mut NMDevice, connection: *mut NMConnection, version_id: u64, flags: u32, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_reapply_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_set_autoconnect(device: *mut NMDevice, autoconnect: gboolean);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_set_managed(device: *mut NMDevice, managed: gboolean);

    //=========================================================================
    // NMDevice6Lowpan
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_device_6lowpan_get_type() -> GType;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_device_6lowpan_get_parent(device: *mut NMDevice6Lowpan) -> *mut NMDevice;

    //=========================================================================
    // NMDeviceAdsl
    //=========================================================================
    pub fn nm_device_adsl_get_type() -> GType;
    pub fn nm_device_adsl_get_carrier(device: *mut NMDeviceAdsl) -> gboolean;

    //=========================================================================
    // NMDeviceBond
    //=========================================================================
    pub fn nm_device_bond_get_type() -> GType;
    pub fn nm_device_bond_get_carrier(device: *mut NMDeviceBond) -> gboolean;
    pub fn nm_device_bond_get_hw_address(device: *mut NMDeviceBond) -> *const c_char;
    pub fn nm_device_bond_get_slaves(device: *mut NMDeviceBond) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceBridge
    //=========================================================================
    pub fn nm_device_bridge_get_type() -> GType;
    pub fn nm_device_bridge_get_carrier(device: *mut NMDeviceBridge) -> gboolean;
    pub fn nm_device_bridge_get_hw_address(device: *mut NMDeviceBridge) -> *const c_char;
    pub fn nm_device_bridge_get_slaves(device: *mut NMDeviceBridge) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceBt
    //=========================================================================
    pub fn nm_device_bt_get_type() -> GType;
    pub fn nm_device_bt_get_capabilities(device: *mut NMDeviceBt) -> NMBluetoothCapabilities;
    pub fn nm_device_bt_get_hw_address(device: *mut NMDeviceBt) -> *const c_char;
    pub fn nm_device_bt_get_name(device: *mut NMDeviceBt) -> *const c_char;

    //=========================================================================
    // NMDeviceDummy
    //=========================================================================
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_device_dummy_get_type() -> GType;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_device_dummy_get_hw_address(device: *mut NMDeviceDummy) -> *const c_char;

    //=========================================================================
    // NMDeviceEthernet
    //=========================================================================
    pub fn nm_device_ethernet_get_type() -> GType;
    pub fn nm_device_ethernet_get_carrier(device: *mut NMDeviceEthernet) -> gboolean;
    pub fn nm_device_ethernet_get_hw_address(device: *mut NMDeviceEthernet) -> *const c_char;
    pub fn nm_device_ethernet_get_permanent_hw_address(device: *mut NMDeviceEthernet) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ethernet_get_s390_subchannels(device: *mut NMDeviceEthernet) -> *const *const c_char;
    pub fn nm_device_ethernet_get_speed(device: *mut NMDeviceEthernet) -> u32;

    //=========================================================================
    // NMDeviceGeneric
    //=========================================================================
    pub fn nm_device_generic_get_type() -> GType;
    pub fn nm_device_generic_get_hw_address(device: *mut NMDeviceGeneric) -> *const c_char;

    //=========================================================================
    // NMDeviceHsr
    //=========================================================================
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_device_hsr_get_type() -> GType;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_device_hsr_get_multicast_spec(device: *mut NMDeviceHsr) -> u8;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_device_hsr_get_port1(device: *mut NMDeviceHsr) -> *mut NMDevice;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_device_hsr_get_port2(device: *mut NMDeviceHsr) -> *mut NMDevice;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_device_hsr_get_prp(device: *mut NMDeviceHsr) -> gboolean;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_device_hsr_get_supervision_address(device: *mut NMDeviceHsr) -> *const c_char;

    //=========================================================================
    // NMDeviceIPTunnel
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_encapsulation_limit(device: *mut NMDeviceIPTunnel) -> u8;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_device_ip_tunnel_get_flags(device: *mut NMDeviceIPTunnel) -> NMIPTunnelFlags;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_flow_label(device: *mut NMDeviceIPTunnel) -> c_uint;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_device_ip_tunnel_get_fwmark(device: *mut NMDeviceIPTunnel) -> u32;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_input_key(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_local(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_mode(device: *mut NMDeviceIPTunnel) -> NMIPTunnelMode;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_output_key(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_parent(device: *mut NMDeviceIPTunnel) -> *mut NMDevice;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_path_mtu_discovery(device: *mut NMDeviceIPTunnel) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_remote(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_tos(device: *mut NMDeviceIPTunnel) -> u8;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_ip_tunnel_get_ttl(device: *mut NMDeviceIPTunnel) -> u8;

    //=========================================================================
    // NMDeviceInfiniband
    //=========================================================================
    pub fn nm_device_infiniband_get_type() -> GType;
    pub fn nm_device_infiniband_get_carrier(device: *mut NMDeviceInfiniband) -> gboolean;
    pub fn nm_device_infiniband_get_hw_address(device: *mut NMDeviceInfiniband) -> *const c_char;

    //=========================================================================
    // NMDeviceLoopback
    //=========================================================================
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_device_loopback_get_type() -> GType;

    //=========================================================================
    // NMDeviceMacsec
    //=========================================================================
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_cipher_suite(device: *mut NMDeviceMacsec) -> u64;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_encoding_sa(device: *mut NMDeviceMacsec) -> u8;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_encrypt(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_es(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_hw_address(device: *mut NMDeviceMacsec) -> *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_icv_length(device: *mut NMDeviceMacsec) -> u8;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_include_sci(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_device_macsec_get_parent(device: *mut NMDeviceMacsec) -> *mut NMDevice;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_protect(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_replay_protect(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_scb(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_sci(device: *mut NMDeviceMacsec) -> u64;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_validation(device: *mut NMDeviceMacsec) -> *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_device_macsec_get_window(device: *mut NMDeviceMacsec) -> c_uint;

    //=========================================================================
    // NMDeviceMacvlan
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_macvlan_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_macvlan_get_hw_address(device: *mut NMDeviceMacvlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_macvlan_get_mode(device: *mut NMDeviceMacvlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_macvlan_get_no_promisc(device: *mut NMDeviceMacvlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_macvlan_get_parent(device: *mut NMDeviceMacvlan) -> *mut NMDevice;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_macvlan_get_tap(device: *mut NMDeviceMacvlan) -> gboolean;

    //=========================================================================
    // NMDeviceModem
    //=========================================================================
    pub fn nm_device_modem_get_type() -> GType;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_device_modem_get_apn(self_: *mut NMDeviceModem) -> *const c_char;
    pub fn nm_device_modem_get_current_capabilities(self_: *mut NMDeviceModem) -> NMDeviceModemCapabilities;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_device_modem_get_device_id(self_: *mut NMDeviceModem) -> *const c_char;
    pub fn nm_device_modem_get_modem_capabilities(self_: *mut NMDeviceModem) -> NMDeviceModemCapabilities;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_device_modem_get_operator_code(self_: *mut NMDeviceModem) -> *const c_char;

    //=========================================================================
    // NMDeviceOlpcMesh
    //=========================================================================
    pub fn nm_device_olpc_mesh_get_type() -> GType;
    pub fn nm_device_olpc_mesh_get_active_channel(device: *mut NMDeviceOlpcMesh) -> u32;
    pub fn nm_device_olpc_mesh_get_companion(device: *mut NMDeviceOlpcMesh) -> *mut NMDeviceWifi;
    pub fn nm_device_olpc_mesh_get_hw_address(device: *mut NMDeviceOlpcMesh) -> *const c_char;

    //=========================================================================
    // NMDeviceOvsBridge
    //=========================================================================
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_device_ovs_bridge_get_type() -> GType;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_device_ovs_bridge_get_slaves(device: *mut NMDeviceOvsBridge) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceOvsInterface
    //=========================================================================
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_device_ovs_interface_get_type() -> GType;

    //=========================================================================
    // NMDeviceOvsPort
    //=========================================================================
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_device_ovs_port_get_type() -> GType;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_device_ovs_port_get_slaves(device: *mut NMDeviceOvsPort) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDevicePpp
    //=========================================================================
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_device_ppp_get_type() -> GType;

    //=========================================================================
    // NMDeviceTeam
    //=========================================================================
    pub fn nm_device_team_get_type() -> GType;
    pub fn nm_device_team_get_carrier(device: *mut NMDeviceTeam) -> gboolean;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_device_team_get_config(device: *mut NMDeviceTeam) -> *const c_char;
    pub fn nm_device_team_get_hw_address(device: *mut NMDeviceTeam) -> *const c_char;
    pub fn nm_device_team_get_slaves(device: *mut NMDeviceTeam) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceTun
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_tun_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_tun_get_group(device: *mut NMDeviceTun) -> i64;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_tun_get_hw_address(device: *mut NMDeviceTun) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_tun_get_mode(device: *mut NMDeviceTun) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_tun_get_multi_queue(device: *mut NMDeviceTun) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_tun_get_no_pi(device: *mut NMDeviceTun) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_tun_get_owner(device: *mut NMDeviceTun) -> i64;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_tun_get_vnet_hdr(device: *mut NMDeviceTun) -> gboolean;

    //=========================================================================
    // NMDeviceVeth
    //=========================================================================
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_device_veth_get_type() -> GType;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_device_veth_get_peer(device: *mut NMDeviceVeth) -> *mut NMDevice;

    //=========================================================================
    // NMDeviceVlan
    //=========================================================================
    pub fn nm_device_vlan_get_type() -> GType;
    pub fn nm_device_vlan_get_carrier(device: *mut NMDeviceVlan) -> gboolean;
    pub fn nm_device_vlan_get_hw_address(device: *mut NMDeviceVlan) -> *const c_char;
    pub fn nm_device_vlan_get_parent(device: *mut NMDeviceVlan) -> *mut NMDevice;
    pub fn nm_device_vlan_get_vlan_id(device: *mut NMDeviceVlan) -> c_uint;

    //=========================================================================
    // NMDeviceVrf
    //=========================================================================
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_device_vrf_get_type() -> GType;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_device_vrf_get_table(device: *mut NMDeviceVrf) -> u32;

    //=========================================================================
    // NMDeviceVxlan
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_ageing(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_device_vxlan_get_carrier(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_dst_port(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_group(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_hw_address(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_id(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_l2miss(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_l3miss(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_learning(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_limit(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_local(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_parent(device: *mut NMDeviceVxlan) -> *mut NMDevice;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_proxy(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_device_vxlan_get_rsc(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_src_port_max(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_src_port_min(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_tos(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_vxlan_get_ttl(device: *mut NMDeviceVxlan) -> c_uint;

    //=========================================================================
    // NMDeviceWifi
    //=========================================================================
    pub fn nm_device_wifi_get_type() -> GType;
    pub fn nm_device_wifi_get_access_point_by_path(device: *mut NMDeviceWifi, path: *const c_char) -> *mut NMAccessPoint;
    pub fn nm_device_wifi_get_access_points(device: *mut NMDeviceWifi) -> *const glib::GPtrArray;
    pub fn nm_device_wifi_get_active_access_point(device: *mut NMDeviceWifi) -> *mut NMAccessPoint;
    pub fn nm_device_wifi_get_bitrate(device: *mut NMDeviceWifi) -> u32;
    pub fn nm_device_wifi_get_capabilities(device: *mut NMDeviceWifi) -> NMDeviceWifiCapabilities;
    pub fn nm_device_wifi_get_hw_address(device: *mut NMDeviceWifi) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_device_wifi_get_last_scan(device: *mut NMDeviceWifi) -> i64;
    pub fn nm_device_wifi_get_mode(device: *mut NMDeviceWifi) -> NM80211Mode;
    pub fn nm_device_wifi_get_permanent_hw_address(device: *mut NMDeviceWifi) -> *const c_char;
    pub fn nm_device_wifi_request_scan(device: *mut NMDeviceWifi, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_wifi_request_scan_async(device: *mut NMDeviceWifi, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_wifi_request_scan_finish(device: *mut NMDeviceWifi, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_wifi_request_scan_options(device: *mut NMDeviceWifi, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_device_wifi_request_scan_options_async(device: *mut NMDeviceWifi, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // NMDeviceWifiP2P
    //=========================================================================
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_device_wifi_p2p_get_type() -> GType;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_device_wifi_p2p_get_hw_address(device: *mut NMDeviceWifiP2P) -> *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_device_wifi_p2p_get_peer_by_path(device: *mut NMDeviceWifiP2P, path: *const c_char) -> *mut NMWifiP2PPeer;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_device_wifi_p2p_get_peers(device: *mut NMDeviceWifiP2P) -> *const glib::GPtrArray;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_device_wifi_p2p_start_find(device: *mut NMDeviceWifiP2P, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_device_wifi_p2p_start_find_finish(device: *mut NMDeviceWifiP2P, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_device_wifi_p2p_stop_find(device: *mut NMDeviceWifiP2P, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_device_wifi_p2p_stop_find_finish(device: *mut NMDeviceWifiP2P, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMDeviceWimax
    //=========================================================================
    pub fn nm_device_wimax_get_type() -> GType;
    pub fn nm_device_wimax_get_active_nsp(wimax: *mut NMDeviceWimax) -> *mut NMWimaxNsp;
    pub fn nm_device_wimax_get_bsid(self_: *mut NMDeviceWimax) -> *const c_char;
    pub fn nm_device_wimax_get_center_frequency(self_: *mut NMDeviceWimax) -> c_uint;
    pub fn nm_device_wimax_get_cinr(self_: *mut NMDeviceWimax) -> c_int;
    pub fn nm_device_wimax_get_hw_address(wimax: *mut NMDeviceWimax) -> *const c_char;
    pub fn nm_device_wimax_get_nsp_by_path(wimax: *mut NMDeviceWimax, path: *const c_char) -> *mut NMWimaxNsp;
    pub fn nm_device_wimax_get_nsps(wimax: *mut NMDeviceWimax) -> *const glib::GPtrArray;
    pub fn nm_device_wimax_get_rssi(self_: *mut NMDeviceWimax) -> c_int;
    pub fn nm_device_wimax_get_tx_power(self_: *mut NMDeviceWimax) -> c_int;

    //=========================================================================
    // NMDeviceWireGuard
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_device_wireguard_get_type() -> GType;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_device_wireguard_get_fwmark(device: *mut NMDeviceWireGuard) -> u32;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_device_wireguard_get_listen_port(device: *mut NMDeviceWireGuard) -> u16;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_device_wireguard_get_public_key(device: *mut NMDeviceWireGuard) -> *mut glib::GBytes;

    //=========================================================================
    // NMDeviceWpan
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_device_wpan_get_type() -> GType;

    //=========================================================================
    // NMDhcpConfig
    //=========================================================================
    pub fn nm_dhcp_config_get_type() -> GType;
    pub fn nm_dhcp_config_get_family(config: *mut NMDhcpConfig) -> c_int;
    pub fn nm_dhcp_config_get_one_option(config: *mut NMDhcpConfig, option: *const c_char) -> *const c_char;
    pub fn nm_dhcp_config_get_options(config: *mut NMDhcpConfig) -> *mut glib::GHashTable;

    //=========================================================================
    // NMIPConfig
    //=========================================================================
    pub fn nm_ip_config_get_type() -> GType;
    pub fn nm_ip_config_get_addresses(config: *mut NMIPConfig) -> *mut glib::GPtrArray;
    pub fn nm_ip_config_get_domains(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_family(config: *mut NMIPConfig) -> c_int;
    pub fn nm_ip_config_get_gateway(config: *mut NMIPConfig) -> *const c_char;
    pub fn nm_ip_config_get_nameservers(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_routes(config: *mut NMIPConfig) -> *mut glib::GPtrArray;
    pub fn nm_ip_config_get_searches(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_wins_servers(config: *mut NMIPConfig) -> *const *const c_char;

    //=========================================================================
    // NMObject
    //=========================================================================
    pub fn nm_object_get_type() -> GType;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_object_get_client(object: *mut NMObject) -> *mut NMClient;
    pub fn nm_object_get_path(object: *mut NMObject) -> *const c_char;

    //=========================================================================
    // NMRemoteConnection
    //=========================================================================
    pub fn nm_remote_connection_get_type() -> GType;
    pub fn nm_remote_connection_commit_changes(connection: *mut NMRemoteConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_commit_changes_async(connection: *mut NMRemoteConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_commit_changes_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_delete(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_delete_async(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_delete_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_remote_connection_get_filename(connection: *mut NMRemoteConnection) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_remote_connection_get_flags(connection: *mut NMRemoteConnection) -> NMSettingsConnectionFlags;
    pub fn nm_remote_connection_get_secrets(connection: *mut NMRemoteConnection, setting_name: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn nm_remote_connection_get_secrets_async(connection: *mut NMRemoteConnection, setting_name: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_get_secrets_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn nm_remote_connection_get_unsaved(connection: *mut NMRemoteConnection) -> gboolean;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_remote_connection_get_version_id(connection: *mut NMRemoteConnection) -> u64;
    pub fn nm_remote_connection_get_visible(connection: *mut NMRemoteConnection) -> gboolean;
    pub fn nm_remote_connection_save(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_save_async(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_save_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_remote_connection_update2(connection: *mut NMRemoteConnection, settings: *mut glib::GVariant, flags: NMSettingsUpdate2Flags, args: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_remote_connection_update2_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;

    //=========================================================================
    // NMSecretAgentOld
    //=========================================================================
    pub fn nm_secret_agent_old_get_type() -> GType;
    pub fn nm_secret_agent_old_delete_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, callback: NMSecretAgentOldDeleteSecretsFunc, user_data: gpointer);
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_secret_agent_old_destroy(self_: *mut NMSecretAgentOld);
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_secret_agent_old_enable(self_: *mut NMSecretAgentOld, enable: gboolean);
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_secret_agent_old_get_context_busy_watcher(self_: *mut NMSecretAgentOld) -> *mut gobject::GObject;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_secret_agent_old_get_dbus_connection(self_: *mut NMSecretAgentOld) -> *mut gio::GDBusConnection;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_secret_agent_old_get_dbus_name_owner(self_: *mut NMSecretAgentOld) -> *const c_char;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_secret_agent_old_get_main_context(self_: *mut NMSecretAgentOld) -> *mut glib::GMainContext;
    pub fn nm_secret_agent_old_get_registered(self_: *mut NMSecretAgentOld) -> gboolean;
    pub fn nm_secret_agent_old_get_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, setting_name: *const c_char, hints: *mut *const c_char, flags: NMSecretAgentGetSecretsFlags, callback: NMSecretAgentOldGetSecretsFunc, user_data: gpointer);
    pub fn nm_secret_agent_old_register(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_register_async(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_secret_agent_old_register_finish(self_: *mut NMSecretAgentOld, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_save_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, callback: NMSecretAgentOldSaveSecretsFunc, user_data: gpointer);
    pub fn nm_secret_agent_old_unregister(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_unregister_async(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_secret_agent_old_unregister_finish(self_: *mut NMSecretAgentOld, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSetting
    //=========================================================================
    pub fn nm_setting_get_type() -> GType;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_get_enum_property_type(setting_type: GType, property_name: *const c_char) -> GType;
    pub fn nm_setting_lookup_type(name: *const c_char) -> GType;
    pub fn nm_setting_compare(a: *mut NMSetting, b: *mut NMSetting, flags: NMSettingCompareFlags) -> gboolean;
    pub fn nm_setting_diff(a: *mut NMSetting, b: *mut NMSetting, flags: NMSettingCompareFlags, invert_results: gboolean, results: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_setting_duplicate(setting: *mut NMSetting) -> *mut NMSetting;
    pub fn nm_setting_enumerate_values(setting: *mut NMSetting, func: NMSettingValueIterFn, user_data: gpointer);
    pub fn nm_setting_get_dbus_property_type(setting: *mut NMSetting, property_name: *const c_char) -> *const glib::GVariantType;
    pub fn nm_setting_get_name(setting: *mut NMSetting) -> *const c_char;
    pub fn nm_setting_get_secret_flags(setting: *mut NMSetting, secret_name: *const c_char, out_flags: *mut NMSettingSecretFlags, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_option_clear_by_name(setting: *mut NMSetting, predicate: NMUtilsPredicateStr);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_option_get(setting: *mut NMSetting, opt_name: *const c_char) -> *mut glib::GVariant;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_option_get_all_names(setting: *mut NMSetting, out_len: *mut c_uint) -> *const *const c_char;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_option_get_boolean(setting: *mut NMSetting, opt_name: *const c_char, out_value: *mut gboolean) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_option_get_uint32(setting: *mut NMSetting, opt_name: *const c_char, out_value: *mut u32) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_option_set(setting: *mut NMSetting, opt_name: *const c_char, variant: *mut glib::GVariant);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_option_set_boolean(setting: *mut NMSetting, opt_name: *const c_char, value: gboolean);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_option_set_uint32(setting: *mut NMSetting, opt_name: *const c_char, value: u32);
    pub fn nm_setting_set_secret_flags(setting: *mut NMSetting, secret_name: *const c_char, flags: NMSettingSecretFlags, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_to_string(setting: *mut NMSetting) -> *mut c_char;
    pub fn nm_setting_verify(setting: *mut NMSetting, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_verify_secrets(setting: *mut NMSetting, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSetting6Lowpan
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_6lowpan_get_type() -> GType;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_6lowpan_new() -> *mut NMSetting;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_6lowpan_get_parent(setting: *mut NMSetting6Lowpan) -> *const c_char;

    //=========================================================================
    // NMSetting8021x
    //=========================================================================
    pub fn nm_setting_802_1x_get_type() -> GType;
    pub fn nm_setting_802_1x_new() -> *mut NMSetting;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_802_1x_check_cert_scheme(pdata: gconstpointer, length: size_t, error: *mut *mut glib::GError) -> NMSetting8021xCKScheme;
    pub fn nm_setting_802_1x_add_altsubject_match(setting: *mut NMSetting8021x, altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_add_eap_method(setting: *mut NMSetting8021x, eap: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_add_phase2_altsubject_match(setting: *mut NMSetting8021x, phase2_altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_clear_altsubject_matches(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_clear_eap_methods(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_clear_phase2_altsubject_matches(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_get_altsubject_match(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_anonymous_identity(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_auth_timeout(setting: *mut NMSetting8021x) -> c_int;
    pub fn nm_setting_802_1x_get_ca_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_ca_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_ca_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_ca_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_ca_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_802_1x_get_ca_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_ca_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_client_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_client_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_client_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_client_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_client_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_802_1x_get_client_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_802_1x_get_domain_match(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_802_1x_get_domain_suffix_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_eap_method(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_identity(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_num_altsubject_matches(setting: *mut NMSetting8021x) -> u32;
    pub fn nm_setting_802_1x_get_num_eap_methods(setting: *mut NMSetting8021x) -> u32;
    pub fn nm_setting_802_1x_get_num_phase2_altsubject_matches(setting: *mut NMSetting8021x) -> u32;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_802_1x_get_openssl_ciphers(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_setting_802_1x_get_optional(setting: *mut NMSetting8021x) -> gboolean;
    pub fn nm_setting_802_1x_get_pac_file(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_password_raw(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_password_raw_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_phase1_auth_flags(setting: *mut NMSetting8021x) -> NMSetting8021xAuthFlags;
    pub fn nm_setting_802_1x_get_phase1_fast_provisioning(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase1_peaplabel(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase1_peapver(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_altsubject_match(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_auth(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_autheap(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_client_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_client_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_client_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_802_1x_get_phase2_domain_match(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_802_1x_get_phase2_domain_suffix_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_phase2_private_key_format(setting: *mut NMSetting8021x) -> NMSetting8021xCKFormat;
    pub fn nm_setting_802_1x_get_phase2_private_key_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_private_key_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_802_1x_get_phase2_private_key_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_subject_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_pin(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_pin_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_private_key_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_private_key_format(setting: *mut NMSetting8021x) -> NMSetting8021xCKFormat;
    pub fn nm_setting_802_1x_get_private_key_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_private_key_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_private_key_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_private_key_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_802_1x_get_private_key_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_subject_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_system_ca_certs(setting: *mut NMSetting8021x) -> gboolean;
    pub fn nm_setting_802_1x_remove_altsubject_match(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_altsubject_match_by_value(setting: *mut NMSetting8021x, altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_remove_eap_method(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_eap_method_by_value(setting: *mut NMSetting8021x, eap: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_remove_phase2_altsubject_match(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_phase2_altsubject_match_by_value(setting: *mut NMSetting8021x, phase2_altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_set_ca_cert(setting: *mut NMSetting8021x, value: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_client_cert(setting: *mut NMSetting8021x, value: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_phase2_ca_cert(setting: *mut NMSetting8021x, value: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_phase2_client_cert(setting: *mut NMSetting8021x, value: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_phase2_private_key(setting: *mut NMSetting8021x, value: *const c_char, password: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_private_key(setting: *mut NMSetting8021x, value: *const c_char, password: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSettingAdsl
    //=========================================================================
    pub fn nm_setting_adsl_get_type() -> GType;
    pub fn nm_setting_adsl_new() -> *mut NMSetting;
    pub fn nm_setting_adsl_get_encapsulation(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_password(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_password_flags(setting: *mut NMSettingAdsl) -> NMSettingSecretFlags;
    pub fn nm_setting_adsl_get_protocol(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_username(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_vci(setting: *mut NMSettingAdsl) -> u32;
    pub fn nm_setting_adsl_get_vpi(setting: *mut NMSettingAdsl) -> u32;

    //=========================================================================
    // NMSettingBluetooth
    //=========================================================================
    pub fn nm_setting_bluetooth_get_type() -> GType;
    pub fn nm_setting_bluetooth_new() -> *mut NMSetting;
    pub fn nm_setting_bluetooth_get_bdaddr(setting: *mut NMSettingBluetooth) -> *const c_char;
    pub fn nm_setting_bluetooth_get_connection_type(setting: *mut NMSettingBluetooth) -> *const c_char;

    //=========================================================================
    // NMSettingBond
    //=========================================================================
    pub fn nm_setting_bond_get_type() -> GType;
    pub fn nm_setting_bond_new() -> *mut NMSetting;
    pub fn nm_setting_bond_validate_option(name: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_bond_add_option(setting: *mut NMSettingBond, name: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_bond_get_num_options(setting: *mut NMSettingBond) -> u32;
    pub fn nm_setting_bond_get_option(setting: *mut NMSettingBond, idx: u32, out_name: *mut *const c_char, out_value: *mut *const c_char) -> gboolean;
    pub fn nm_setting_bond_get_option_by_name(setting: *mut NMSettingBond, name: *const c_char) -> *const c_char;
    pub fn nm_setting_bond_get_option_default(setting: *mut NMSettingBond, name: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_bond_get_option_normalized(setting: *mut NMSettingBond, name: *const c_char) -> *const c_char;
    pub fn nm_setting_bond_get_valid_options(setting: *mut NMSettingBond) -> *mut *const c_char;
    pub fn nm_setting_bond_remove_option(setting: *mut NMSettingBond, name: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingBondPort
    //=========================================================================
    pub fn nm_setting_bond_port_get_type() -> GType;
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn nm_setting_bond_port_new() -> *mut NMSetting;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_bond_port_get_prio(setting: *mut NMSettingBondPort) -> i32;
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn nm_setting_bond_port_get_queue_id(setting: *mut NMSettingBondPort) -> u32;

    //=========================================================================
    // NMSettingBridge
    //=========================================================================
    pub fn nm_setting_bridge_get_type() -> GType;
    pub fn nm_setting_bridge_new() -> *mut NMSetting;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_add_vlan(setting: *mut NMSettingBridge, vlan: *mut NMBridgeVlan);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_clear_vlans(setting: *mut NMSettingBridge);
    pub fn nm_setting_bridge_get_ageing_time(setting: *mut NMSettingBridge) -> u32;
    pub fn nm_setting_bridge_get_forward_delay(setting: *mut NMSettingBridge) -> u16;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_bridge_get_group_address(setting: *const NMSettingBridge) -> *const c_char;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_bridge_get_group_forward_mask(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_hello_time(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_mac_address(setting: *mut NMSettingBridge) -> *const c_char;
    pub fn nm_setting_bridge_get_max_age(setting: *mut NMSettingBridge) -> u16;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_hash_max(setting: *const NMSettingBridge) -> u32;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_last_member_count(setting: *const NMSettingBridge) -> u32;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_last_member_interval(setting: *const NMSettingBridge) -> u64;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_membership_interval(setting: *const NMSettingBridge) -> u64;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_bridge_get_multicast_querier(setting: *const NMSettingBridge) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_querier_interval(setting: *const NMSettingBridge) -> u64;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_query_interval(setting: *const NMSettingBridge) -> u64;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_query_response_interval(setting: *const NMSettingBridge) -> u64;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_bridge_get_multicast_query_use_ifaddr(setting: *const NMSettingBridge) -> gboolean;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_bridge_get_multicast_router(setting: *const NMSettingBridge) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_bridge_get_multicast_snooping(setting: *mut NMSettingBridge) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_startup_query_count(setting: *const NMSettingBridge) -> u32;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_bridge_get_multicast_startup_query_interval(setting: *const NMSettingBridge) -> u64;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_get_num_vlans(setting: *mut NMSettingBridge) -> c_uint;
    pub fn nm_setting_bridge_get_priority(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_stp(setting: *mut NMSettingBridge) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_get_vlan(setting: *mut NMSettingBridge, idx: c_uint) -> *mut NMBridgeVlan;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_get_vlan_default_pvid(setting: *mut NMSettingBridge) -> u16;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_get_vlan_filtering(setting: *mut NMSettingBridge) -> gboolean;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_bridge_get_vlan_protocol(setting: *const NMSettingBridge) -> *const c_char;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_bridge_get_vlan_stats_enabled(setting: *const NMSettingBridge) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_remove_vlan(setting: *mut NMSettingBridge, idx: c_uint);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_remove_vlan_by_vid(setting: *mut NMSettingBridge, vid_start: u16, vid_end: u16) -> gboolean;

    //=========================================================================
    // NMSettingBridgePort
    //=========================================================================
    pub fn nm_setting_bridge_port_get_type() -> GType;
    pub fn nm_setting_bridge_port_new() -> *mut NMSetting;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_port_add_vlan(setting: *mut NMSettingBridgePort, vlan: *mut NMBridgeVlan);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_port_clear_vlans(setting: *mut NMSettingBridgePort);
    pub fn nm_setting_bridge_port_get_hairpin_mode(setting: *mut NMSettingBridgePort) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_port_get_num_vlans(setting: *mut NMSettingBridgePort) -> c_uint;
    pub fn nm_setting_bridge_port_get_path_cost(setting: *mut NMSettingBridgePort) -> u16;
    pub fn nm_setting_bridge_port_get_priority(setting: *mut NMSettingBridgePort) -> u16;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_port_get_vlan(setting: *mut NMSettingBridgePort, idx: c_uint) -> *mut NMBridgeVlan;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_port_remove_vlan(setting: *mut NMSettingBridgePort, idx: c_uint);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_bridge_port_remove_vlan_by_vid(setting: *mut NMSettingBridgePort, vid_start: u16, vid_end: u16) -> gboolean;

    //=========================================================================
    // NMSettingCdma
    //=========================================================================
    pub fn nm_setting_cdma_get_type() -> GType;
    pub fn nm_setting_cdma_new() -> *mut NMSetting;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_cdma_get_mtu(setting: *mut NMSettingCdma) -> u32;
    pub fn nm_setting_cdma_get_number(setting: *mut NMSettingCdma) -> *const c_char;
    pub fn nm_setting_cdma_get_password(setting: *mut NMSettingCdma) -> *const c_char;
    pub fn nm_setting_cdma_get_password_flags(setting: *mut NMSettingCdma) -> NMSettingSecretFlags;
    pub fn nm_setting_cdma_get_username(setting: *mut NMSettingCdma) -> *const c_char;

    //=========================================================================
    // NMSettingConnection
    //=========================================================================
    pub fn nm_setting_connection_get_type() -> GType;
    pub fn nm_setting_connection_new() -> *mut NMSetting;
    pub fn nm_setting_connection_add_permission(setting: *mut NMSettingConnection, ptype: *const c_char, pitem: *const c_char, detail: *const c_char) -> gboolean;
    pub fn nm_setting_connection_add_secondary(setting: *mut NMSettingConnection, sec_uuid: *const c_char) -> gboolean;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_connection_get_auth_retries(setting: *mut NMSettingConnection) -> c_int;
    pub fn nm_setting_connection_get_autoconnect(setting: *mut NMSettingConnection) -> gboolean;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_connection_get_autoconnect_ports(setting: *mut NMSettingConnection) -> NMTernary;
    pub fn nm_setting_connection_get_autoconnect_priority(setting: *mut NMSettingConnection) -> c_int;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_connection_get_autoconnect_retries(setting: *mut NMSettingConnection) -> c_int;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_connection_get_autoconnect_slaves(setting: *mut NMSettingConnection) -> NMSettingConnectionAutoconnectSlaves;
    pub fn nm_setting_connection_get_connection_type(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_connection_get_controller(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn nm_setting_connection_get_dns_over_tls(setting: *mut NMSettingConnection) -> NMSettingConnectionDnsOverTls;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_connection_get_down_on_poweroff(setting: *mut NMSettingConnection) -> NMSettingConnectionDownOnPoweroff;
    pub fn nm_setting_connection_get_gateway_ping_timeout(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_id(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_interface_name(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_connection_get_lldp(setting: *mut NMSettingConnection) -> NMSettingConnectionLldp;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_connection_get_llmnr(setting: *mut NMSettingConnection) -> NMSettingConnectionLlmnr;
    pub fn nm_setting_connection_get_master(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_connection_get_mdns(setting: *mut NMSettingConnection) -> NMSettingConnectionMdns;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_connection_get_metered(setting: *mut NMSettingConnection) -> NMMetered;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_connection_get_mptcp_flags(setting: *mut NMSettingConnection) -> NMMptcpFlags;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_connection_get_mud_url(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_connection_get_multi_connect(setting: *mut NMSettingConnection) -> NMConnectionMultiConnect;
    pub fn nm_setting_connection_get_num_permissions(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_num_secondaries(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_permission(setting: *mut NMSettingConnection, idx: u32, out_ptype: *mut *const c_char, out_pitem: *mut *const c_char, out_detail: *mut *const c_char) -> gboolean;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_connection_get_port_type(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_read_only(setting: *mut NMSettingConnection) -> gboolean;
    pub fn nm_setting_connection_get_secondary(setting: *mut NMSettingConnection, idx: u32) -> *const c_char;
    pub fn nm_setting_connection_get_slave_type(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_setting_connection_get_stable_id(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_timestamp(setting: *mut NMSettingConnection) -> u64;
    pub fn nm_setting_connection_get_uuid(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    pub fn nm_setting_connection_get_wait_activation_delay(setting: *mut NMSettingConnection) -> i32;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_setting_connection_get_wait_device_timeout(setting: *mut NMSettingConnection) -> i32;
    pub fn nm_setting_connection_get_zone(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_is_slave_type(setting: *mut NMSettingConnection, type_: *const c_char) -> gboolean;
    pub fn nm_setting_connection_permissions_user_allowed(setting: *mut NMSettingConnection, uname: *const c_char) -> gboolean;
    pub fn nm_setting_connection_remove_permission(setting: *mut NMSettingConnection, idx: u32);
    pub fn nm_setting_connection_remove_permission_by_value(setting: *mut NMSettingConnection, ptype: *const c_char, pitem: *const c_char, detail: *const c_char) -> gboolean;
    pub fn nm_setting_connection_remove_secondary(setting: *mut NMSettingConnection, idx: u32);
    pub fn nm_setting_connection_remove_secondary_by_value(setting: *mut NMSettingConnection, sec_uuid: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingDcb
    //=========================================================================
    pub fn nm_setting_dcb_get_type() -> GType;
    pub fn nm_setting_dcb_new() -> *mut NMSetting;
    pub fn nm_setting_dcb_get_app_fcoe_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_fcoe_mode(setting: *mut NMSettingDcb) -> *const c_char;
    pub fn nm_setting_dcb_get_app_fcoe_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_app_fip_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_fip_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_app_iscsi_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_iscsi_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_priority_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_flow_control(setting: *mut NMSettingDcb, user_priority: c_uint) -> gboolean;
    pub fn nm_setting_dcb_get_priority_flow_control_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_priority_group_bandwidth(setting: *mut NMSettingDcb, group_id: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_group_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_priority_group_id(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_strict_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint) -> gboolean;
    pub fn nm_setting_dcb_get_priority_traffic_class(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_set_priority_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint, bandwidth_percent: c_uint);
    pub fn nm_setting_dcb_set_priority_flow_control(setting: *mut NMSettingDcb, user_priority: c_uint, enabled: gboolean);
    pub fn nm_setting_dcb_set_priority_group_bandwidth(setting: *mut NMSettingDcb, group_id: c_uint, bandwidth_percent: c_uint);
    pub fn nm_setting_dcb_set_priority_group_id(setting: *mut NMSettingDcb, user_priority: c_uint, group_id: c_uint);
    pub fn nm_setting_dcb_set_priority_strict_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint, strict: gboolean);
    pub fn nm_setting_dcb_set_priority_traffic_class(setting: *mut NMSettingDcb, user_priority: c_uint, traffic_class: c_uint);

    //=========================================================================
    // NMSettingDummy
    //=========================================================================
    pub fn nm_setting_dummy_get_type() -> GType;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_dummy_new() -> *mut NMSetting;

    //=========================================================================
    // NMSettingEthtool
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_ethtool_get_type() -> GType;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_ethtool_new() -> *mut NMSetting;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_ethtool_clear_features(setting: *mut NMSettingEthtool);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_ethtool_get_feature(setting: *mut NMSettingEthtool, optname: *const c_char) -> NMTernary;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_setting_ethtool_get_optnames(setting: *mut NMSettingEthtool, out_length: *mut c_uint) -> *mut *const c_char;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_ethtool_set_feature(setting: *mut NMSettingEthtool, optname: *const c_char, value: NMTernary);

    //=========================================================================
    // NMSettingGeneric
    //=========================================================================
    pub fn nm_setting_generic_get_type() -> GType;
    pub fn nm_setting_generic_new() -> *mut NMSetting;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_generic_get_device_handler(setting: *mut NMSettingGeneric) -> *const c_char;

    //=========================================================================
    // NMSettingGsm
    //=========================================================================
    pub fn nm_setting_gsm_get_type() -> GType;
    pub fn nm_setting_gsm_new() -> *mut NMSetting;
    pub fn nm_setting_gsm_get_apn(setting: *mut NMSettingGsm) -> *const c_char;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_setting_gsm_get_auto_config(setting: *mut NMSettingGsm) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_gsm_get_device_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_home_only(setting: *mut NMSettingGsm) -> gboolean;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_gsm_get_initial_eps_apn(setting: *mut NMSettingGsm) -> *const c_char;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_gsm_get_initial_eps_config(setting: *mut NMSettingGsm) -> gboolean;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_gsm_get_mtu(setting: *mut NMSettingGsm) -> u32;
    pub fn nm_setting_gsm_get_network_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_number(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_password(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_password_flags(setting: *mut NMSettingGsm) -> NMSettingSecretFlags;
    pub fn nm_setting_gsm_get_pin(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_pin_flags(setting: *mut NMSettingGsm) -> NMSettingSecretFlags;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_gsm_get_sim_id(setting: *mut NMSettingGsm) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_gsm_get_sim_operator_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_username(setting: *mut NMSettingGsm) -> *const c_char;

    //=========================================================================
    // NMSettingHostname
    //=========================================================================
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_hostname_get_type() -> GType;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_hostname_new() -> *mut NMSetting;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_hostname_get_from_dhcp(setting: *mut NMSettingHostname) -> NMTernary;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_hostname_get_from_dns_lookup(setting: *mut NMSettingHostname) -> NMTernary;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_hostname_get_only_from_default(setting: *mut NMSettingHostname) -> NMTernary;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_hostname_get_priority(setting: *mut NMSettingHostname) -> c_int;

    //=========================================================================
    // NMSettingHsr
    //=========================================================================
    pub fn nm_setting_hsr_get_type() -> GType;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_hsr_new() -> *mut NMSetting;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_hsr_get_multicast_spec(setting: *mut NMSettingHsr) -> u32;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_hsr_get_port1(setting: *mut NMSettingHsr) -> *const c_char;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_hsr_get_port2(setting: *mut NMSettingHsr) -> *const c_char;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_hsr_get_prp(setting: *mut NMSettingHsr) -> gboolean;

    //=========================================================================
    // NMSettingIP4Config
    //=========================================================================
    pub fn nm_setting_ip4_config_get_type() -> GType;
    pub fn nm_setting_ip4_config_new() -> *mut NMSetting;
    pub fn nm_setting_ip4_config_get_dhcp_client_id(setting: *mut NMSettingIP4Config) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip4_config_get_dhcp_fqdn(setting: *mut NMSettingIP4Config) -> *const c_char;
    #[cfg(feature = "v1_28")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_28")))]
    pub fn nm_setting_ip4_config_get_dhcp_vendor_class_identifier(setting: *mut NMSettingIP4Config) -> *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ip4_config_get_link_local(setting: *mut NMSettingIP4Config) -> NMSettingIP4LinkLocal;

    //=========================================================================
    // NMSettingIP6Config
    //=========================================================================
    pub fn nm_setting_ip6_config_get_type() -> GType;
    pub fn nm_setting_ip6_config_new() -> *mut NMSetting;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip6_config_get_addr_gen_mode(setting: *mut NMSettingIP6Config) -> NMSettingIP6ConfigAddrGenMode;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_ip6_config_get_dhcp_duid(setting: *mut NMSettingIP6Config) -> *const c_char;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_ip6_config_get_dhcp_pd_hint(setting: *mut NMSettingIP6Config) -> *const c_char;
    pub fn nm_setting_ip6_config_get_ip6_privacy(setting: *mut NMSettingIP6Config) -> NMSettingIP6ConfigPrivacy;
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    pub fn nm_setting_ip6_config_get_mtu(setting: *mut NMSettingIP6Config) -> u32;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_ip6_config_get_ra_timeout(setting: *mut NMSettingIP6Config) -> i32;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_ip6_config_get_temp_preferred_lifetime(setting: *mut NMSettingIP6Config) -> i32;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_ip6_config_get_temp_valid_lifetime(setting: *mut NMSettingIP6Config) -> i32;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_setting_ip6_config_get_token(setting: *mut NMSettingIP6Config) -> *const c_char;

    //=========================================================================
    // NMSettingIPConfig
    //=========================================================================
    pub fn nm_setting_ip_config_get_type() -> GType;
    pub fn nm_setting_ip_config_add_address(setting: *mut NMSettingIPConfig, address: *mut NMIPAddress) -> gboolean;
    #[cfg(feature = "v1_28")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_28")))]
    pub fn nm_setting_ip_config_add_dhcp_reject_server(setting: *mut NMSettingIPConfig, server: *const c_char);
    pub fn nm_setting_ip_config_add_dns(setting: *mut NMSettingIPConfig, dns: *const c_char) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_add_dns_option(setting: *mut NMSettingIPConfig, dns_option: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_add_dns_search(setting: *mut NMSettingIPConfig, dns_search: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_add_route(setting: *mut NMSettingIPConfig, route: *mut NMIPRoute) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_ip_config_add_routing_rule(setting: *mut NMSettingIPConfig, routing_rule: *mut NMIPRoutingRule);
    pub fn nm_setting_ip_config_clear_addresses(setting: *mut NMSettingIPConfig);
    #[cfg(feature = "v1_28")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_28")))]
    pub fn nm_setting_ip_config_clear_dhcp_reject_servers(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_clear_dns(setting: *mut NMSettingIPConfig);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_clear_dns_options(setting: *mut NMSettingIPConfig, is_set: gboolean);
    pub fn nm_setting_ip_config_clear_dns_searches(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_clear_routes(setting: *mut NMSettingIPConfig);
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_ip_config_clear_routing_rules(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_get_address(setting: *mut NMSettingIPConfig, idx: c_int) -> *mut NMIPAddress;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ip_config_get_auto_route_ext_gw(setting: *mut NMSettingIPConfig) -> NMTernary;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_get_dad_timeout(setting: *mut NMSettingIPConfig) -> c_int;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_ip_config_get_dhcp_dscp(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_dhcp_hostname(setting: *mut NMSettingIPConfig) -> *const c_char;
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn nm_setting_ip_config_get_dhcp_hostname_flags(setting: *mut NMSettingIPConfig) -> NMDhcpHostnameFlags;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ip_config_get_dhcp_iaid(setting: *mut NMSettingIPConfig) -> *const c_char;
    #[cfg(feature = "v1_28")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_28")))]
    pub fn nm_setting_ip_config_get_dhcp_reject_servers(setting: *mut NMSettingIPConfig, out_len: *mut c_uint) -> *const *const c_char;
    pub fn nm_setting_ip_config_get_dhcp_send_hostname(setting: *mut NMSettingIPConfig) -> gboolean;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_ip_config_get_dhcp_send_release(setting: *mut NMSettingIPConfig) -> NMTernary;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_get_dhcp_timeout(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_dns(setting: *mut NMSettingIPConfig, idx: c_int) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_get_dns_option(setting: *mut NMSettingIPConfig, idx: c_uint) -> *const c_char;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_setting_ip_config_get_dns_priority(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_dns_search(setting: *mut NMSettingIPConfig, idx: c_int) -> *const c_char;
    pub fn nm_setting_ip_config_get_gateway(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_ignore_auto_dns(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_ignore_auto_routes(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_may_fail(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_method(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_never_default(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_num_addresses(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_dns(setting: *mut NMSettingIPConfig) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_get_num_dns_options(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_dns_searches(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_routes(setting: *mut NMSettingIPConfig) -> c_uint;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_ip_config_get_num_routing_rules(setting: *mut NMSettingIPConfig) -> c_uint;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_ip_config_get_replace_local_rule(setting: *mut NMSettingIPConfig) -> NMTernary;
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn nm_setting_ip_config_get_required_timeout(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_route(setting: *mut NMSettingIPConfig, idx: c_int) -> *mut NMIPRoute;
    pub fn nm_setting_ip_config_get_route_metric(setting: *mut NMSettingIPConfig) -> i64;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ip_config_get_route_table(setting: *mut NMSettingIPConfig) -> u32;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_ip_config_get_routing_rule(setting: *mut NMSettingIPConfig, idx: c_uint) -> *mut NMIPRoutingRule;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_has_dns_options(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_remove_address(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_address_by_value(setting: *mut NMSettingIPConfig, address: *mut NMIPAddress) -> gboolean;
    #[cfg(feature = "v1_28")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_28")))]
    pub fn nm_setting_ip_config_remove_dhcp_reject_server(setting: *mut NMSettingIPConfig, idx: c_uint);
    pub fn nm_setting_ip_config_remove_dns(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_dns_by_value(setting: *mut NMSettingIPConfig, dns: *const c_char) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_remove_dns_option(setting: *mut NMSettingIPConfig, idx: c_int);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_config_remove_dns_option_by_value(setting: *mut NMSettingIPConfig, dns_option: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_remove_dns_search(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_dns_search_by_value(setting: *mut NMSettingIPConfig, dns_search: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_remove_route(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_route_by_value(setting: *mut NMSettingIPConfig, route: *mut NMIPRoute) -> gboolean;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn nm_setting_ip_config_remove_routing_rule(setting: *mut NMSettingIPConfig, idx: c_uint);

    //=========================================================================
    // NMSettingIPTunnel
    //=========================================================================
    pub fn nm_setting_ip_tunnel_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_new() -> *mut NMSetting;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ip_tunnel_get_encapsulation_limit(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_ip_tunnel_get_flags(setting: *mut NMSettingIPTunnel) -> NMIPTunnelFlags;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ip_tunnel_get_flow_label(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ip_tunnel_get_fwmark(setting: *mut NMSettingIPTunnel) -> u32;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_input_key(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_local(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_mode(setting: *mut NMSettingIPTunnel) -> NMIPTunnelMode;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_mtu(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_output_key(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_parent(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_path_mtu_discovery(setting: *mut NMSettingIPTunnel) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_remote(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_tos(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_ip_tunnel_get_ttl(setting: *mut NMSettingIPTunnel) -> c_uint;

    //=========================================================================
    // NMSettingInfiniband
    //=========================================================================
    pub fn nm_setting_infiniband_get_type() -> GType;
    pub fn nm_setting_infiniband_new() -> *mut NMSetting;
    pub fn nm_setting_infiniband_get_mac_address(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_mtu(setting: *mut NMSettingInfiniband) -> u32;
    pub fn nm_setting_infiniband_get_p_key(setting: *mut NMSettingInfiniband) -> c_int;
    pub fn nm_setting_infiniband_get_parent(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_transport_mode(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_virtual_interface_name(setting: *mut NMSettingInfiniband) -> *const c_char;

    //=========================================================================
    // NMSettingLink
    //=========================================================================
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_link_get_type() -> GType;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_link_new() -> *mut NMSetting;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_link_get_gro_max_size(setting: *mut NMSettingLink) -> i64;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_link_get_gso_max_segments(setting: *mut NMSettingLink) -> i64;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_link_get_gso_max_size(setting: *mut NMSettingLink) -> i64;
    #[cfg(feature = "v1_44")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_44")))]
    pub fn nm_setting_link_get_tx_queue_length(setting: *mut NMSettingLink) -> i64;

    //=========================================================================
    // NMSettingLoopback
    //=========================================================================
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_loopback_get_type() -> GType;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_loopback_new() -> *mut NMSetting;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_loopback_get_mtu(setting: *mut NMSettingLoopback) -> u32;

    //=========================================================================
    // NMSettingMacsec
    //=========================================================================
    pub fn nm_setting_macsec_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_new() -> *mut NMSetting;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_get_encrypt(setting: *mut NMSettingMacsec) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_get_mka_cak(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_get_mka_cak_flags(setting: *mut NMSettingMacsec) -> NMSettingSecretFlags;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_get_mka_ckn(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_get_mode(setting: *mut NMSettingMacsec) -> NMSettingMacsecMode;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_macsec_get_offload(setting: *mut NMSettingMacsec) -> NMSettingMacsecOffload;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_get_parent(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_get_port(setting: *mut NMSettingMacsec) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_macsec_get_send_sci(setting: *mut NMSettingMacsec) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_macsec_get_validation(setting: *mut NMSettingMacsec) -> NMSettingMacsecValidation;

    //=========================================================================
    // NMSettingMacvlan
    //=========================================================================
    pub fn nm_setting_macvlan_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_macvlan_new() -> *mut NMSetting;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_macvlan_get_mode(setting: *mut NMSettingMacvlan) -> NMSettingMacvlanMode;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_macvlan_get_parent(setting: *mut NMSettingMacvlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_macvlan_get_promiscuous(setting: *mut NMSettingMacvlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_macvlan_get_tap(setting: *mut NMSettingMacvlan) -> gboolean;

    //=========================================================================
    // NMSettingMatch
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_match_get_type() -> GType;
    #[cfg(feature = "v1_32")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_32")))]
    pub fn nm_setting_match_new() -> *mut NMSetting;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_add_driver(setting: *mut NMSettingMatch, driver: *const c_char);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_match_add_interface_name(setting: *mut NMSettingMatch, interface_name: *const c_char);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_add_kernel_command_line(setting: *mut NMSettingMatch, kernel_command_line: *const c_char);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_add_path(setting: *mut NMSettingMatch, path: *const c_char);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_clear_drivers(setting: *mut NMSettingMatch);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_match_clear_interface_names(setting: *mut NMSettingMatch);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_clear_kernel_command_lines(setting: *mut NMSettingMatch);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_clear_paths(setting: *mut NMSettingMatch);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_driver(setting: *mut NMSettingMatch, idx: c_uint) -> *const c_char;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_drivers(setting: *mut NMSettingMatch, length: *mut c_uint) -> *const *const c_char;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_match_get_interface_name(setting: *mut NMSettingMatch, idx: c_int) -> *const c_char;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_match_get_interface_names(setting: *mut NMSettingMatch, length: *mut c_uint) -> *const *const c_char;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_kernel_command_line(setting: *mut NMSettingMatch, idx: c_uint) -> *const c_char;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_kernel_command_lines(setting: *mut NMSettingMatch, length: *mut c_uint) -> *const *const c_char;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_num_drivers(setting: *mut NMSettingMatch) -> c_uint;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_match_get_num_interface_names(setting: *mut NMSettingMatch) -> c_uint;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_num_kernel_command_lines(setting: *mut NMSettingMatch) -> c_uint;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_num_paths(setting: *mut NMSettingMatch) -> c_uint;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_path(setting: *mut NMSettingMatch, idx: c_uint) -> *const c_char;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_get_paths(setting: *mut NMSettingMatch, length: *mut c_uint) -> *const *const c_char;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_remove_driver(setting: *mut NMSettingMatch, idx: c_uint);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_remove_driver_by_value(setting: *mut NMSettingMatch, driver: *const c_char) -> gboolean;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_match_remove_interface_name(setting: *mut NMSettingMatch, idx: c_int);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_match_remove_interface_name_by_value(setting: *mut NMSettingMatch, interface_name: *const c_char) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_remove_kernel_command_line(setting: *mut NMSettingMatch, idx: c_uint);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_remove_kernel_command_line_by_value(setting: *mut NMSettingMatch, kernel_command_line: *const c_char) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_remove_path(setting: *mut NMSettingMatch, idx: c_uint);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_setting_match_remove_path_by_value(setting: *mut NMSettingMatch, path: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingOlpcMesh
    //=========================================================================
    pub fn nm_setting_olpc_mesh_get_type() -> GType;
    pub fn nm_setting_olpc_mesh_new() -> *mut NMSetting;
    pub fn nm_setting_olpc_mesh_get_channel(setting: *mut NMSettingOlpcMesh) -> u32;
    pub fn nm_setting_olpc_mesh_get_dhcp_anycast_address(setting: *mut NMSettingOlpcMesh) -> *const c_char;
    pub fn nm_setting_olpc_mesh_get_ssid(setting: *mut NMSettingOlpcMesh) -> *mut glib::GBytes;

    //=========================================================================
    // NMSettingOvsBridge
    //=========================================================================
    pub fn nm_setting_ovs_bridge_get_type() -> GType;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_bridge_new() -> *mut NMSetting;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_bridge_get_datapath_type(self_: *mut NMSettingOvsBridge) -> *const c_char;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_bridge_get_fail_mode(self_: *mut NMSettingOvsBridge) -> *const c_char;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_bridge_get_mcast_snooping_enable(self_: *mut NMSettingOvsBridge) -> gboolean;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_bridge_get_rstp_enable(self_: *mut NMSettingOvsBridge) -> gboolean;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_bridge_get_stp_enable(self_: *mut NMSettingOvsBridge) -> gboolean;

    //=========================================================================
    // NMSettingOvsDpdk
    //=========================================================================
    pub fn nm_setting_ovs_dpdk_get_type() -> GType;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_setting_ovs_dpdk_new() -> *mut NMSetting;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_setting_ovs_dpdk_get_devargs(self_: *mut NMSettingOvsDpdk) -> *const c_char;
    #[cfg(feature = "v1_36")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_36")))]
    pub fn nm_setting_ovs_dpdk_get_n_rxq(self_: *mut NMSettingOvsDpdk) -> u32;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_dpdk_get_n_rxq_desc(self_: *mut NMSettingOvsDpdk) -> u32;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_dpdk_get_n_txq_desc(self_: *mut NMSettingOvsDpdk) -> u32;

    //=========================================================================
    // NMSettingOvsExternalIDs
    //=========================================================================
    pub fn nm_setting_ovs_external_ids_get_type() -> GType;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_ovs_external_ids_new() -> *mut NMSettingOvsExternalIDs;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_ovs_external_ids_check_key(key: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_ovs_external_ids_check_val(val: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_ovs_external_ids_get_data(setting: *mut NMSettingOvsExternalIDs, key: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_ovs_external_ids_get_data_keys(setting: *mut NMSettingOvsExternalIDs, out_len: *mut c_uint) -> *const *const c_char;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_ovs_external_ids_set_data(setting: *mut NMSettingOvsExternalIDs, key: *const c_char, val: *const c_char);

    //=========================================================================
    // NMSettingOvsInterface
    //=========================================================================
    pub fn nm_setting_ovs_interface_get_type() -> GType;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_interface_new() -> *mut NMSetting;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_interface_get_interface_type(self_: *mut NMSettingOvsInterface) -> *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_interface_get_ofport_request(self_: *mut NMSettingOvsInterface) -> u32;

    //=========================================================================
    // NMSettingOvsOtherConfig
    //=========================================================================
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_other_config_get_type() -> GType;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_other_config_new() -> *mut NMSettingOvsOtherConfig;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_other_config_get_data(setting: *mut NMSettingOvsOtherConfig, key: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_other_config_get_data_keys(setting: *mut NMSettingOvsOtherConfig, out_len: *mut c_uint) -> *const *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_other_config_set_data(setting: *mut NMSettingOvsOtherConfig, key: *const c_char, val: *const c_char);

    //=========================================================================
    // NMSettingOvsPatch
    //=========================================================================
    pub fn nm_setting_ovs_patch_get_type() -> GType;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_patch_new() -> *mut NMSetting;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_patch_get_peer(self_: *mut NMSettingOvsPatch) -> *const c_char;

    //=========================================================================
    // NMSettingOvsPort
    //=========================================================================
    pub fn nm_setting_ovs_port_get_type() -> GType;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_port_new() -> *mut NMSetting;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_port_add_trunk(setting: *mut NMSettingOvsPort, trunk: *mut NMRange);
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_port_clear_trunks(setting: *mut NMSettingOvsPort);
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_port_get_bond_downdelay(self_: *mut NMSettingOvsPort) -> c_uint;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_port_get_bond_mode(self_: *mut NMSettingOvsPort) -> *const c_char;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_port_get_bond_updelay(self_: *mut NMSettingOvsPort) -> c_uint;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_port_get_lacp(self_: *mut NMSettingOvsPort) -> *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_port_get_num_trunks(setting: *mut NMSettingOvsPort) -> c_uint;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_port_get_tag(self_: *mut NMSettingOvsPort) -> c_uint;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_port_get_trunk(setting: *mut NMSettingOvsPort, idx: c_uint) -> *mut NMRange;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_ovs_port_get_vlan_mode(self_: *mut NMSettingOvsPort) -> *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_port_remove_trunk(setting: *mut NMSettingOvsPort, idx: c_uint);
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_ovs_port_remove_trunk_by_value(setting: *mut NMSettingOvsPort, start: c_uint, end: c_uint) -> gboolean;

    //=========================================================================
    // NMSettingPpp
    //=========================================================================
    pub fn nm_setting_ppp_get_type() -> GType;
    pub fn nm_setting_ppp_new() -> *mut NMSetting;
    pub fn nm_setting_ppp_get_baud(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_crtscts(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_lcp_echo_failure(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_lcp_echo_interval(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_mppe_stateful(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_mru(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_mtu(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_no_vj_comp(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_noauth(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_nobsdcomp(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_nodeflate(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_chap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_eap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_mschap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_mschapv2(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_pap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_require_mppe(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_require_mppe_128(setting: *mut NMSettingPpp) -> gboolean;

    //=========================================================================
    // NMSettingPppoe
    //=========================================================================
    pub fn nm_setting_pppoe_get_type() -> GType;
    pub fn nm_setting_pppoe_new() -> *mut NMSetting;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_pppoe_get_parent(setting: *mut NMSettingPppoe) -> *const c_char;
    pub fn nm_setting_pppoe_get_password(setting: *mut NMSettingPppoe) -> *const c_char;
    pub fn nm_setting_pppoe_get_password_flags(setting: *mut NMSettingPppoe) -> NMSettingSecretFlags;
    pub fn nm_setting_pppoe_get_service(setting: *mut NMSettingPppoe) -> *const c_char;
    pub fn nm_setting_pppoe_get_username(setting: *mut NMSettingPppoe) -> *const c_char;

    //=========================================================================
    // NMSettingProxy
    //=========================================================================
    pub fn nm_setting_proxy_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_proxy_new() -> *mut NMSetting;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_proxy_get_browser_only(setting: *mut NMSettingProxy) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_proxy_get_method(setting: *mut NMSettingProxy) -> NMSettingProxyMethod;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_proxy_get_pac_script(setting: *mut NMSettingProxy) -> *const c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_setting_proxy_get_pac_url(setting: *mut NMSettingProxy) -> *const c_char;

    //=========================================================================
    // NMSettingSerial
    //=========================================================================
    pub fn nm_setting_serial_get_type() -> GType;
    pub fn nm_setting_serial_new() -> *mut NMSetting;
    pub fn nm_setting_serial_get_baud(setting: *mut NMSettingSerial) -> c_uint;
    pub fn nm_setting_serial_get_bits(setting: *mut NMSettingSerial) -> c_uint;
    pub fn nm_setting_serial_get_parity(setting: *mut NMSettingSerial) -> NMSettingSerialParity;
    pub fn nm_setting_serial_get_send_delay(setting: *mut NMSettingSerial) -> u64;
    pub fn nm_setting_serial_get_stopbits(setting: *mut NMSettingSerial) -> c_uint;

    //=========================================================================
    // NMSettingSriov
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_get_type() -> GType;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_new() -> *mut NMSetting;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_add_vf(setting: *mut NMSettingSriov, vf: *mut NMSriovVF);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_clear_vfs(setting: *mut NMSettingSriov);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_get_autoprobe_drivers(setting: *mut NMSettingSriov) -> NMTernary;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_sriov_get_eswitch_encap_mode(setting: *mut NMSettingSriov) -> NMSriovEswitchEncapMode;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_sriov_get_eswitch_inline_mode(setting: *mut NMSettingSriov) -> NMSriovEswitchInlineMode;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_setting_sriov_get_eswitch_mode(setting: *mut NMSettingSriov) -> NMSriovEswitchMode;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_get_num_vfs(setting: *mut NMSettingSriov) -> c_uint;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_get_total_vfs(setting: *mut NMSettingSriov) -> c_uint;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_get_vf(setting: *mut NMSettingSriov, idx: c_uint) -> *mut NMSriovVF;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_remove_vf(setting: *mut NMSettingSriov, idx: c_uint);
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_sriov_remove_vf_by_index(setting: *mut NMSettingSriov, index: c_uint) -> gboolean;

    //=========================================================================
    // NMSettingTCConfig
    //=========================================================================
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_get_type() -> GType;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_new() -> *mut NMSetting;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_add_qdisc(setting: *mut NMSettingTCConfig, qdisc: *mut NMTCQdisc) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_add_tfilter(setting: *mut NMSettingTCConfig, tfilter: *mut NMTCTfilter) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_clear_qdiscs(setting: *mut NMSettingTCConfig);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_clear_tfilters(setting: *mut NMSettingTCConfig);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_get_num_qdiscs(setting: *mut NMSettingTCConfig) -> c_uint;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_get_num_tfilters(setting: *mut NMSettingTCConfig) -> c_uint;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_get_qdisc(setting: *mut NMSettingTCConfig, idx: c_uint) -> *mut NMTCQdisc;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_get_tfilter(setting: *mut NMSettingTCConfig, idx: c_uint) -> *mut NMTCTfilter;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_remove_qdisc(setting: *mut NMSettingTCConfig, idx: c_uint);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_remove_qdisc_by_value(setting: *mut NMSettingTCConfig, qdisc: *mut NMTCQdisc) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_remove_tfilter(setting: *mut NMSettingTCConfig, idx: c_uint);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_tc_config_remove_tfilter_by_value(setting: *mut NMSettingTCConfig, tfilter: *mut NMTCTfilter) -> gboolean;

    //=========================================================================
    // NMSettingTeam
    //=========================================================================
    pub fn nm_setting_team_get_type() -> GType;
    pub fn nm_setting_team_new() -> *mut NMSetting;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_add_link_watcher(setting: *mut NMSettingTeam, link_watcher: *mut NMTeamLinkWatcher) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_add_runner_tx_hash(setting: *mut NMSettingTeam, txhash: *const c_char) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_clear_link_watchers(setting: *mut NMSettingTeam);
    pub fn nm_setting_team_get_config(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_link_watcher(setting: *mut NMSettingTeam, idx: c_uint) -> *mut NMTeamLinkWatcher;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_mcast_rejoin_count(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_mcast_rejoin_interval(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_notify_peers_count(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_notify_peers_interval(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_num_link_watchers(setting: *mut NMSettingTeam) -> c_uint;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_num_runner_tx_hash(setting: *mut NMSettingTeam) -> c_uint;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_active(setting: *mut NMSettingTeam) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_agg_select_policy(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_fast_rate(setting: *mut NMSettingTeam) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_hwaddr_policy(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_min_ports(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_sys_prio(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_tx_balancer(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_tx_balancer_interval(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_get_runner_tx_hash(setting: *mut NMSettingTeam, idx: c_uint) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_remove_link_watcher(setting: *mut NMSettingTeam, idx: c_uint);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_remove_link_watcher_by_value(setting: *mut NMSettingTeam, link_watcher: *mut NMTeamLinkWatcher) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_remove_runner_tx_hash(setting: *mut NMSettingTeam, idx: c_uint);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_remove_runner_tx_hash_by_value(setting: *mut NMSettingTeam, txhash: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingTeamPort
    //=========================================================================
    pub fn nm_setting_team_port_get_type() -> GType;
    pub fn nm_setting_team_port_new() -> *mut NMSetting;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_add_link_watcher(setting: *mut NMSettingTeamPort, link_watcher: *mut NMTeamLinkWatcher) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_clear_link_watchers(setting: *mut NMSettingTeamPort);
    pub fn nm_setting_team_port_get_config(setting: *mut NMSettingTeamPort) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_get_lacp_key(setting: *mut NMSettingTeamPort) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_get_lacp_prio(setting: *mut NMSettingTeamPort) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_get_link_watcher(setting: *mut NMSettingTeamPort, idx: c_uint) -> *mut NMTeamLinkWatcher;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_get_num_link_watchers(setting: *mut NMSettingTeamPort) -> c_uint;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_get_prio(setting: *mut NMSettingTeamPort) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_get_queue_id(setting: *mut NMSettingTeamPort) -> c_int;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_get_sticky(setting: *mut NMSettingTeamPort) -> gboolean;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_remove_link_watcher(setting: *mut NMSettingTeamPort, idx: c_uint);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_team_port_remove_link_watcher_by_value(setting: *mut NMSettingTeamPort, link_watcher: *mut NMTeamLinkWatcher) -> gboolean;

    //=========================================================================
    // NMSettingTun
    //=========================================================================
    pub fn nm_setting_tun_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_tun_new() -> *mut NMSetting;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_tun_get_group(setting: *mut NMSettingTun) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_tun_get_mode(setting: *mut NMSettingTun) -> NMSettingTunMode;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_tun_get_multi_queue(setting: *mut NMSettingTun) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_tun_get_owner(setting: *mut NMSettingTun) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_tun_get_pi(setting: *mut NMSettingTun) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_tun_get_vnet_hdr(setting: *mut NMSettingTun) -> gboolean;

    //=========================================================================
    // NMSettingUser
    //=========================================================================
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_user_get_type() -> GType;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_user_new() -> *mut NMSetting;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_user_check_key(key: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_user_check_val(val: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_user_get_data(setting: *mut NMSettingUser, key: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_user_get_keys(setting: *mut NMSettingUser, out_len: *mut c_uint) -> *const *const c_char;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_setting_user_set_data(setting: *mut NMSettingUser, key: *const c_char, val: *const c_char, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSettingVeth
    //=========================================================================
    pub fn nm_setting_veth_get_type() -> GType;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_veth_new() -> *mut NMSetting;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_setting_veth_get_peer(setting: *mut NMSettingVeth) -> *const c_char;

    //=========================================================================
    // NMSettingVlan
    //=========================================================================
    pub fn nm_setting_vlan_get_type() -> GType;
    pub fn nm_setting_vlan_new() -> *mut NMSetting;
    pub fn nm_setting_vlan_add_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, from: u32, to: u32) -> gboolean;
    pub fn nm_setting_vlan_add_priority_str(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, str: *const c_char) -> gboolean;
    pub fn nm_setting_vlan_clear_priorities(setting: *mut NMSettingVlan, map: NMVlanPriorityMap);
    pub fn nm_setting_vlan_get_flags(setting: *mut NMSettingVlan) -> u32;
    pub fn nm_setting_vlan_get_id(setting: *mut NMSettingVlan) -> u32;
    pub fn nm_setting_vlan_get_num_priorities(setting: *mut NMSettingVlan, map: NMVlanPriorityMap) -> i32;
    pub fn nm_setting_vlan_get_parent(setting: *mut NMSettingVlan) -> *const c_char;
    pub fn nm_setting_vlan_get_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, idx: u32, out_from: *mut u32, out_to: *mut u32) -> gboolean;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_vlan_get_protocol(setting: *mut NMSettingVlan) -> *const c_char;
    pub fn nm_setting_vlan_remove_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, idx: u32);
    pub fn nm_setting_vlan_remove_priority_by_value(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, from: u32, to: u32) -> gboolean;
    pub fn nm_setting_vlan_remove_priority_str_by_value(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, str: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingVpn
    //=========================================================================
    pub fn nm_setting_vpn_get_type() -> GType;
    pub fn nm_setting_vpn_new() -> *mut NMSetting;
    pub fn nm_setting_vpn_add_data_item(setting: *mut NMSettingVpn, key: *const c_char, item: *const c_char);
    pub fn nm_setting_vpn_add_secret(setting: *mut NMSettingVpn, key: *const c_char, secret: *const c_char);
    pub fn nm_setting_vpn_foreach_data_item(setting: *mut NMSettingVpn, func: NMVpnIterFunc, user_data: gpointer);
    pub fn nm_setting_vpn_foreach_secret(setting: *mut NMSettingVpn, func: NMVpnIterFunc, user_data: gpointer);
    pub fn nm_setting_vpn_get_data_item(setting: *mut NMSettingVpn, key: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_vpn_get_data_keys(setting: *mut NMSettingVpn, out_length: *mut c_uint) -> *mut *const c_char;
    pub fn nm_setting_vpn_get_num_data_items(setting: *mut NMSettingVpn) -> u32;
    pub fn nm_setting_vpn_get_num_secrets(setting: *mut NMSettingVpn) -> u32;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_vpn_get_persistent(setting: *mut NMSettingVpn) -> gboolean;
    pub fn nm_setting_vpn_get_secret(setting: *mut NMSettingVpn, key: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_vpn_get_secret_keys(setting: *mut NMSettingVpn, out_length: *mut c_uint) -> *mut *const c_char;
    pub fn nm_setting_vpn_get_service_type(setting: *mut NMSettingVpn) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vpn_get_timeout(setting: *mut NMSettingVpn) -> u32;
    pub fn nm_setting_vpn_get_user_name(setting: *mut NMSettingVpn) -> *const c_char;
    pub fn nm_setting_vpn_remove_data_item(setting: *mut NMSettingVpn, key: *const c_char) -> gboolean;
    pub fn nm_setting_vpn_remove_secret(setting: *mut NMSettingVpn, key: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingVrf
    //=========================================================================
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_vrf_get_type() -> GType;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_vrf_new() -> *mut NMSetting;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn nm_setting_vrf_get_table(setting: *mut NMSettingVrf) -> u32;

    //=========================================================================
    // NMSettingVxlan
    //=========================================================================
    pub fn nm_setting_vxlan_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_new() -> *mut NMSetting;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_ageing(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_destination_port(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_id(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_l2_miss(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_l3_miss(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_learning(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_limit(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_local(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_parent(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_proxy(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_remote(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_rsc(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_source_port_max(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_source_port_min(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_tos(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_vxlan_get_ttl(setting: *mut NMSettingVxlan) -> c_uint;

    //=========================================================================
    // NMSettingWifiP2P
    //=========================================================================
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wifi_p2p_get_type() -> GType;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wifi_p2p_new() -> *mut NMSetting;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wifi_p2p_get_peer(setting: *mut NMSettingWifiP2P) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wifi_p2p_get_wfd_ies(setting: *mut NMSettingWifiP2P) -> *mut glib::GBytes;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wifi_p2p_get_wps_method(setting: *mut NMSettingWifiP2P) -> NMSettingWirelessSecurityWpsMethod;

    //=========================================================================
    // NMSettingWimax
    //=========================================================================
    pub fn nm_setting_wimax_get_type() -> GType;
    pub fn nm_setting_wimax_new() -> *mut NMSetting;
    pub fn nm_setting_wimax_get_mac_address(setting: *mut NMSettingWimax) -> *const c_char;
    pub fn nm_setting_wimax_get_network_name(setting: *mut NMSettingWimax) -> *const c_char;

    //=========================================================================
    // NMSettingWireGuard
    //=========================================================================
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_type() -> GType;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_new() -> *mut NMSetting;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_append_peer(self_: *mut NMSettingWireGuard, peer: *mut NMWireGuardPeer);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_clear_peers(self_: *mut NMSettingWireGuard) -> c_uint;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_fwmark(self_: *mut NMSettingWireGuard) -> u32;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_setting_wireguard_get_ip4_auto_default_route(self_: *mut NMSettingWireGuard) -> NMTernary;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_setting_wireguard_get_ip6_auto_default_route(self_: *mut NMSettingWireGuard) -> NMTernary;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_listen_port(self_: *mut NMSettingWireGuard) -> u16;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_mtu(self_: *mut NMSettingWireGuard) -> u32;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_peer(self_: *mut NMSettingWireGuard, idx: c_uint) -> *mut NMWireGuardPeer;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_peer_by_public_key(self_: *mut NMSettingWireGuard, public_key: *const c_char, out_idx: *mut c_uint) -> *mut NMWireGuardPeer;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_peer_routes(self_: *mut NMSettingWireGuard) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_peers_len(self_: *mut NMSettingWireGuard) -> c_uint;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_private_key(self_: *mut NMSettingWireGuard) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_get_private_key_flags(self_: *mut NMSettingWireGuard) -> NMSettingSecretFlags;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_remove_peer(self_: *mut NMSettingWireGuard, idx: c_uint) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_setting_wireguard_set_peer(self_: *mut NMSettingWireGuard, peer: *mut NMWireGuardPeer, idx: c_uint);

    //=========================================================================
    // NMSettingWired
    //=========================================================================
    pub fn nm_setting_wired_get_type() -> GType;
    pub fn nm_setting_wired_new() -> *mut NMSetting;
    pub fn nm_setting_wired_add_mac_blacklist_item(setting: *mut NMSettingWired, mac: *const c_char) -> gboolean;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wired_add_mac_denylist_item(setting: *mut NMSettingWired, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wired_add_s390_option(setting: *mut NMSettingWired, key: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_wired_clear_mac_blacklist_items(setting: *mut NMSettingWired);
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wired_clear_mac_denylist_items(setting: *mut NMSettingWired);
    #[cfg(feature = "v1_32")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_32")))]
    pub fn nm_setting_wired_get_accept_all_mac_addresses(setting: *mut NMSettingWired) -> NMTernary;
    pub fn nm_setting_wired_get_auto_negotiate(setting: *mut NMSettingWired) -> gboolean;
    pub fn nm_setting_wired_get_cloned_mac_address(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_duplex(setting: *mut NMSettingWired) -> *const c_char;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_setting_wired_get_generate_mac_address_mask(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_mac_address(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_mac_address_blacklist(setting: *mut NMSettingWired) -> *const *const c_char;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wired_get_mac_address_denylist(setting: *mut NMSettingWired) -> *const *const c_char;
    pub fn nm_setting_wired_get_mac_blacklist_item(setting: *mut NMSettingWired, idx: u32) -> *const c_char;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wired_get_mac_denylist_item(setting: *mut NMSettingWired, idx: u32) -> *const c_char;
    pub fn nm_setting_wired_get_mtu(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_num_mac_blacklist_items(setting: *mut NMSettingWired) -> u32;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wired_get_num_mac_denylist_items(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_num_s390_options(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_port(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_s390_nettype(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_s390_option(setting: *mut NMSettingWired, idx: u32, out_key: *mut *const c_char, out_value: *mut *const c_char) -> gboolean;
    pub fn nm_setting_wired_get_s390_option_by_key(setting: *mut NMSettingWired, key: *const c_char) -> *const c_char;
    pub fn nm_setting_wired_get_s390_subchannels(setting: *mut NMSettingWired) -> *const *const c_char;
    pub fn nm_setting_wired_get_speed(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_valid_s390_options(setting: *mut NMSettingWired) -> *mut *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_wired_get_wake_on_lan(setting: *mut NMSettingWired) -> NMSettingWiredWakeOnLan;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_wired_get_wake_on_lan_password(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_remove_mac_blacklist_item(setting: *mut NMSettingWired, idx: u32);
    pub fn nm_setting_wired_remove_mac_blacklist_item_by_value(setting: *mut NMSettingWired, mac: *const c_char) -> gboolean;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wired_remove_mac_denylist_item(setting: *mut NMSettingWired, idx: u32);
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wired_remove_mac_denylist_item_by_value(setting: *mut NMSettingWired, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wired_remove_s390_option(setting: *mut NMSettingWired, key: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingWireless
    //=========================================================================
    pub fn nm_setting_wireless_get_type() -> GType;
    pub fn nm_setting_wireless_new() -> *mut NMSetting;
    pub fn nm_setting_wireless_add_mac_blacklist_item(setting: *mut NMSettingWireless, mac: *const c_char) -> gboolean;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wireless_add_mac_denylist_item(setting: *mut NMSettingWireless, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_add_seen_bssid(setting: *mut NMSettingWireless, bssid: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_ap_security_compatible(s_wireless: *mut NMSettingWireless, s_wireless_sec: *mut NMSettingWirelessSecurity, ap_flags: NM80211ApFlags, ap_wpa: NM80211ApSecurityFlags, ap_rsn: NM80211ApSecurityFlags, ap_mode: NM80211Mode) -> gboolean;
    pub fn nm_setting_wireless_clear_mac_blacklist_items(setting: *mut NMSettingWireless);
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wireless_clear_mac_denylist_items(setting: *mut NMSettingWireless);
    #[cfg(feature = "v1_28")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_28")))]
    pub fn nm_setting_wireless_get_ap_isolation(setting: *mut NMSettingWireless) -> NMTernary;
    pub fn nm_setting_wireless_get_band(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_bssid(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_channel(setting: *mut NMSettingWireless) -> u32;
    #[cfg(feature = "v1_50")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
    pub fn nm_setting_wireless_get_channel_width(setting: *mut NMSettingWireless) -> NMSettingWirelessChannelWidth;
    pub fn nm_setting_wireless_get_cloned_mac_address(setting: *mut NMSettingWireless) -> *const c_char;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_setting_wireless_get_generate_mac_address_mask(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_hidden(setting: *mut NMSettingWireless) -> gboolean;
    pub fn nm_setting_wireless_get_mac_address(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_mac_address_blacklist(setting: *mut NMSettingWireless) -> *const *const c_char;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wireless_get_mac_address_denylist(setting: *mut NMSettingWireless) -> *const *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_wireless_get_mac_address_randomization(setting: *mut NMSettingWireless) -> NMSettingMacRandomization;
    pub fn nm_setting_wireless_get_mac_blacklist_item(setting: *mut NMSettingWireless, idx: u32) -> *const c_char;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wireless_get_mac_denylist_item(setting: *mut NMSettingWireless, idx: u32) -> *const c_char;
    pub fn nm_setting_wireless_get_mode(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_mtu(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_num_mac_blacklist_items(setting: *mut NMSettingWireless) -> u32;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wireless_get_num_mac_denylist_items(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_num_seen_bssids(setting: *mut NMSettingWireless) -> u32;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_setting_wireless_get_powersave(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_rate(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_seen_bssid(setting: *mut NMSettingWireless, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_get_ssid(setting: *mut NMSettingWireless) -> *mut glib::GBytes;
    pub fn nm_setting_wireless_get_tx_power(setting: *mut NMSettingWireless) -> u32;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_wireless_get_wake_on_wlan(setting: *mut NMSettingWireless) -> NMSettingWirelessWakeOnWLan;
    pub fn nm_setting_wireless_remove_mac_blacklist_item(setting: *mut NMSettingWireless, idx: u32);
    pub fn nm_setting_wireless_remove_mac_blacklist_item_by_value(setting: *mut NMSettingWireless, mac: *const c_char) -> gboolean;
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wireless_remove_mac_denylist_item(setting: *mut NMSettingWireless, idx: u32);
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn nm_setting_wireless_remove_mac_denylist_item_by_value(setting: *mut NMSettingWireless, mac: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingWirelessSecurity
    //=========================================================================
    pub fn nm_setting_wireless_security_get_type() -> GType;
    pub fn nm_setting_wireless_security_new() -> *mut NMSetting;
    pub fn nm_setting_wireless_security_add_group(setting: *mut NMSettingWirelessSecurity, group: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_add_pairwise(setting: *mut NMSettingWirelessSecurity, pairwise: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_add_proto(setting: *mut NMSettingWirelessSecurity, proto: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_clear_groups(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_clear_pairwise(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_clear_protos(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_get_auth_alg(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_setting_wireless_security_get_fils(setting: *mut NMSettingWirelessSecurity) -> NMSettingWirelessSecurityFils;
    pub fn nm_setting_wireless_security_get_group(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_key_mgmt(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_leap_password(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_leap_password_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_leap_username(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_num_groups(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_num_pairwise(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_num_protos(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_pairwise(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_wireless_security_get_pmf(setting: *mut NMSettingWirelessSecurity) -> NMSettingWirelessSecurityPmf;
    pub fn nm_setting_wireless_security_get_proto(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_psk(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_psk_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_wep_key(setting: *mut NMSettingWirelessSecurity, idx: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_wep_key_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_wep_key_type(setting: *mut NMSettingWirelessSecurity) -> NMWepKeyType;
    pub fn nm_setting_wireless_security_get_wep_tx_keyidx(setting: *mut NMSettingWirelessSecurity) -> u32;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_setting_wireless_security_get_wps_method(setting: *mut NMSettingWirelessSecurity) -> NMSettingWirelessSecurityWpsMethod;
    pub fn nm_setting_wireless_security_remove_group(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_group_by_value(setting: *mut NMSettingWirelessSecurity, group: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_remove_pairwise(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_pairwise_by_value(setting: *mut NMSettingWirelessSecurity, pairwise: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_remove_proto(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_proto_by_value(setting: *mut NMSettingWirelessSecurity, proto: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_set_wep_key(setting: *mut NMSettingWirelessSecurity, idx: u32, key: *const c_char);

    //=========================================================================
    // NMSettingWpan
    //=========================================================================
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_setting_wpan_get_type() -> GType;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_wpan_new() -> *mut NMSetting;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_wpan_get_channel(setting: *mut NMSettingWpan) -> i16;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_wpan_get_mac_address(setting: *mut NMSettingWpan) -> *const c_char;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_wpan_get_page(setting: *mut NMSettingWpan) -> i16;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_wpan_get_pan_id(setting: *mut NMSettingWpan) -> u16;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_setting_wpan_get_short_address(setting: *mut NMSettingWpan) -> u16;

    //=========================================================================
    // NMSimpleConnection
    //=========================================================================
    pub fn nm_simple_connection_get_type() -> GType;
    pub fn nm_simple_connection_new() -> *mut NMConnection;
    pub fn nm_simple_connection_new_clone(connection: *mut NMConnection) -> *mut NMConnection;
    pub fn nm_simple_connection_new_from_dbus(dict: *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut NMConnection;

    //=========================================================================
    // NMVpnConnection
    //=========================================================================
    pub fn nm_vpn_connection_get_type() -> GType;
    pub fn nm_vpn_connection_get_banner(vpn: *mut NMVpnConnection) -> *const c_char;
    pub fn nm_vpn_connection_get_vpn_state(vpn: *mut NMVpnConnection) -> NMVpnConnectionState;

    //=========================================================================
    // NMVpnPluginInfo
    //=========================================================================
    pub fn nm_vpn_plugin_info_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_new_from_file(filename: *const c_char, error: *mut *mut glib::GError) -> *mut NMVpnPluginInfo;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_plugin_info_new_search_file(name: *const c_char, service: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_new_with_data(filename: *const c_char, keyfile: *mut glib::GKeyFile, error: *mut *mut glib::GError) -> *mut NMVpnPluginInfo;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_list_add(list: *mut *mut glib::GSList, plugin_info: *mut NMVpnPluginInfo, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_list_find_by_filename(list: *mut glib::GSList, filename: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_list_find_by_name(list: *mut glib::GSList, name: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_list_find_by_service(list: *mut glib::GSList, service: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_plugin_info_list_find_service_type(list: *mut glib::GSList, name: *const c_char) -> *mut c_char;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_plugin_info_list_get_service_types(list: *mut glib::GSList, only_existing: gboolean, with_abbreviations: gboolean) -> *mut *mut c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_list_load() -> *mut glib::GSList;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_list_remove(list: *mut *mut glib::GSList, plugin_info: *mut NMVpnPluginInfo) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_validate_filename(filename: *const c_char) -> gboolean;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_plugin_info_get_aliases(self_: *mut NMVpnPluginInfo) -> *const *const c_char;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_plugin_info_get_auth_dialog(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_get_editor_plugin(self_: *mut NMVpnPluginInfo) -> *mut NMVpnEditorPlugin;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_get_filename(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_get_name(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_get_plugin(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_get_program(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_plugin_info_get_service(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_load_editor_plugin(self_: *mut NMVpnPluginInfo, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_lookup_property(self_: *mut NMVpnPluginInfo, group: *const c_char, key: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_plugin_info_set_editor_plugin(self_: *mut NMVpnPluginInfo, plugin: *mut NMVpnEditorPlugin);
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_plugin_info_supports_hints(self_: *mut NMVpnPluginInfo) -> gboolean;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_vpn_plugin_info_supports_multiple(self_: *mut NMVpnPluginInfo) -> gboolean;

    //=========================================================================
    // NMVpnPluginOld
    //=========================================================================
    pub fn nm_vpn_plugin_old_get_type() -> GType;
    pub fn nm_vpn_plugin_old_get_secret_flags(data: *mut glib::GHashTable, secret_name: *const c_char, out_flags: *mut NMSettingSecretFlags) -> gboolean;
    pub fn nm_vpn_plugin_old_read_vpn_details(fd: c_int, out_data: *mut *mut glib::GHashTable, out_secrets: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_vpn_plugin_old_disconnect(plugin: *mut NMVpnPluginOld, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_vpn_plugin_old_failure(plugin: *mut NMVpnPluginOld, reason: NMVpnPluginFailure);
    pub fn nm_vpn_plugin_old_get_connection(plugin: *mut NMVpnPluginOld) -> *mut gio::GDBusConnection;
    pub fn nm_vpn_plugin_old_get_state(plugin: *mut NMVpnPluginOld) -> NMVpnServiceState;
    pub fn nm_vpn_plugin_old_secrets_required(plugin: *mut NMVpnPluginOld, message: *const c_char, hints: *mut *const c_char);
    pub fn nm_vpn_plugin_old_set_ip4_config(plugin: *mut NMVpnPluginOld, ip4_config: *mut glib::GVariant);
    pub fn nm_vpn_plugin_old_set_login_banner(plugin: *mut NMVpnPluginOld, banner: *const c_char);
    pub fn nm_vpn_plugin_old_set_state(plugin: *mut NMVpnPluginOld, state: NMVpnServiceState);

    //=========================================================================
    // NMVpnServicePlugin
    //=========================================================================
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_get_secret_flags(data: *mut glib::GHashTable, secret_name: *const c_char, out_flags: *mut NMSettingSecretFlags) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_read_vpn_details(fd: c_int, out_data: *mut *mut glib::GHashTable, out_secrets: *mut *mut glib::GHashTable) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_disconnect(plugin: *mut NMVpnServicePlugin, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_failure(plugin: *mut NMVpnServicePlugin, reason: NMVpnPluginFailure);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_get_connection(plugin: *mut NMVpnServicePlugin) -> *mut gio::GDBusConnection;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_secrets_required(plugin: *mut NMVpnServicePlugin, message: *const c_char, hints: *mut *const c_char);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_set_config(plugin: *mut NMVpnServicePlugin, config: *mut glib::GVariant);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_set_ip4_config(plugin: *mut NMVpnServicePlugin, ip4_config: *mut glib::GVariant);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_set_ip6_config(plugin: *mut NMVpnServicePlugin, ip6_config: *mut glib::GVariant);
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_service_plugin_set_login_banner(plugin: *mut NMVpnServicePlugin, banner: *const c_char);
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_vpn_service_plugin_shutdown(plugin: *mut NMVpnServicePlugin);

    //=========================================================================
    // NMWifiP2PPeer
    //=========================================================================
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_type() -> GType;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_connection_valid(peer: *mut NMWifiP2PPeer, connection: *mut NMConnection) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_filter_connections(peer: *mut NMWifiP2PPeer, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_flags(peer: *mut NMWifiP2PPeer) -> NM80211ApFlags;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_hw_address(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_last_seen(peer: *mut NMWifiP2PPeer) -> c_int;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_manufacturer(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_model(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_model_number(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_name(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_serial(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_strength(peer: *mut NMWifiP2PPeer) -> u8;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_wifi_p2p_peer_get_wfd_ies(peer: *mut NMWifiP2PPeer) -> *mut glib::GBytes;

    //=========================================================================
    // NMWimaxNsp
    //=========================================================================
    pub fn nm_wimax_nsp_get_type() -> GType;
    pub fn nm_wimax_nsp_connection_valid(nsp: *mut NMWimaxNsp, connection: *mut NMConnection) -> gboolean;
    pub fn nm_wimax_nsp_filter_connections(nsp: *mut NMWimaxNsp, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    pub fn nm_wimax_nsp_get_name(nsp: *mut NMWimaxNsp) -> *const c_char;
    pub fn nm_wimax_nsp_get_network_type(nsp: *mut NMWimaxNsp) -> NMWimaxNspNetworkType;
    pub fn nm_wimax_nsp_get_signal_quality(nsp: *mut NMWimaxNsp) -> u32;

    //=========================================================================
    // NMConnection
    //=========================================================================
    pub fn nm_connection_get_type() -> GType;
    pub fn nm_connection_add_setting(connection: *mut NMConnection, setting: *mut NMSetting);
    pub fn nm_connection_clear_secrets(connection: *mut NMConnection);
    pub fn nm_connection_clear_secrets_with_flags(connection: *mut NMConnection, func: NMSettingClearSecretsWithFlagsFn, user_data: gpointer);
    pub fn nm_connection_clear_settings(connection: *mut NMConnection);
    pub fn nm_connection_compare(a: *mut NMConnection, b: *mut NMConnection, flags: NMSettingCompareFlags) -> gboolean;
    pub fn nm_connection_diff(a: *mut NMConnection, b: *mut NMConnection, flags: NMSettingCompareFlags, out_settings: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_connection_dump(connection: *mut NMConnection);
    pub fn nm_connection_for_each_setting_value(connection: *mut NMConnection, func: NMSettingValueIterFn, user_data: gpointer);
    pub fn nm_connection_get_connection_type(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_id(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_interface_name(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_path(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_setting(connection: *mut NMConnection, setting_type: GType) -> *mut NMSetting;
    pub fn nm_connection_get_setting_802_1x(connection: *mut NMConnection) -> *mut NMSetting8021x;
    pub fn nm_connection_get_setting_adsl(connection: *mut NMConnection) -> *mut NMSettingAdsl;
    pub fn nm_connection_get_setting_bluetooth(connection: *mut NMConnection) -> *mut NMSettingBluetooth;
    pub fn nm_connection_get_setting_bond(connection: *mut NMConnection) -> *mut NMSettingBond;
    pub fn nm_connection_get_setting_bridge(connection: *mut NMConnection) -> *mut NMSettingBridge;
    pub fn nm_connection_get_setting_bridge_port(connection: *mut NMConnection) -> *mut NMSettingBridgePort;
    pub fn nm_connection_get_setting_by_name(connection: *mut NMConnection, name: *const c_char) -> *mut NMSetting;
    pub fn nm_connection_get_setting_cdma(connection: *mut NMConnection) -> *mut NMSettingCdma;
    pub fn nm_connection_get_setting_connection(connection: *mut NMConnection) -> *mut NMSettingConnection;
    pub fn nm_connection_get_setting_dcb(connection: *mut NMConnection) -> *mut NMSettingDcb;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_connection_get_setting_dummy(connection: *mut NMConnection) -> *mut NMSettingDummy;
    pub fn nm_connection_get_setting_generic(connection: *mut NMConnection) -> *mut NMSettingGeneric;
    pub fn nm_connection_get_setting_gsm(connection: *mut NMConnection) -> *mut NMSettingGsm;
    pub fn nm_connection_get_setting_infiniband(connection: *mut NMConnection) -> *mut NMSettingInfiniband;
    pub fn nm_connection_get_setting_ip4_config(connection: *mut NMConnection) -> *mut NMSettingIP4Config;
    pub fn nm_connection_get_setting_ip6_config(connection: *mut NMConnection) -> *mut NMSettingIP6Config;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_connection_get_setting_ip_tunnel(connection: *mut NMConnection) -> *mut NMSettingIPTunnel;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_connection_get_setting_macsec(connection: *mut NMConnection) -> *mut NMSettingMacsec;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_connection_get_setting_macvlan(connection: *mut NMConnection) -> *mut NMSettingMacvlan;
    pub fn nm_connection_get_setting_olpc_mesh(connection: *mut NMConnection) -> *mut NMSettingOlpcMesh;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_connection_get_setting_ovs_bridge(connection: *mut NMConnection) -> *mut NMSettingOvsBridge;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_connection_get_setting_ovs_interface(connection: *mut NMConnection) -> *mut NMSettingOvsInterface;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_connection_get_setting_ovs_patch(connection: *mut NMConnection) -> *mut NMSettingOvsPatch;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_connection_get_setting_ovs_port(connection: *mut NMConnection) -> *mut NMSettingOvsPort;
    pub fn nm_connection_get_setting_ppp(connection: *mut NMConnection) -> *mut NMSettingPpp;
    pub fn nm_connection_get_setting_pppoe(connection: *mut NMConnection) -> *mut NMSettingPppoe;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_connection_get_setting_proxy(connection: *mut NMConnection) -> *mut NMSettingProxy;
    pub fn nm_connection_get_setting_serial(connection: *mut NMConnection) -> *mut NMSettingSerial;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_connection_get_setting_tc_config(connection: *mut NMConnection) -> *mut NMSettingTCConfig;
    pub fn nm_connection_get_setting_team(connection: *mut NMConnection) -> *mut NMSettingTeam;
    pub fn nm_connection_get_setting_team_port(connection: *mut NMConnection) -> *mut NMSettingTeamPort;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_connection_get_setting_tun(connection: *mut NMConnection) -> *mut NMSettingTun;
    pub fn nm_connection_get_setting_vlan(connection: *mut NMConnection) -> *mut NMSettingVlan;
    pub fn nm_connection_get_setting_vpn(connection: *mut NMConnection) -> *mut NMSettingVpn;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_connection_get_setting_vxlan(connection: *mut NMConnection) -> *mut NMSettingVxlan;
    pub fn nm_connection_get_setting_wimax(connection: *mut NMConnection) -> *mut NMSettingWimax;
    pub fn nm_connection_get_setting_wired(connection: *mut NMConnection) -> *mut NMSettingWired;
    pub fn nm_connection_get_setting_wireless(connection: *mut NMConnection) -> *mut NMSettingWireless;
    pub fn nm_connection_get_setting_wireless_security(connection: *mut NMConnection) -> *mut NMSettingWirelessSecurity;
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn nm_connection_get_settings(connection: *mut NMConnection, out_length: *mut c_uint) -> *mut *mut NMSetting;
    pub fn nm_connection_get_uuid(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_virtual_device_description(connection: *mut NMConnection) -> *mut c_char;
    pub fn nm_connection_is_type(connection: *mut NMConnection, type_: *const c_char) -> gboolean;
    pub fn nm_connection_is_virtual(connection: *mut NMConnection) -> gboolean;
    pub fn nm_connection_need_secrets(connection: *mut NMConnection, hints: *mut *mut glib::GPtrArray) -> *const c_char;
    pub fn nm_connection_normalize(connection: *mut NMConnection, parameters: *mut glib::GHashTable, modified: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_remove_setting(connection: *mut NMConnection, setting_type: GType);
    pub fn nm_connection_replace_settings(connection: *mut NMConnection, new_settings: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_replace_settings_from_connection(connection: *mut NMConnection, new_connection: *mut NMConnection);
    pub fn nm_connection_set_path(connection: *mut NMConnection, path: *const c_char);
    pub fn nm_connection_to_dbus(connection: *mut NMConnection, flags: NMConnectionSerializationFlags) -> *mut glib::GVariant;
    pub fn nm_connection_update_secrets(connection: *mut NMConnection, setting_name: *const c_char, secrets: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_verify(connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_connection_verify_secrets(connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMVpnEditor
    //=========================================================================
    pub fn nm_vpn_editor_get_type() -> GType;
    pub fn nm_vpn_editor_get_widget(editor: *mut NMVpnEditor) -> *mut gobject::GObject;
    pub fn nm_vpn_editor_update_connection(editor: *mut NMVpnEditor, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMVpnEditorPlugin
    //=========================================================================
    pub fn nm_vpn_editor_plugin_get_type() -> GType;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_editor_plugin_load(plugin_name: *const c_char, check_service: *const c_char, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_vpn_editor_plugin_load_from_file(plugin_name: *const c_char, check_service: *const c_char, check_owner: c_int, check_file: NMUtilsCheckFilePredicate, user_data: gpointer, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    pub fn nm_vpn_editor_plugin_export(plugin: *mut NMVpnEditorPlugin, path: *const c_char, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_vpn_editor_plugin_get_capabilities(plugin: *mut NMVpnEditorPlugin) -> NMVpnEditorPluginCapability;
    pub fn nm_vpn_editor_plugin_get_editor(plugin: *mut NMVpnEditorPlugin, connection: *mut NMConnection, error: *mut *mut glib::GError) -> *mut NMVpnEditor;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_editor_plugin_get_plugin_info(plugin: *mut NMVpnEditorPlugin) -> *mut NMVpnPluginInfo;
    pub fn nm_vpn_editor_plugin_get_suggested_filename(plugin: *mut NMVpnEditorPlugin, connection: *mut NMConnection) -> *mut c_char;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_editor_plugin_get_vt(plugin: *mut NMVpnEditorPlugin, vt: *mut NMVpnEditorPluginVT, vt_size: size_t) -> size_t;
    pub fn nm_vpn_editor_plugin_import(plugin: *mut NMVpnEditorPlugin, path: *const c_char, error: *mut *mut glib::GError) -> *mut NMConnection;
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn nm_vpn_editor_plugin_set_plugin_info(plugin: *mut NMVpnEditorPlugin, plugin_info: *mut NMVpnPluginInfo);

    //=========================================================================
    // Other functions
    //=========================================================================
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    pub fn nm_conn_wireguard_import(filename: *const c_char, error: *mut *mut glib::GError) -> *mut NMConnection;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_ethtool_optname_is_channels(optname: *const c_char) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_ethtool_optname_is_coalesce(optname: *const c_char) -> gboolean;
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn nm_ethtool_optname_is_eee(optname: *const c_char) -> gboolean;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn nm_ethtool_optname_is_feature(optname: *const c_char) -> gboolean;
    #[cfg(feature = "v1_32")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_32")))]
    pub fn nm_ethtool_optname_is_pause(optname: *const c_char) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn nm_ethtool_optname_is_ring(optname: *const c_char) -> gboolean;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_keyfile_read(keyfile: *mut glib::GKeyFile, base_dir: *const c_char, handler_flags: NMKeyfileHandlerFlags, handler: NMKeyfileReadHandler, user_data: *mut c_void, error: *mut *mut glib::GError) -> *mut NMConnection;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_keyfile_write(connection: *mut NMConnection, handler_flags: NMKeyfileHandlerFlags, handler: NMKeyfileWriteHandler, user_data: *mut c_void, error: *mut *mut glib::GError) -> *mut glib::GKeyFile;
    pub fn nm_utils_ap_mode_security_valid(type_: NMUtilsSecurityType, wifi_caps: NMDeviceWifiCapabilities) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn nm_utils_base64secret_decode(base64_key: *const c_char, required_key_len: size_t, out_key: *mut u8) -> gboolean;
    pub fn nm_utils_bin2hexstr(src: gconstpointer, len: size_t, final_len: c_int) -> *mut c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_utils_bond_mode_int_to_string(mode: c_int) -> *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_utils_bond_mode_string_to_int(mode: *const c_char) -> c_int;
    pub fn nm_utils_check_virtual_device_compatibility(virtual_type: GType, other_type: GType) -> gboolean;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_utils_ensure_gtypes();
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_utils_enum_from_str(type_: GType, str: *const c_char, out_value: *mut c_int, err_token: *mut *mut c_char) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_utils_enum_get_values(type_: GType, from: c_int, to: c_int) -> *mut *const c_char;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_utils_enum_to_str(type_: GType, value: c_int) -> *mut c_char;
    pub fn nm_utils_escape_ssid(ssid: *const u8, len: size_t) -> *const c_char;
    pub fn nm_utils_file_is_certificate(filename: *const c_char) -> gboolean;
    pub fn nm_utils_file_is_pkcs12(filename: *const c_char) -> gboolean;
    pub fn nm_utils_file_is_private_key(filename: *const c_char, out_encrypted: *mut gboolean) -> gboolean;
    pub fn nm_utils_file_search_in_paths(progname: *const c_char, try_first: *const c_char, paths: *const *const c_char, file_test_flags: glib::GFileTest, predicate: NMUtilsFileSearchInPathsPredicate, user_data: gpointer, error: *mut *mut glib::GError) -> *const c_char;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_utils_format_variant_attributes(attributes: *mut glib::GHashTable, attr_separator: c_char, key_value_separator: c_char) -> *mut c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_utils_get_timestamp_msec() -> i64;
    pub fn nm_utils_hexstr2bin(hex: *const c_char) -> *mut glib::GBytes;
    pub fn nm_utils_hwaddr_atoba(asc: *const c_char, length: size_t) -> *mut glib::GByteArray;
    pub fn nm_utils_hwaddr_aton(asc: *const c_char, buffer: gpointer, length: size_t) -> *mut u8;
    pub fn nm_utils_hwaddr_canonical(asc: *const c_char, length: ssize_t) -> *mut c_char;
    pub fn nm_utils_hwaddr_len(type_: c_int) -> size_t;
    pub fn nm_utils_hwaddr_matches(hwaddr1: gconstpointer, hwaddr1_len: ssize_t, hwaddr2: gconstpointer, hwaddr2_len: ssize_t) -> gboolean;
    pub fn nm_utils_hwaddr_ntoa(addr: gconstpointer, length: size_t) -> *mut c_char;
    pub fn nm_utils_hwaddr_valid(asc: *const c_char, length: ssize_t) -> gboolean;
    pub fn nm_utils_iface_valid_name(name: *const c_char) -> gboolean;
    pub fn nm_utils_inet4_ntop(inaddr: u32, dst: *mut c_char) -> *const c_char;
    pub fn nm_utils_inet6_ntop(in6addr: *const in6_addr, dst: *mut c_char) -> *const c_char;
    pub fn nm_utils_ip4_addresses_from_variant(value: *mut glib::GVariant, out_gateway: *mut *mut c_char) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip4_addresses_to_variant(addresses: *mut glib::GPtrArray, gateway: *const c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip4_dns_from_variant(value: *mut glib::GVariant) -> *mut *mut c_char;
    pub fn nm_utils_ip4_dns_to_variant(dns: *mut *mut c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip4_get_default_prefix(ip: u32) -> u32;
    pub fn nm_utils_ip4_netmask_to_prefix(netmask: u32) -> u32;
    pub fn nm_utils_ip4_prefix_to_netmask(prefix: u32) -> u32;
    pub fn nm_utils_ip4_routes_from_variant(value: *mut glib::GVariant) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip4_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ip6_addresses_from_variant(value: *mut glib::GVariant, out_gateway: *mut *mut c_char) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip6_addresses_to_variant(addresses: *mut glib::GPtrArray, gateway: *const c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip6_dns_from_variant(value: *mut glib::GVariant) -> *mut *mut c_char;
    pub fn nm_utils_ip6_dns_to_variant(dns: *mut *mut c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip6_routes_from_variant(value: *mut glib::GVariant) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip6_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_utils_ip_addresses_from_variant(value: *mut glib::GVariant, family: c_int) -> *mut glib::GPtrArray;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_utils_ip_addresses_to_variant(addresses: *mut glib::GPtrArray) -> *mut glib::GVariant;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_utils_ip_routes_from_variant(value: *mut glib::GVariant, family: c_int) -> *mut glib::GPtrArray;
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    pub fn nm_utils_ip_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ipaddr_valid(family: c_int, ip: *const c_char) -> gboolean;
    pub fn nm_utils_is_empty_ssid(ssid: *const u8, len: size_t) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_utils_is_json_object(str: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_utils_is_uuid(str: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_utils_is_valid_iface_name(name: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn nm_utils_parse_variant_attributes(string: *const c_char, attr_separator: c_char, key_value_separator: c_char, ignore_unknown: gboolean, spec: *const *const NMVariantAttributeSpec, error: *mut *mut glib::GError) -> *mut glib::GHashTable;
    #[cfg(feature = "v1_30")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    pub fn nm_utils_print(output_mode: c_int, msg: *const c_char);
    pub fn nm_utils_same_ssid(ssid1: *const u8, len1: size_t, ssid2: *const u8, len2: size_t, ignore_trailing_null: gboolean) -> gboolean;
    pub fn nm_utils_security_valid(type_: NMUtilsSecurityType, wifi_caps: NMDeviceWifiCapabilities, have_ap: gboolean, adhoc: gboolean, ap_flags: NM80211ApFlags, ap_wpa: NM80211ApSecurityFlags, ap_rsn: NM80211ApSecurityFlags) -> gboolean;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_utils_sriov_vf_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMSriovVF;
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn nm_utils_sriov_vf_to_str(vf: *const NMSriovVF, omit_index: gboolean, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn nm_utils_ssid_to_utf8(ssid: *const u8, len: size_t) -> *mut c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_utils_tc_action_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMTCAction;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_utils_tc_action_to_str(action: *mut NMTCAction, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_utils_tc_qdisc_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMTCQdisc;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_utils_tc_qdisc_to_str(qdisc: *mut NMTCQdisc, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_utils_tc_tfilter_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMTCTfilter;
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn nm_utils_tc_tfilter_to_str(tfilter: *mut NMTCTfilter, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn nm_utils_uuid_generate() -> *mut c_char;
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn nm_utils_version() -> c_uint;
    pub fn nm_utils_wep_key_valid(key: *const c_char, wep_type: NMWepKeyType) -> gboolean;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_utils_wifi_2ghz_freqs() -> *const c_uint;
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn nm_utils_wifi_5ghz_freqs() -> *const c_uint;
    pub fn nm_utils_wifi_channel_to_freq(channel: u32, band: *const c_char) -> u32;
    pub fn nm_utils_wifi_find_next_channel(channel: u32, direction: c_int, band: *mut c_char) -> u32;
    pub fn nm_utils_wifi_freq_to_channel(freq: u32) -> u32;
    pub fn nm_utils_wifi_is_channel_valid(channel: u32, band: *const c_char) -> gboolean;
    pub fn nm_utils_wifi_strength_bars(strength: u8) -> *const c_char;
    pub fn nm_utils_wpa_psk_valid(psk: *const c_char) -> gboolean;

}
