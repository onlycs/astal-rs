// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../../gir/gir-files
// DO NOT EDIT

use crate::{ffi,Action,ClosedReason,Urgency};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "AstalNotifdNotification")]
    pub struct Notification(Object<ffi::AstalNotifdNotification, ffi::AstalNotifdNotificationClass>);

    match fn {
        type_ => || ffi::astal_notifd_notification_get_type(),
    }
}

impl Notification {
        pub const NONE: Option<&'static Notification> = None;
    

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`Notification`] objects.
            ///
            /// This method returns an instance of [`NotificationBuilder`](crate::builders::NotificationBuilder) which can be used to create [`Notification`] objects.
            pub fn builder() -> NotificationBuilder {
                NotificationBuilder::new()
            }
        
}

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`Notification`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct NotificationBuilder {
            builder: glib::object::ObjectBuilder<'static, Notification>,
        }

        impl NotificationBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            pub fn time(self, time: i64) -> Self {
                            
                            Self { builder: self.builder.property("time", time), }
                        }

                            pub fn app_name(self, app_name: impl Into<glib::GString>) -> Self {
                            
                            Self { builder: self.builder.property("app-name", app_name.into()), }
                        }

                            pub fn app_icon(self, app_icon: impl Into<glib::GString>) -> Self {
                            
                            Self { builder: self.builder.property("app-icon", app_icon.into()), }
                        }

                            pub fn summary(self, summary: impl Into<glib::GString>) -> Self {
                            
                            Self { builder: self.builder.property("summary", summary.into()), }
                        }

                            pub fn body(self, body: impl Into<glib::GString>) -> Self {
                            
                            Self { builder: self.builder.property("body", body.into()), }
                        }

                            pub fn id(self, id: u32) -> Self {
                            
                            Self { builder: self.builder.property("id", id), }
                        }

                            pub fn expire_timeout(self, expire_timeout: i32) -> Self {
                            
                            Self { builder: self.builder.property("expire-timeout", expire_timeout), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`Notification`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Notification {
assert_initialized_main_thread!();
    self.builder.build() }
}

pub trait NotificationExt: IsA<Notification> + 'static {
    #[doc(alias = "astal_notifd_notification_get_hint")]
    #[doc(alias = "get_hint")]
    fn hint(&self, hint: &str) -> Option<glib::Variant> {
        unsafe {
            from_glib_full(ffi::astal_notifd_notification_get_hint(self.as_ref().to_glib_none().0, hint.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_str_hint")]
    #[doc(alias = "get_str_hint")]
    fn str_hint(&self, hint: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_str_hint(self.as_ref().to_glib_none().0, hint.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_bool_hint")]
    #[doc(alias = "get_bool_hint")]
    fn is_bool_hint(&self, hint: &str) -> bool {
        unsafe {
            from_glib(ffi::astal_notifd_notification_get_bool_hint(self.as_ref().to_glib_none().0, hint.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_int_hint")]
    #[doc(alias = "get_int_hint")]
    fn int_hint(&self, hint: &str) -> i32 {
        unsafe {
            ffi::astal_notifd_notification_get_int_hint(self.as_ref().to_glib_none().0, hint.to_glib_none().0)
        }
    }

    #[doc(alias = "astal_notifd_notification_get_byte_hint")]
    #[doc(alias = "get_byte_hint")]
    fn byte_hint(&self, hint: &str) -> u8 {
        unsafe {
            ffi::astal_notifd_notification_get_byte_hint(self.as_ref().to_glib_none().0, hint.to_glib_none().0)
        }
    }

    #[doc(alias = "astal_notifd_notification_dismiss")]
    fn dismiss(&self) {
        unsafe {
            ffi::astal_notifd_notification_dismiss(self.as_ref().to_glib_none().0);
        }
    }

    #[doc(alias = "astal_notifd_notification_invoke")]
    fn invoke(&self, action_id: &str) {
        unsafe {
            ffi::astal_notifd_notification_invoke(self.as_ref().to_glib_none().0, action_id.to_glib_none().0);
        }
    }

    #[doc(alias = "astal_notifd_notification_get_time")]
    #[doc(alias = "get_time")]
    fn time(&self) -> i64 {
        unsafe {
            ffi::astal_notifd_notification_get_time(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_notifd_notification_get_app_name")]
    #[doc(alias = "get_app_name")]
    fn app_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_app_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_app_icon")]
    #[doc(alias = "get_app_icon")]
    fn app_icon(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_app_icon(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_summary")]
    #[doc(alias = "get_summary")]
    fn summary(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_summary(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_body")]
    #[doc(alias = "get_body")]
    fn body(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_body(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_id")]
    #[doc(alias = "get_id")]
    fn id(&self) -> u32 {
        unsafe {
            ffi::astal_notifd_notification_get_id(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_notifd_notification_get_expire_timeout")]
    #[doc(alias = "get_expire_timeout")]
    fn expire_timeout(&self) -> i32 {
        unsafe {
            ffi::astal_notifd_notification_get_expire_timeout(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_notifd_notification_get_actions")]
    #[doc(alias = "get_actions")]
    fn actions(&self) -> Vec<Action> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::astal_notifd_notification_get_actions(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_image")]
    #[doc(alias = "get_image")]
    fn image(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_image(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_action_icons")]
    #[doc(alias = "get_action_icons")]
    fn is_action_icons(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_notifd_notification_get_action_icons(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_category")]
    #[doc(alias = "get_category")]
    fn category(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_category(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_desktop_entry")]
    #[doc(alias = "get_desktop_entry")]
    fn desktop_entry(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_desktop_entry(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_resident")]
    #[doc(alias = "get_resident")]
    fn is_resident(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_notifd_notification_get_resident(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_sound_file")]
    #[doc(alias = "get_sound_file")]
    fn sound_file(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_sound_file(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_sound_name")]
    #[doc(alias = "get_sound_name")]
    fn sound_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_notifd_notification_get_sound_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_suppress_sound")]
    #[doc(alias = "get_suppress_sound")]
    fn is_suppress_sound(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_notifd_notification_get_suppress_sound(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_transient")]
    #[doc(alias = "get_transient")]
    fn is_transient(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_notifd_notification_get_transient(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_notifd_notification_get_x")]
    #[doc(alias = "get_x")]
    fn x(&self) -> i32 {
        unsafe {
            ffi::astal_notifd_notification_get_x(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_notifd_notification_get_y")]
    #[doc(alias = "get_y")]
    fn y(&self) -> i32 {
        unsafe {
            ffi::astal_notifd_notification_get_y(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_notifd_notification_get_urgency")]
    #[doc(alias = "get_urgency")]
    fn urgency(&self) -> Urgency {
        unsafe {
            from_glib(ffi::astal_notifd_notification_get_urgency(self.as_ref().to_glib_none().0))
        }
    }

    fn set_time(&self, time: i64) {
        ObjectExt::set_property(self.as_ref(),"time", time)
    }

    #[doc(alias = "app-name")]
    fn set_app_name(&self, app_name: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"app-name", app_name)
    }

    #[doc(alias = "app-icon")]
    fn set_app_icon(&self, app_icon: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"app-icon", app_icon)
    }

    fn set_summary(&self, summary: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"summary", summary)
    }

    fn set_body(&self, body: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"body", body)
    }

    fn set_id(&self, id: u32) {
        ObjectExt::set_property(self.as_ref(),"id", id)
    }

    #[doc(alias = "expire-timeout")]
    fn set_expire_timeout(&self, expire_timeout: i32) {
        ObjectExt::set_property(self.as_ref(),"expire-timeout", expire_timeout)
    }

    #[doc(alias = "resolved")]
    fn connect_resolved<F: Fn(&Self, ClosedReason) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn resolved_trampoline<P: IsA<Notification>, F: Fn(&P, ClosedReason) + 'static>(this: *mut ffi::AstalNotifdNotification, reason: ffi::AstalNotifdClosedReason, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref(), from_glib(reason))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"resolved\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(resolved_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "dismissed")]
    fn connect_dismissed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn dismissed_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"dismissed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(dismissed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "invoked")]
    fn connect_invoked<F: Fn(&Self, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn invoked_trampoline<P: IsA<Notification>, F: Fn(&P, &str) + 'static>(this: *mut ffi::AstalNotifdNotification, action_id: *const std::ffi::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref(), &glib::GString::from_glib_borrow(action_id))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"invoked\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(invoked_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "time")]
    fn connect_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_time_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::time\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_time_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "app-name")]
    fn connect_app_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_app_name_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::app-name\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_app_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "app-icon")]
    fn connect_app_icon_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_app_icon_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::app-icon\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_app_icon_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "summary")]
    fn connect_summary_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_summary_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::summary\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_summary_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "body")]
    fn connect_body_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_body_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::body\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_body_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "id")]
    fn connect_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::id\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "expire-timeout")]
    fn connect_expire_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_expire_timeout_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::expire-timeout\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_expire_timeout_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "actions")]
    fn connect_actions_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_actions_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::actions\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_actions_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "image")]
    fn connect_image_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_image_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::image\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_image_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "action-icons")]
    fn connect_action_icons_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_action_icons_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::action-icons\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_action_icons_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "category")]
    fn connect_category_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_category_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::category\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_category_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "desktop-entry")]
    fn connect_desktop_entry_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_desktop_entry_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::desktop-entry\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_desktop_entry_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "resident")]
    fn connect_resident_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_resident_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::resident\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_resident_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "sound-file")]
    fn connect_sound_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_sound_file_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::sound-file\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_sound_file_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "sound-name")]
    fn connect_sound_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_sound_name_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::sound-name\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_sound_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "suppress-sound")]
    fn connect_suppress_sound_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_suppress_sound_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::suppress-sound\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_suppress_sound_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "transient")]
    fn connect_transient_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_transient_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::transient\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_transient_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "x")]
    fn connect_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::x\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_x_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "y")]
    fn connect_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_y_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::y\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_y_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "urgency")]
    fn connect_urgency_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_urgency_trampoline<P: IsA<Notification>, F: Fn(&P) + 'static>(this: *mut ffi::AstalNotifdNotification, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Notification::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::urgency\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_urgency_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Notification>> NotificationExt for O {}
