// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../../gir/gir-files
// DO NOT EDIT

use crate::{ffi,Output};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "AstalRiverRiver")]
    pub struct River(Object<ffi::AstalRiverRiver, ffi::AstalRiverRiverClass>);

    match fn {
        type_ => || ffi::astal_river_river_get_type(),
    }
}

impl River {
    #[doc(alias = "astal_river_river_new")]
    pub fn new() -> Option<River> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::astal_river_river_new())
        }
    }

    #[doc(alias = "astal_river_river_get_focused_output")]
    #[doc(alias = "get_focused_output")]
    #[doc(alias = "focused-output")]
    pub fn focused_output(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_river_river_get_focused_output(self.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_river_river_get_focused_view")]
    #[doc(alias = "get_focused_view")]
    #[doc(alias = "focused-view")]
    pub fn focused_view(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_river_river_get_focused_view(self.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_river_river_get_mode")]
    #[doc(alias = "get_mode")]
    pub fn mode(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_river_river_get_mode(self.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_river_river_get_output")]
    #[doc(alias = "get_output")]
    pub fn output(&self, name: &str) -> Option<Output> {
        unsafe {
            from_glib_none(ffi::astal_river_river_get_output(self.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_river_river_get_outputs")]
    #[doc(alias = "get_outputs")]
    pub fn outputs(&self) -> Vec<Output> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::astal_river_river_get_outputs(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "astal_river_river_run_command_async")]
    //pub fn run_command_async(&self, cmd: &[&str], callback: Option<Box_<dyn FnOnce(bool) + 'static>>) {
    //    unsafe { TODO: call ffi:astal_river_river_run_command_async() }
    //}

    #[doc(alias = "astal_river_river_get_default")]
    #[doc(alias = "get_default")]
    #[allow(clippy::should_implement_trait)]    pub fn default() -> Option<River> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::astal_river_river_get_default())
        }
    }

    #[doc(alias = "changed")]
    pub fn connect_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn changed_trampoline<F: Fn(&River) + 'static>(this: *mut ffi::AstalRiverRiver, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"changed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "output-added")]
    pub fn connect_output_added<F: Fn(&Self, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn output_added_trampoline<F: Fn(&River, &str) + 'static>(this: *mut ffi::AstalRiverRiver, output: *mut std::ffi::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &glib::GString::from_glib_borrow(output))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"output-added\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(output_added_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "output-removed")]
    pub fn connect_output_removed<F: Fn(&Self, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn output_removed_trampoline<F: Fn(&River, &str) + 'static>(this: *mut ffi::AstalRiverRiver, output: *mut std::ffi::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &glib::GString::from_glib_borrow(output))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"output-removed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(output_removed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "focused-output")]
    pub fn connect_focused_output_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_focused_output_trampoline<F: Fn(&River) + 'static>(this: *mut ffi::AstalRiverRiver, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::focused-output\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_focused_output_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "focused-view")]
    pub fn connect_focused_view_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_focused_view_trampoline<F: Fn(&River) + 'static>(this: *mut ffi::AstalRiverRiver, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::focused-view\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_focused_view_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mode")]
    pub fn connect_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mode_trampoline<F: Fn(&River) + 'static>(this: *mut ffi::AstalRiverRiver, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::mode\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mode_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "outputs")]
    pub fn connect_outputs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_outputs_trampoline<F: Fn(&River) + 'static>(this: *mut ffi::AstalRiverRiver, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::outputs\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_outputs_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}
