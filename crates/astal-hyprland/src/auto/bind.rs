// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../../gir/gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "AstalHyprlandBind")]
    pub struct Bind(Object<ffi::AstalHyprlandBind, ffi::AstalHyprlandBindClass>);

    match fn {
        type_ => || ffi::astal_hyprland_bind_get_type(),
    }
}

impl Bind {
        pub const NONE: Option<&'static Bind> = None;
    

    #[doc(alias = "astal_hyprland_bind_new")]
    pub fn new() -> Bind {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::astal_hyprland_bind_new())
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`Bind`] objects.
            ///
            /// This method returns an instance of [`BindBuilder`](crate::builders::BindBuilder) which can be used to create [`Bind`] objects.
            pub fn builder() -> BindBuilder {
                BindBuilder::new()
            }
        
}

impl Default for Bind {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`Bind`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct BindBuilder {
            builder: glib::object::ObjectBuilder<'static, Bind>,
        }

        impl BindBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            pub fn locked(self, locked: bool) -> Self {
                            
                            Self { builder: self.builder.property("locked", locked), }
                        }

                            pub fn mouse(self, mouse: bool) -> Self {
                            
                            Self { builder: self.builder.property("mouse", mouse), }
                        }

                            pub fn release(self, release: bool) -> Self {
                            
                            Self { builder: self.builder.property("release", release), }
                        }

                            pub fn repeat(self, repeat: bool) -> Self {
                            
                            Self { builder: self.builder.property("repeat", repeat), }
                        }

                            pub fn non_consuming(self, non_consuming: bool) -> Self {
                            
                            Self { builder: self.builder.property("non-consuming", non_consuming), }
                        }

                            pub fn modmask(self, modmask: i64) -> Self {
                            
                            Self { builder: self.builder.property("modmask", modmask), }
                        }

                            pub fn submap(self, submap: impl Into<glib::GString>) -> Self {
                            
                            Self { builder: self.builder.property("submap", submap.into()), }
                        }

                            pub fn key(self, key: impl Into<glib::GString>) -> Self {
                            
                            Self { builder: self.builder.property("key", key.into()), }
                        }

                            pub fn keycode(self, keycode: i64) -> Self {
                            
                            Self { builder: self.builder.property("keycode", keycode), }
                        }

                            pub fn catch_all(self, catch_all: bool) -> Self {
                            
                            Self { builder: self.builder.property("catch-all", catch_all), }
                        }

                            pub fn dispatcher(self, dispatcher: impl Into<glib::GString>) -> Self {
                            
                            Self { builder: self.builder.property("dispatcher", dispatcher.into()), }
                        }

                            pub fn arg(self, arg: impl Into<glib::GString>) -> Self {
                            
                            Self { builder: self.builder.property("arg", arg.into()), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`Bind`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Bind {
assert_initialized_main_thread!();
    self.builder.build() }
}

pub trait BindExt: IsA<Bind> + 'static {
    #[doc(alias = "astal_hyprland_bind_get_locked")]
    #[doc(alias = "get_locked")]
    fn is_locked(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_hyprland_bind_get_locked(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_locked")]
    fn set_locked(&self, value: bool) {
        unsafe {
            ffi::astal_hyprland_bind_set_locked(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_mouse")]
    #[doc(alias = "get_mouse")]
    fn is_mouse(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_hyprland_bind_get_mouse(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_mouse")]
    fn set_mouse(&self, value: bool) {
        unsafe {
            ffi::astal_hyprland_bind_set_mouse(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_release")]
    #[doc(alias = "get_release")]
    fn is_release(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_hyprland_bind_get_release(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_release")]
    fn set_release(&self, value: bool) {
        unsafe {
            ffi::astal_hyprland_bind_set_release(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_repeat")]
    #[doc(alias = "get_repeat")]
    fn is_repeat(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_hyprland_bind_get_repeat(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_repeat")]
    fn set_repeat(&self, value: bool) {
        unsafe {
            ffi::astal_hyprland_bind_set_repeat(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_non_consuming")]
    #[doc(alias = "get_non_consuming")]
    fn is_non_consuming(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_hyprland_bind_get_non_consuming(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_non_consuming")]
    fn set_non_consuming(&self, value: bool) {
        unsafe {
            ffi::astal_hyprland_bind_set_non_consuming(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_modmask")]
    #[doc(alias = "get_modmask")]
    fn modmask(&self) -> i64 {
        unsafe {
            ffi::astal_hyprland_bind_get_modmask(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_modmask")]
    fn set_modmask(&self, value: i64) {
        unsafe {
            ffi::astal_hyprland_bind_set_modmask(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_submap")]
    #[doc(alias = "get_submap")]
    fn submap(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_hyprland_bind_get_submap(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_submap")]
    fn set_submap(&self, value: &str) {
        unsafe {
            ffi::astal_hyprland_bind_set_submap(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_key")]
    #[doc(alias = "get_key")]
    fn key(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_hyprland_bind_get_key(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_key")]
    fn set_key(&self, value: &str) {
        unsafe {
            ffi::astal_hyprland_bind_set_key(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_keycode")]
    #[doc(alias = "get_keycode")]
    fn keycode(&self) -> i64 {
        unsafe {
            ffi::astal_hyprland_bind_get_keycode(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_keycode")]
    fn set_keycode(&self, value: i64) {
        unsafe {
            ffi::astal_hyprland_bind_set_keycode(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_catch_all")]
    #[doc(alias = "get_catch_all")]
    fn is_catch_all(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_hyprland_bind_get_catch_all(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_catch_all")]
    fn set_catch_all(&self, value: bool) {
        unsafe {
            ffi::astal_hyprland_bind_set_catch_all(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_dispatcher")]
    #[doc(alias = "get_dispatcher")]
    fn dispatcher(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_hyprland_bind_get_dispatcher(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_dispatcher")]
    fn set_dispatcher(&self, value: &str) {
        unsafe {
            ffi::astal_hyprland_bind_set_dispatcher(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "astal_hyprland_bind_get_arg")]
    #[doc(alias = "get_arg")]
    fn arg(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::astal_hyprland_bind_get_arg(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_hyprland_bind_set_arg")]
    fn set_arg(&self, value: &str) {
        unsafe {
            ffi::astal_hyprland_bind_set_arg(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "locked")]
    fn connect_locked_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_locked_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::locked\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_locked_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mouse")]
    fn connect_mouse_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mouse_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::mouse\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mouse_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "release")]
    fn connect_release_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_release_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::release\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_release_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "repeat")]
    fn connect_repeat_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_repeat_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::repeat\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_repeat_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "non-consuming")]
    fn connect_non_consuming_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_non_consuming_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::non-consuming\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_non_consuming_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "modmask")]
    fn connect_modmask_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_modmask_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::modmask\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_modmask_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "submap")]
    fn connect_submap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_submap_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::submap\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_submap_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "key")]
    fn connect_key_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_key_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::key\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_key_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "keycode")]
    fn connect_keycode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_keycode_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::keycode\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_keycode_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "catch-all")]
    fn connect_catch_all_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_catch_all_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::catch-all\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_catch_all_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "dispatcher")]
    fn connect_dispatcher_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dispatcher_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::dispatcher\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_dispatcher_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "arg")]
    fn connect_arg_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_arg_trampoline<P: IsA<Bind>, F: Fn(&P) + 'static>(this: *mut ffi::AstalHyprlandBind, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Bind::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::arg\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_arg_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Bind>> BindExt for O {}
