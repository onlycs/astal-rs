// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../../gir/gir-files
// DO NOT EDIT

use crate::{ffi,Application};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "AstalAppsApps")]
    pub struct Apps(Object<ffi::AstalAppsApps, ffi::AstalAppsAppsClass>);

    match fn {
        type_ => || ffi::astal_apps_apps_get_type(),
    }
}

impl Apps {
        pub const NONE: Option<&'static Apps> = None;
    

    #[doc(alias = "astal_apps_apps_new")]
    pub fn new() -> Apps {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::astal_apps_apps_new())
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`Apps`] objects.
            ///
            /// This method returns an instance of [`AppsBuilder`](crate::builders::AppsBuilder) which can be used to create [`Apps`] objects.
            pub fn builder() -> AppsBuilder {
                AppsBuilder::new()
            }
        
}

impl Default for Apps {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`Apps`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct AppsBuilder {
            builder: glib::object::ObjectBuilder<'static, Apps>,
        }

        impl AppsBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            pub fn show_hidden(self, show_hidden: bool) -> Self {
                            
                            Self { builder: self.builder.property("show-hidden", show_hidden), }
                        }

                            pub fn min_score(self, min_score: f64) -> Self {
                            
                            Self { builder: self.builder.property("min-score", min_score), }
                        }

                            pub fn name_multiplier(self, name_multiplier: f64) -> Self {
                            
                            Self { builder: self.builder.property("name-multiplier", name_multiplier), }
                        }

                            pub fn entry_multiplier(self, entry_multiplier: f64) -> Self {
                            
                            Self { builder: self.builder.property("entry-multiplier", entry_multiplier), }
                        }

                            pub fn executable_multiplier(self, executable_multiplier: f64) -> Self {
                            
                            Self { builder: self.builder.property("executable-multiplier", executable_multiplier), }
                        }

                            pub fn description_multiplier(self, description_multiplier: f64) -> Self {
                            
                            Self { builder: self.builder.property("description-multiplier", description_multiplier), }
                        }

                            pub fn keywords_multiplier(self, keywords_multiplier: f64) -> Self {
                            
                            Self { builder: self.builder.property("keywords-multiplier", keywords_multiplier), }
                        }

                            pub fn categories_multiplier(self, categories_multiplier: f64) -> Self {
                            
                            Self { builder: self.builder.property("categories-multiplier", categories_multiplier), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`Apps`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Apps {
assert_initialized_main_thread!();
    self.builder.build() }
}

pub trait AppsExt: IsA<Apps> + 'static {
    #[doc(alias = "astal_apps_apps_fuzzy_score")]
    fn fuzzy_score(&self, search: &str, a: &impl IsA<Application>) -> f64 {
        unsafe {
            ffi::astal_apps_apps_fuzzy_score(self.as_ref().to_glib_none().0, search.to_glib_none().0, a.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_exact_score")]
    fn exact_score(&self, search: &str, a: &impl IsA<Application>) -> f64 {
        unsafe {
            ffi::astal_apps_apps_exact_score(self.as_ref().to_glib_none().0, search.to_glib_none().0, a.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_fuzzy_query")]
    fn fuzzy_query(&self, search: Option<&str>) -> Vec<Application> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::astal_apps_apps_fuzzy_query(self.as_ref().to_glib_none().0, search.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_apps_apps_exact_query")]
    fn exact_query(&self, search: Option<&str>) -> Vec<Application> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::astal_apps_apps_exact_query(self.as_ref().to_glib_none().0, search.to_glib_none().0))
        }
    }

    #[doc(alias = "astal_apps_apps_reload")]
    fn reload(&self) {
        unsafe {
            ffi::astal_apps_apps_reload(self.as_ref().to_glib_none().0);
        }
    }

    #[doc(alias = "astal_apps_apps_get_show_hidden")]
    #[doc(alias = "get_show_hidden")]
    fn shows_hidden(&self) -> bool {
        unsafe {
            from_glib(ffi::astal_apps_apps_get_show_hidden(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_apps_apps_set_show_hidden")]
    fn set_show_hidden(&self, value: bool) {
        unsafe {
            ffi::astal_apps_apps_set_show_hidden(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "astal_apps_apps_get_list")]
    #[doc(alias = "get_list")]
    fn list(&self) -> Vec<Application> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::astal_apps_apps_get_list(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "astal_apps_apps_get_min_score")]
    #[doc(alias = "get_min_score")]
    fn min_score(&self) -> f64 {
        unsafe {
            ffi::astal_apps_apps_get_min_score(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_set_min_score")]
    fn set_min_score(&self, value: f64) {
        unsafe {
            ffi::astal_apps_apps_set_min_score(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "astal_apps_apps_get_name_multiplier")]
    #[doc(alias = "get_name_multiplier")]
    fn name_multiplier(&self) -> f64 {
        unsafe {
            ffi::astal_apps_apps_get_name_multiplier(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_set_name_multiplier")]
    fn set_name_multiplier(&self, value: f64) {
        unsafe {
            ffi::astal_apps_apps_set_name_multiplier(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "astal_apps_apps_get_entry_multiplier")]
    #[doc(alias = "get_entry_multiplier")]
    fn entry_multiplier(&self) -> f64 {
        unsafe {
            ffi::astal_apps_apps_get_entry_multiplier(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_set_entry_multiplier")]
    fn set_entry_multiplier(&self, value: f64) {
        unsafe {
            ffi::astal_apps_apps_set_entry_multiplier(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "astal_apps_apps_get_executable_multiplier")]
    #[doc(alias = "get_executable_multiplier")]
    fn executable_multiplier(&self) -> f64 {
        unsafe {
            ffi::astal_apps_apps_get_executable_multiplier(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_set_executable_multiplier")]
    fn set_executable_multiplier(&self, value: f64) {
        unsafe {
            ffi::astal_apps_apps_set_executable_multiplier(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "astal_apps_apps_get_description_multiplier")]
    #[doc(alias = "get_description_multiplier")]
    fn description_multiplier(&self) -> f64 {
        unsafe {
            ffi::astal_apps_apps_get_description_multiplier(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_set_description_multiplier")]
    fn set_description_multiplier(&self, value: f64) {
        unsafe {
            ffi::astal_apps_apps_set_description_multiplier(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "astal_apps_apps_get_keywords_multiplier")]
    #[doc(alias = "get_keywords_multiplier")]
    fn keywords_multiplier(&self) -> f64 {
        unsafe {
            ffi::astal_apps_apps_get_keywords_multiplier(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_set_keywords_multiplier")]
    fn set_keywords_multiplier(&self, value: f64) {
        unsafe {
            ffi::astal_apps_apps_set_keywords_multiplier(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "astal_apps_apps_get_categories_multiplier")]
    #[doc(alias = "get_categories_multiplier")]
    fn categories_multiplier(&self) -> f64 {
        unsafe {
            ffi::astal_apps_apps_get_categories_multiplier(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "astal_apps_apps_set_categories_multiplier")]
    fn set_categories_multiplier(&self, value: f64) {
        unsafe {
            ffi::astal_apps_apps_set_categories_multiplier(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "show-hidden")]
    fn connect_show_hidden_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_show_hidden_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::show-hidden\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_show_hidden_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "list")]
    fn connect_list_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_list_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::list\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_list_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "min-score")]
    fn connect_min_score_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_score_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::min-score\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_min_score_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "name-multiplier")]
    fn connect_name_multiplier_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_name_multiplier_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::name-multiplier\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_name_multiplier_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "entry-multiplier")]
    fn connect_entry_multiplier_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_entry_multiplier_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::entry-multiplier\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_entry_multiplier_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "executable-multiplier")]
    fn connect_executable_multiplier_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_executable_multiplier_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::executable-multiplier\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_executable_multiplier_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "description-multiplier")]
    fn connect_description_multiplier_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_description_multiplier_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::description-multiplier\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_description_multiplier_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "keywords-multiplier")]
    fn connect_keywords_multiplier_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_keywords_multiplier_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::keywords-multiplier\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_keywords_multiplier_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "categories-multiplier")]
    fn connect_categories_multiplier_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_categories_multiplier_trampoline<P: IsA<Apps>, F: Fn(&P) + 'static>(this: *mut ffi::AstalAppsApps, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Apps::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::categories-multiplier\0".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_categories_multiplier_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Apps>> AppsExt for O {}
